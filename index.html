
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="Documentation for arkIQ IoT data management and alerting.">
      
      
      
      
      
        <link rel="next" href="architecture/">
      
      
      <link rel="icon" href="https://media.licdn.com/dms/image/v2/D4E0BAQGm_K9hKOC6iA/company-logo_200_200/B4EZXIsZm.H0AI-/0/1742828837776/arkiq_logo?e=2147483647&v=beta&t=s-mwQWrz3zXGHuindYjJPvLAkCWT5rPnCRMuShekDI8">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.6.15">
    
    
      
        <title>arkIQ Documentation</title>
      
    
    
      <link rel="stylesheet" href="assets/stylesheets/main.342714a4.min.css">
      
        
        <link rel="stylesheet" href="assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Verdana:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Verdana";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL(".",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#arkiq-system-documentation" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="." title="arkIQ Documentation" class="md-header__button md-logo" aria-label="arkIQ Documentation" data-md-component="logo">
      
  <img src="https://thearkiq.com/wp-content/uploads/2024/03/arkIQ-Horizontal-TM-PNG-768x290.png" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            arkIQ Documentation
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Home
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-hidden="true"  type="radio" name="__palette" id="__palette_0">
    
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m17.75 4.09-2.53 1.94.91 3.06-2.63-1.81-2.63 1.81.91-3.06-2.53-1.94L12.44 4l1.06-3 1.06 3zm3.5 6.91-1.64 1.25.59 1.98-1.7-1.17-1.7 1.17.59-1.98L15.75 11l2.06-.05L18.5 9l.69 1.95zm-2.28 4.95c.83-.08 1.72 1.1 1.19 1.85-.32.45-.66.87-1.08 1.27C15.17 23 8.84 23 4.94 19.07c-3.91-3.9-3.91-10.24 0-14.14.4-.4.82-.76 1.27-1.08.75-.53 1.93.36 1.85 1.19-.27 2.86.69 5.83 2.89 8.02a9.96 9.96 0 0 0 8.02 2.89m-1.64 2.02a12.08 12.08 0 0 1-7.8-3.47c-2.17-2.19-3.33-5-3.49-7.82-2.81 3.14-2.7 7.96.31 10.98 3.02 3.01 7.84 3.12 10.98.31"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
        <div class="md-search__suggest" data-md-component="search-suggest"></div>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
            
<nav class="md-tabs" aria-label="Tabs" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
    
  
  
    <li class="md-tabs__item md-tabs__item--active">
      <a href="." class="md-tabs__link">
        
  
  
    
  
  Home

      </a>
    </li>
  

      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="architecture/" class="md-tabs__link">
        
  
  
    
  
  Architecture

      </a>
    </li>
  

      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="services/auth/" class="md-tabs__link">
          
  
  
  Services

        </a>
      </li>
    
  

      
    </ul>
  </div>
</nav>
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="." title="arkIQ Documentation" class="md-nav__button md-logo" aria-label="arkIQ Documentation" data-md-component="logo">
      
  <img src="https://thearkiq.com/wp-content/uploads/2024/03/arkIQ-Horizontal-TM-PNG-768x290.png" alt="logo">

    </a>
    arkIQ Documentation
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  
  <span class="md-ellipsis">
    Home
    
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="." class="md-nav__link md-nav__link--active">
        
  
  
  <span class="md-ellipsis">
    Home
    
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#ttn-to-aws" class="md-nav__link">
    <span class="md-ellipsis">
      TTN to AWS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#device-types" class="md-nav__link">
    <span class="md-ellipsis">
      Device Types:
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#iqwl" class="md-nav__link">
    <span class="md-ellipsis">
      IQWL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#iqwl-dual-chip" class="md-nav__link">
    <span class="md-ellipsis">
      IQWL Dual Chip
    </span>
  </a>
  
    <nav class="md-nav" aria-label="IQWL Dual Chip">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#what-are-the-difference-between-iqwl-chip-lorawan-and-iqwl-chip-sidewalk" class="md-nav__link">
    <span class="md-ellipsis">
      What are the difference between IQWL chip LoRaWAN and IQWL chip Sidewalk
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#iqsl" class="md-nav__link">
    <span class="md-ellipsis">
      IQSL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bytes" class="md-nav__link">
    <span class="md-ellipsis">
      Bytes:
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#criptographic" class="md-nav__link">
    <span class="md-ellipsis">
      Criptographic:
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bytes_1" class="md-nav__link">
    <span class="md-ellipsis">
      Bytes:
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#criptographic_1" class="md-nav__link">
    <span class="md-ellipsis">
      Criptographic:
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Criptographic:">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#iqsl-payload-formatter-ttn" class="md-nav__link">
    <span class="md-ellipsis">
      IQSL Payload Formatter (TTN):
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#iqsv" class="md-nav__link">
    <span class="md-ellipsis">
      IQSV
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#iqwm" class="md-nav__link">
    <span class="md-ellipsis">
      IQWM
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#lambdas-for-example" class="md-nav__link">
    <span class="md-ellipsis">
      Lambdas for example
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Lambdas for example">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#lambda-functions" class="md-nav__link">
    <span class="md-ellipsis">
      Lambda Functions
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="architecture/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Architecture
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" >
        
          
          <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    Services
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            Services
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="services/auth/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Auth Service
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="services/iot-data/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    IoT Data Service
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="services/alerting/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Alerting Service
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#ttn-to-aws" class="md-nav__link">
    <span class="md-ellipsis">
      TTN to AWS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#device-types" class="md-nav__link">
    <span class="md-ellipsis">
      Device Types:
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#iqwl" class="md-nav__link">
    <span class="md-ellipsis">
      IQWL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#iqwl-dual-chip" class="md-nav__link">
    <span class="md-ellipsis">
      IQWL Dual Chip
    </span>
  </a>
  
    <nav class="md-nav" aria-label="IQWL Dual Chip">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#what-are-the-difference-between-iqwl-chip-lorawan-and-iqwl-chip-sidewalk" class="md-nav__link">
    <span class="md-ellipsis">
      What are the difference between IQWL chip LoRaWAN and IQWL chip Sidewalk
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#iqsl" class="md-nav__link">
    <span class="md-ellipsis">
      IQSL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bytes" class="md-nav__link">
    <span class="md-ellipsis">
      Bytes:
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#criptographic" class="md-nav__link">
    <span class="md-ellipsis">
      Criptographic:
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bytes_1" class="md-nav__link">
    <span class="md-ellipsis">
      Bytes:
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#criptographic_1" class="md-nav__link">
    <span class="md-ellipsis">
      Criptographic:
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Criptographic:">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#iqsl-payload-formatter-ttn" class="md-nav__link">
    <span class="md-ellipsis">
      IQSL Payload Formatter (TTN):
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#iqsv" class="md-nav__link">
    <span class="md-ellipsis">
      IQSV
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#iqwm" class="md-nav__link">
    <span class="md-ellipsis">
      IQWM
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#lambdas-for-example" class="md-nav__link">
    <span class="md-ellipsis">
      Lambdas for example
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Lambdas for example">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#lambda-functions" class="md-nav__link">
    <span class="md-ellipsis">
      Lambda Functions
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  



<h1 id="arkiq-system-documentation">arkIQ System Documentation</h1>
<h3 id="ttn-to-aws">TTN to AWS</h3>
<p><img alt="TTN AWS Integration Diagram" src="https://arkiq-open-images.s3.us-east-1.amazonaws.com/ttn+aws+integration+diagram.png" /></p>
<ol>
<li>
<p><strong>Uplink sent from TTN to AWS</strong></p>
</li>
<li>
<p><strong>AWS IoT Core</strong> receives the uplinks.<br />
   A separate <strong>IoT Core Rule</strong> is defined for each device type, extracting the necessary information from each uplink.</p>
</li>
<li>
<p>The extracted data is sent to a <strong>dedicated queue</strong> for each device type.</p>
</li>
<li>
<p>Each queue triggers a <strong>separate Lambda function</strong>, which processes the received data and follows a distinct path depending on the device.</p>
</li>
<li>
<p>Alerts<br />
If necessary, alerts are sent via <strong>email</strong> and <strong>SMS</strong>.</p>
</li>
<li>
<p>Database Storage<br />
Processed data is stored in the <strong>database</strong>.</p>
</li>
</ol>
<p><strong>From now on (September, 2025) the new devices should be onboarded on AWS IoT Core</strong></p>
<hr />
<hr />
<hr />
<h3 id="device-types">Device Types:</h3>
<p>arkIQ has different types of devices</p>
<p>1- IQWL: Leak Sensor<br />
2- IQSL: Leak Sensor + Toilet Sensor<br />
3- IQWM: Water Meter<br />
4- IQSV: Smart Valve  </p>
<h3 id="iqwl">IQWL</h3>
<p>Attributes:
Water Leak Detected: boolean<br />
Tamper Detected: boolean<br />
Button Pressed: boolean<br />
Temperature (Celsius): decimal<br />
Humidity (%): decimal<br />
Battery (V): decimal  </p>
<p>Payload:</p>
<p>Bytes:
00 08 d2 00 3e</p>
<p>Criptographic:
AAjSAD4=</p>
<p>Decoded:</p>
<pre><code class="language-json">{
  &quot;battery_volt&quot;: 2.9,
  &quot;button&quot;: 0,
  &quot;humi&quot;: 62,
  &quot;tamper&quot;: 0,
  &quot;temperature&quot;: 21,
  &quot;water&quot;: 0
}
</code></pre>
<p>Payload Formatter (TTN):</p>
<pre><code class="language-js">function hex2bin(hex){
  return (parseInt(hex, 16).toString(2)).padStart(8, '0');
}

//IQWL sensor
function decodeUplink(input) {
    let fPort = input.fPort;
    let payloadlens = input.bytes.length;
    if(fPort==126 &amp;&amp; payloadlens==5){
        let intput_list = input.bytes;
        let battery_int=intput_list[1];// battery calculate
        battery_volt = (21+battery_int)/10;
        temperature_hex= (intput_list[3].toString(16).padStart(2, '0'))+(intput_list[2].toString(16).padStart(2, '0'));  //temperature calculate
        if((parseInt(temperature_hex, 16))&gt;1250){
            temperature = ((parseInt(temperature_hex, 16))-65536)/10;
        }
        else{
            temperature = (parseInt(temperature_hex, 16))/10;
        }

        humi =  intput_list[4]; //Humidity calculate
        let water_hex = intput_list[0].toString(16).padStart(2, '0'); // Sensor Status calculate
        let water_binary = hex2bin(water_hex); 
        let water_st = water_binary.substring(7, 8); 
        let button_st = water_binary.substring(6, 7); 
        let tamper_st = water_binary.substring(5, 6); 

        water = parseInt(water_st); // water status
        button = parseInt(button_st); // Button pressed
        tamper = parseInt(tamper_st); // Tamper detected

        return {
        data: {
        battery_volt,
        temperature,
        humi,
        water,
        button,
        tamper
        },
        };
    }
    else if (fPort==126 &amp;&amp; payloadlens==4){
        let intput_list = input.bytes;
        let battery_int=intput_list[1];// battery calculate
        battery_volt = (21+battery_int)/10;
        temperature_int= intput_list[2]; //temperature calculate
        if(temperature_int&gt;125){
            temperature = temperature_int-256;
        }
        else{
            temperature = temperature_int;
        }
        humi =  intput_list[3]; //Humidity calculate

        let water_hex = intput_list[0].toString(16).padStart(2, '0'); // Sensor Status calculate
        let water_binary = hex2bin(water_hex); 
        let water_st = water_binary.substring(7, 8); 
        let button_st = water_binary.substring(6, 7); 
        let tamper_st = water_binary.substring(5, 6); 

        water = parseInt(water_st); // water status
        button = parseInt(button_st); // Button pressed
        tamper = parseInt(tamper_st); // Tamper detected

        return {
        data: {
        battery_volt,
        temperature,
        humi,
        water,
        button,
        tamper
        },
        };
    }
    //Fireware Info
    else if (fPort==204 &amp;&amp; payloadlens==9){
    let message = 'This is fireware info.';
    byteArray = input.bytes;
    let payload = byteArray.map(byte =&gt; byte.toString(16).padStart(2, '0')).join('');
    return {
      data: {
              fPort,
                message,
                payload
              },
            };
    }
    //Configuration Info
    else if (fPort==204 &amp;&amp; payloadlens==11){
    let message = 'This is configuration info.';
    byteArray = input.bytes;
    let payload = byteArray.map(byte =&gt; byte.toString(16).padStart(2, '0')).join('');
    return {
      data: {
              fPort,
                message,
                payload
              },
            };
    }
    else{
            let fPort = input.fPort;
            let payloadlength = input.bytes.length;
            let message = 'Invalid fPort or payload length';
            return {
              data: {
                fPort,
                payloadlength,
                message,
              },
            };
    }
}
</code></pre>
<h3 id="iqwl-dual-chip">IQWL Dual Chip</h3>
<p>Some IQWL has dual chip:<br />
1. LoRaWAN<br />
2. Amazon Sidewalk  </p>
<p>By default, when it's turned ON, it will try to connect to LoRaWAN.  </p>
<p>If after 3 attempts, it doesn't connect to LoRaWAN, it will connect to Amazon Sidewalk.  </p>
<h4 id="what-are-the-difference-between-iqwl-chip-lorawan-and-iqwl-chip-sidewalk">What are the difference between IQWL chip LoRaWAN and IQWL chip Sidewalk</h4>
<ul>
<li>LoRaWAN needs to be connected to a network and be cover by a LoRaWAN gateway. Sidewalk doesn't need Gateways.</li>
<li>Sidewalk uses the devices from Amazon to spread the connection</li>
<li>Sidewalk nowadays (year 2025) only work in United States, but soon it will be active to other countries as well (<a href="https://coverage.sidewalk.amazon/">coverage.sidewalk.amazon</a>)</li>
</ul>
<p><strong>In September 2025, the Sidewalk devices are not in arkIQ cloud. It's in another cloud. The uplinks are forwarded via a Lambda that is connected to an AWS IoT Core Rule from the other AWS Account. We are working on it to bring all the Sidewalk chips to our cloud</strong></p>
<p>The Lambda that receives the messages from Amazon Sidewalk is called ReceiveUplinkBrowanSidewalkLambda. This is the payload structure of every payload:</p>
<pre><code class="language-json">{
    &quot;MessageId&quot;: &quot;48a0c3cb-7dc6-4e03-b738-9f3565808bd0&quot;,
    &quot;WirelessDeviceId&quot;: &quot;cda427e6-1f7c-45bb-aeb2-7324852a191f&quot;,
    &quot;PayloadData&quot;: &quot;N2UwMDBmY2YwMDQw&quot;,
    &quot;WirelessMetadata&quot;: {
        &quot;Sidewalk&quot;: {
            &quot;CmdExStatus&quot;: &quot;COMMAND_EXEC_STATUS_UNSPECIFIED&quot;,
            &quot;MessageType&quot;: &quot;CUSTOM_COMMAND_ID_NOTIFY&quot;,
            &quot;NackExStatus&quot;: [],
            &quot;Seq&quot;: 20,
            &quot;SidewalkId&quot;: &quot;B659A2463A&quot;,
            &quot;Timestamp&quot;: &quot;2025-09-22T14: 47: 18.911Z&quot;
        }
    }
}
</code></pre>
<p>This payoload doesn't contain the DEVEUI or the Serial Number of the device. Rather, it contains the <strong>WirelessDeviceId</strong>
To assign which device is related to this particular uplink, the <strong>WirelessDeviceId</strong> need to be used. <br />
There is a table in the database that contains the <strong>serial-number WirelessDeviceId</strong> relationship: <strong>iqwl_sidewalk_deviceid_connector</strong>  </p>
<p><strong>In the future, when all Amazon Sidewalk chips will be onboarded on our cloud, then we'll implement a more efficient and less manual way to assign the devices with the uplinks.</strong></p>
<h3 id="iqsl">IQSL</h3>
<p>This device is in the same time a <strong>Leak Sensor</strong> and a <strong>Transmitter</strong>:  </p>
<ol>
<li>
<p>Leak Sensor: detects leak using its probs (Similar to IQWL devices).  </p>
</li>
<li>
<p>Transmitter: it's possible to connect a headphone jack wth two functionalities:  </p>
</li>
<li>
<p>Extends Leak Sensor capacity. Another device can be connected to the IQSL that detects Water Leaks. So, using the Headphone Jack, the other device will let the IQSL know that there is an external Leak. <strong>Attribute externalLeakDetectionEnabled = TRUE to extend the Leak Detection to the headphone jack. Attribute externalLeakDetected = TRUE if the extensor detects leak.</strong>  </p>
</li>
<li>
<p>Connect a Toilet Sensor. The Toilet Sensor is a device that can be connected directly on a Toilet Pipe and it will give information about flushes and water usage. It can be connected using the Headphone Jack and will send toilet information to the transmitter. <strong>attribute externalLeakDetected = FALSE to make Toilet Sensor works.</strong>  </p>
</li>
</ol>
<p><strong>The platform need to show if the IQSL is connected to a Leak Sensor, or to a Toilet Sensor, or if there's no headphone jack connected</strong>  </p>
<p><strong>1- Heartbeat Packet (fPort = 0x01)</strong><br />
Attributes:<br />
<em> </em><em>Battery Voltage (V)</em><em><br />
</em> <strong>batteryPercentage (%)</strong><br />
<em> </em><em>Temperature (Celsius)</em><em><br />
</em> <strong>Humidity (%)</strong><br />
<em> </em><em>pinLeakDetectionEnabled: boolean (default: true)</em><em>
* </em><em>externalLeakDetectionEnabled: boolean</em><em> (TRUE to work the Leak Sensor extensor. FALSE to work the Toilet Sensor)<br />
</em> <strong>tamperDetectionEnabled: boolean</strong><br />
<em> </em><em>pinLeakDetected: boolean</em><em> (if it's occuring a leak right now)<br />
</em> <strong>externalLeakDetected: boolean</strong> (if Toilet Sensor connected, then always FALSE)<br />
<em> </em><em>powerDetected: boolean</em><em> (No idea what is this)<br />
</em> <strong>jackDetected: boolean</strong> (True, if connected to a Toilet Sensor)<br />
<em> </em><em>magnetDetected: boolean</em><em> (Tamper detection using a magnet)<br />
</em> <strong>Water Leak Detected: boolean</strong><br />
<em> </em><em>Tamper Detected: boolean</em><em><br />
</em> <strong>Button Pressed: boolean</strong><br />
<em> </em><em>Temperature (Celsius): decimal</em><em><br />
</em> <strong>Humidity (%): decimal</strong>  </p>
<p>Payload:</p>
<p>Bytes:
01B06408D614720BFFB405</p>
<p>Criptographic:
AbBkCNYUcgv/tAU=</p>
<p>Decoded:</p>
<pre><code class="language-json">        &quot;data&quot;: {
          &quot;batteryPercentage&quot;: 100,
          &quot;batteryVoltage&quot;: 3.52,
          &quot;enabledAlerts&quot;: {
            &quot;externalLeakDetectionEnabled&quot;: false,
            &quot;pinLeakDetectionEnabled&quot;: true,
            &quot;tamperDetectionEnabled&quot;: true
          },
          &quot;humidity&quot;: 52.34,
          &quot;lastRssi&quot;: -76,
          &quot;lastSnr&quot;: 11,
          &quot;state&quot;: {
            &quot;externalLeakDetected&quot;: false,
            &quot;jackDetected&quot;: false,
            &quot;magnetDetected&quot;: false,
            &quot;pinLeakDetected&quot;: false,
            &quot;powerDetected&quot;: false
          },
          &quot;stateAsUint8&quot;: 5,
          &quot;temperature&quot;: 22.62
        },
        &quot;payloadType&quot;: &quot;Heartbeat&quot;,
        &quot;payloadTypeId&quot;: 1
</code></pre>
<p><strong>2- Alert Packets (fPort = 0x02)</strong>
Triggered when a specific event occurs.<br />
The first byte (bytes[0]) defines the alert type:  </p>
<p><strong>Case 1: External Leak (via headphone jack)</strong> - not applied, because the Toilet Sensor will be connected to the headphone Jack, not a Leak Sensor Extensor.<br />
Attributes:<br />
<em> </em><em>triggerValue:</em><em> (No idea what is it)
* </em><em>currentValue: int</em><em> (how moisture is it. Can define the level to consider it a leak detected)
* </em><em>temperature</em><em> 
* </em><em>humidity</em><em> 
* </em><em>delayCount</em><em> (No idea what is it)
* </em><em>currentState: boolean</em>* (true = leak detected. false = leak cleared) </p>
<p>(IMPORTANT)
Case 2: Local Leak (via bottom contact pins) <strong>Only activate if the attribute pinLeakDetectionEnabled = true</strong>
Attributes:
triggerValue: (No idea what is it)
currentValue: int (how moisture is it. Can define the level to consider it a leak detected)
temperature 
humidity 
delayCount (No idea what is it)
currentState: boolean (true = leak detected. false = leak cleared) </p>
<p>Case 3: Tamper (magnet detected) - Activate when the magnet touch the device, simulating a tamper. <strong>Only activate if the attribute tamperDetectionEnabled = true</strong></p>
<p>Case 4: Push button pressed - Activated when button is pressed</p>
<p>Case 5: Temperature High. Defined by downlink th hreshold
Case 6: Temperature Low.
Case 7: Humidity High.
Case 8: Humidity Low.
  From 5 to 8: Each includes current value, trigger threshold, guardband (safety margin), delay, and state.</p>
<p>(IMPORTANT)
Case 9: Total Events (cumulative counter): <strong>Toilet Sensor Heartbeat</strong>
Attributes:
longEventTriggered: boolean (is it occuring a Long Flush right now? True = yes. False = No)
alertInterval (no Idea what is it)
deviceTypeId (no Idea what is it)
totalEvents: int (How many flushes occured since the last heartbeat)
totalLiters: decimal (How many litters were spent since the last heartbeat) -&gt; <strong>Convert to Gallons (litters ** 0.264172)</strong>
totalPulses: decimal (How many pulses were spent since the last heartbeat)</p>
<p>Payload:</p>
<p>Bytes:
0900001661000101000005</p>
<p>Criptographic:
CQAAFmEAAQEAAAU=</p>
<p>Decoded:</p>
<pre><code class="language-json">{
        &quot;alertType&quot;: &quot;Pulse Counting (Total Events)&quot;,
        &quot;data&quot;: {
          &quot;longEventTriggered&quot;: 0,
          &quot;settings&quot;: {
            &quot;alertInterval&quot;: 500,
            &quot;deviceTypeId&quot;: 1
          },
          &quot;totalEvents&quot;: 1,
          &quot;totalLiters&quot;: 5.319405756731662,
          &quot;totalPulses&quot;: 5729
        },
        &quot;payloadType&quot;: &quot;Alert&quot;,
        &quot;payloadTypeId&quot;: 9
      }
</code></pre>
<p>(IMPORTANT)
Case 10: Long Event Alert (long-duration events): <strong>Toilet Sensor Long Event detected</strong></p>
<p>Attriubtes:
currentState: boolean (True = started. False: Ended)
durationTrigger: int (How many time flushing is consider a Long Flush and it will trigger this payload - in milliseconds)</p>
<p>Note: this payload will only be triggered after the pulse_duration_trigger interval. So we don't know when the flush started, but we know when the flush is running for a long time. So in order to identify when the flush started, it has to subtract the pulse_duration_trigger value.</p>
<p>Payload:</p>
<h2 id="bytes">Bytes:</h2>
<h2 id="criptographic">Criptographic:</h2>
<p>Decoded:</p>
<pre><code class="language-json">{
        &quot;alertType&quot;: &quot;Pulse Counting (Long Event Alert)&quot;,
        &quot;data&quot;: {
          &quot;currentState&quot;: 1,
          &quot;settings&quot;: {
            &quot;durationTrigger&quot;: 180000
          },
        },
        &quot;payloadType&quot;: &quot;Alert&quot;,
        &quot;payloadTypeId&quot;: 10
      }
</code></pre>
<p>(IMPORTANT)
Case 11: Last Event Usage (usage of the last event): <strong>Toilet Sensor water usage when a flush (normal or long) ends</strong></p>
<p>Attriubtes:
totalLiters: decimal (how many litters was spent in the last flush)  -&gt; <strong>Convert to Gallons (litters x 0.264172)</strong>
totalPulses: decimal (how many pulses was spent in the last flush)
humidity (%)
temperature (Celsius)</p>
<p>Note: this payload will be triggered only after a flush (normal or long). 
- If this flush was a normal flush, we don't know how much time this flush was running. However, we know by this payload when it finished.
- If this flush was a long flush, we know when it started, because the Long Flush payload (type: 10) was triggered before this payload of Last Event Usage (type: 11).
- One challenge is to assign the Last Event Usage payload (type: 11) with the Long Flush payload (type: 10), because the payloads will be triggered in different moments. Also, the Last Event Usage payload doesn't indicate if the last event usage was long or a normal flush.
- If the last flush spent less then 1 gallon. So this is consider a <strong>Scape</strong>, not a normal flush </p>
<p>Payload:</p>
<p>Bytes:
0B00001CCC01088115FF</p>
<p>Criptographic:
CwAAHMwBCIEV/w==</p>
<p>Decoded:</p>
<pre><code class="language-json">{
  &quot;alertType&quot;: &quot;Pulse Counting Event (Last Event Usage)&quot;,
  &quot;data&quot;: {
    &quot;humidity&quot;: 56.31,
    &quot;settings&quot;: {
      &quot;deviceTypeId&quot;: 1
    },
    &quot;temperature&quot;: 21.77,
    &quot;totalLiters&quot;: 6.84493964716806,
    &quot;totalPulses&quot;: 7372
  },
  &quot;payloadType&quot;: &quot;Alert&quot;,
  &quot;payloadTypeId&quot;: 11
}
</code></pre>
<p>(IMPORTANT)
Case 12: Jack connected / disconnected
Attriubtes:
jackConnected: Boolean (true: yes. false: no)</p>
<p>Payload:</p>
<h2 id="bytes_1">Bytes:</h2>
<h2 id="criptographic_1">Criptographic:</h2>
<p><strong>3- System Packets (fPort = 0x03)</strong>
Maintenance/system packets.</p>
<p>Case 0x01: Network Test Packet → reports SNR and RSSI.</p>
<p>Case 0x02: Joined Uplink Packet → confirms joining the network and sends configs:</p>
<p>firmwareVersion, heartbeatInterval, sensorCheckInterval.</p>
<p>Which alerts are enabled (bitmasks in bytes[7] and bytes[8]).</p>
<p>Used for network testing and initial configuration after join.</p>
<p><strong>4- Parameter Values (fPort = 0x04)</strong></p>
<p>Here we have many subtypes (dozens). These are configuration/parameterization packets.
The first byte (bytes[0]) indicates which parameter. Examples:
Identifiers
* Case 0: devEui.
* Case 1: appEui.
* Case 2: appKey (disabled for security reasons).<br />
Network and operation configs
* Case 3–9: retry, confirm mode, join mode, ADR, device class, duty cycle, datarate.
* Case 10–15: RX1/RX2 delays, datarate, TX power.
* Case 16–19: region, channel mask, network mode, mode.<br />
Operation groups
* Case 21–26: heartbeat interval, join group, network test group, battery group, no-ack recovery, heartbeat group.
Event acknowledgements
* Case 27–37: Individual acks for external leak, pin leak, tamper, button, temp high/low, humidity high/low, pulse count, etc.<br />
Detailed sensor configs<br />
* Cases 38–46: Leak detection (pin/external) + buzzer + all-in-one parameters.
* Cases 47–59: Button, high/low temperature, high/low humidity, all with buzzer/guardband/delay.
* Case 60–61: temperature/humidity offsets.
* Case 62: sensing interval.
* Case 63–64: pulse counting configs.
* Case 65–69: Jack detection (enabled, buzzer, ack, etc.) and global buzzer control.</p>
<p>Summary of the Payload Packets:</p>
<ul>
<li>Heartbeat (0x01): general status (battery, SNR, sensors, flags).</li>
<li>Alerts (0x02): triggered events (leak, tamper, button, temperature, humidity, pulses, jack).</li>
<li>System (0x03): network/system packets (tests, join, firmware).</li>
<li>Parameters (0x04): massive set of configuration parameters (network, ADR, alerts, delays, buzzer, offsets, etc.).</li>
</ul>
<h3 id="iqsl-payload-formatter-ttn">IQSL Payload Formatter (TTN):</h3>
<pre><code class="language-js">function DoDecode(fPort, bytes) {
    var decoded = { data: {} };
    switch (fPort) {
        case 0x01: { // HeartBeat Packet

            decoded.data.state = {};
            decoded.data.enabledAlerts = {};
            decoded.payloadType = &quot;Heartbeat&quot;;
            decoded.payloadTypeId = bytes[0];
            decoded.data.batteryVoltage = (bytes[1] / 100) * 2;
            decoded.data.batteryPercentage = bytes[2];
            decoded.data.temperature = UInt16(bytes[3] &lt;&lt; 8 | bytes[4]) / 100;
            decoded.data.humidity = (bytes[5] &lt;&lt; 8 | bytes[6]) / 100;
            decoded.data.lastSnr = Int8(bytes[7]);
            decoded.data.lastRssi = Int16(bytes[8] &lt;&lt; 8 | bytes[9]);
            decoded.data.stateAsUint8 = bytes[10];
            decoded.data.enabledAlerts.pinLeakDetectionEnabled = ((bytes[10] &amp; 0b00000001) &gt; 0);
            decoded.data.enabledAlerts.externalLeakDetectionEnabled = ((bytes[10] &amp; 0b00000010) &gt; 0);
            decoded.data.enabledAlerts.tamperDetectionEnabled = ((bytes[10] &amp; 0b00000100) &gt; 0);
            decoded.data.state.pinLeakDetected = ((bytes[10] &amp; 0b00001000) &gt; 0);
            decoded.data.state.externalLeakDetected = ((bytes[10] &amp; 0b00010000) &gt; 0);
            decoded.data.state.powerDetected = ((bytes[10] &amp; 0b00100000) &gt; 0);
            decoded.data.state.jackDetected = ((bytes[10] &amp; 0b01000000) &gt; 0);
            decoded.data.state.magnetDetected = ((bytes[10] &amp; 0b10000000) &gt; 0);
        }
            break;
        case 0x02: { // Alert Packet

            decoded.payloadType = &quot;Alert&quot;;
            decoded.payloadTypeId = bytes[0];

            switch (bytes[0]) {
                case 1: {
                    decoded.data.settings = {};
                    decoded.alertType = &quot;External Leak Detection (Via Headphone Jack)&quot;;
                    decoded.data.settings.triggerValue = UInt16(bytes[1] &lt;&lt; 8 | bytes[2]);
                    decoded.data.currentValue = UInt16(bytes[3] &lt;&lt; 8 | bytes[4]);
                    decoded.data.temperature = Int16(bytes[5] &lt;&lt; 8 | bytes[6]) / 100;
                    decoded.data.humidity = UInt16(bytes[7] &lt;&lt; 8 | bytes[8]) / 100;
                    decoded.data.settings.delayCount = bytes[9];
                    decoded.data.currentState = bytes[10];
                } break;
                case 2: {
                    decoded.data.settings = {};
                    decoded.alertType = &quot;Local Leak Detection (Via Bottom Contact Pins)&quot;;
                    decoded.data.settings.triggerValue = UInt16(bytes[1] &lt;&lt; 8 | bytes[2]);
                    decoded.data.currentValue = UInt16(bytes[3] &lt;&lt; 8 | bytes[4]);
                    decoded.data.temperature = Int16(bytes[5] &lt;&lt; 8 | bytes[6]) / 100;
                    decoded.data.humidity = UInt16(bytes[7] &lt;&lt; 8 | bytes[8]) / 100;
                    decoded.data.settings.delayCount = bytes[9];
                    decoded.data.currentState = bytes[10];
                } break;
                case 3: {
                    decoded.alertType = &quot;Tamper Detection (Magnet Presence)&quot;;
                    decoded.data.currentValue = bytes[1];
                } break;
                case 4: {
                    decoded.alertType = &quot;Push Button Pressed&quot;;
                    decoded.data.duration = UInt16(bytes[1] &lt;&lt; 8 | bytes[2]);
                    decoded.data.turningOff = bytes[3];
                } break;
                case 5: {
                    decoded.data.settings = {};
                    decoded.alertType = &quot;Temperature Alert (High)&quot;;
                    decoded.data.temperature = Int16(bytes[1] &lt;&lt; 8 | bytes[2]) / 100;
                    decoded.data.settings.triggerValue = Int16(bytes[3] &lt;&lt; 8 | bytes[4]) / 100;
                    decoded.data.settings.guardbandValue = Int16(bytes[5] &lt;&lt; 8 | bytes[6]) / 100;
                    decoded.data.humidity = UInt16(bytes[7] &lt;&lt; 8 | bytes[8]) / 100;
                    decoded.data.settings.delayCount = bytes[9];
                    decoded.data.currentState = bytes[10];
                } break;
                case 6: {
                    decoded.data.settings = {};
                    decoded.alertType = &quot;Temperature Alert (Low)&quot;;
                    decoded.data.temperature = Int16(bytes[1] &lt;&lt; 8 | bytes[2]) / 100;
                    decoded.data.settings.triggerValue = Int16(bytes[3] &lt;&lt; 8 | bytes[4]) / 100;
                    decoded.data.settings.guardbandValue = Int16(bytes[5] &lt;&lt; 8 | bytes[6]) / 100;
                    decoded.data.humidity = UInt16(bytes[7] &lt;&lt; 8 | bytes[8]) / 100;
                    decoded.data.settings.delayCount = bytes[9];
                    decoded.data.currentState = bytes[10];
                } break;
                case 7: {
                    decoded.data.settings = {};
                    decoded.alertType = &quot;Humidity Alert (High)&quot;;
                    decoded.data.humidity = UInt16(bytes[1] &lt;&lt; 8 | bytes[2]) / 100;
                    decoded.data.settings.triggerValue = Int16(bytes[3] &lt;&lt; 8 | bytes[4]) / 100;
                    decoded.data.settings.guardbandValue = Int16(bytes[5] &lt;&lt; 8 | bytes[6]) / 100;
                    decoded.data.temperature = Int16(bytes[7] &lt;&lt; 8 | bytes[8]) / 100;
                    decoded.data.settings.delayCount = bytes[9];
                    decoded.data.currentState = bytes[10];
                } break;
                case 8: {
                    decoded.data.settings = {};
                    decoded.alertType = &quot;Humidity Alert (Low)&quot;;
                    decoded.data.humidity = UInt16(bytes[1] &lt;&lt; 8 | bytes[2]) / 100;
                    decoded.data.settings.triggerValue = Int16(bytes[3] &lt;&lt; 8 | bytes[4]) / 100;
                    decoded.data.settings.guardbandValue = Int16(bytes[5] &lt;&lt; 8 | bytes[6]) / 100;
                    decoded.data.temperature = Int16(bytes[7] &lt;&lt; 8 | bytes[8]) / 100;
                    decoded.data.settings.delayCount = bytes[9];
                    decoded.data.currentState = bytes[10];
                } break;
                case 9: {
                    decoded.data.settings = {};
                    decoded.alertType = &quot;Pulse Counting (Total Events)&quot;;

                    decoded.data.totalPulses = (bytes[1] &lt;&lt; 24) + (bytes[2] &lt;&lt; 16) + (bytes[3] &lt;&lt; 8) + bytes[4];
                    decoded.data.totalEvents = UInt16(bytes[5] &lt;&lt; 8 | bytes[6]);
                    decoded.data.settings.deviceTypeId = bytes[7];
                    decoded.data.longEventTriggered = bytes[8];
                    decoded.data.settings.alertInterval = UInt16(bytes[9] &lt;&lt; 8 | bytes[10]) * 100;

                    switch (decoded.data.settings.deviceTypeId) {
                        // Generic Device Type, no usage calculations
                        case 0x00: {

                        } break;
                        // Toilet Flow Sensor
                        case 0x01: {
                            // F=18*Q-3 = 1077 pulses, Q(L/s) = f/1077, Q(L/min) = f*60/1077 = f/18*Q-3, Q(L/hour) = f*60*60/1077 = f*60/18*Q-3  
                            decoded.data.totalLiters = decoded.data.totalPulses / 1077;
                        } break;
                    }

                } break;
                case 10: {
                    decoded.data.settings = {};
                    decoded.alertType = &quot;Pulse Counting (Long Event Alert)&quot;;
                    decoded.data.currentState = bytes[1];
                    decoded.data.settings.durationTrigger = UInt16(bytes[2] &lt;&lt; 8 | bytes[3]) * 100;
                } break;
                case 11: {
                    decoded.data.settings = {};
                    decoded.alertType = &quot;Pulse Counting Event (Last Event Usage)&quot;;
                    decoded.data.totalPulses = (bytes[1] &lt;&lt; 24) + (bytes[2] &lt;&lt; 16) + (bytes[3] &lt;&lt; 8) + bytes[4];
                    decoded.data.settings.deviceTypeId = bytes[5];
                    decoded.data.temperature = Int16(bytes[6] &lt;&lt; 8 | bytes[7]) / 100;
                    decoded.data.humidity = UInt16(bytes[8] &lt;&lt; 8 | bytes[9]) / 100;
                    switch (decoded.data.settings.deviceTypeId) {
                        // Generic Device Type, no usage calculations
                        case 0x00:
                        case 0x01: {
                            decoded.data.totalLiters = decoded.data.totalPulses / 1077;
                        } break;
                    }

                } break;
                case 12: {
                    decoded.alertType = &quot;Headphone Jack Alert&quot;;
                    decoded.data.currentValue = bytes[1];
                } break;
            }
        } break;
        case 0x03: { // System Packets

            decoded.payloadType = &quot;System&quot;;
            decoded.payloadTypeId = bytes[0];
            switch (bytes[0]) {
                // &quot;Network Test Packet&quot;
                case 0x01: {
                    decoded.systemType = &quot;Network Test Packet&quot;;
                    decoded.data.snr = Int8(bytes[1]);
                    decoded.data.rssi = Int16(bytes[2] &lt;&lt; 8 | bytes[3]);
                } break;
                // &quot;Joined Uplink Packet&quot;
                case 0x02: {
                    decoded.data.settings = {};
                    decoded.data.settings.enabledAlerts = {};
                    decoded.systemType = &quot;Joined Uplink Packet&quot;;
                    decoded.data.firmwareVersion = UInt16(bytes[1] &lt;&lt; 8 | bytes[2]);
                    decoded.data.settings.heartbeatInterval = UInt16(bytes[3] &lt;&lt; 8 | bytes[4]);
                    decoded.data.settings.sensorCheckInterval = UInt16(bytes[5] &lt;&lt; 8 | bytes[6]);
                    decoded.data.settings.enabledAlerts.pinLeakDetection = ((bytes[7] &amp; 0b00000001) &gt; 0);
                    decoded.data.settings.enabledAlerts.externalLeakDetection = ((bytes[7] &amp; 0b00000010) &gt; 0);
                    decoded.data.settings.enabledAlerts.tamperDetection = ((bytes[7] &amp; 0b00000100) &gt; 0);
                    decoded.data.settings.enabledAlerts.pushButton = ((bytes[7] &amp; 0b00001000) &gt; 0);
                    decoded.data.settings.enabledAlerts.temperatureHigh = ((bytes[7] &amp; 0b00010000) &gt; 0);
                    decoded.data.settings.enabledAlerts.temperatureLow = ((bytes[7] &amp; 0b00100000) &gt; 0);
                    decoded.data.settings.enabledAlerts.humidityHigh = ((bytes[7] &amp; 0b01000000) &gt; 0);
                    decoded.data.settings.enabledAlerts.humidityLow = ((bytes[7] &amp; 0b10000000) &gt; 0);
                    decoded.data.settings.enabledAlerts.pulseCountingAlert = ((bytes[8] &amp; 0b00000001) &gt; 0);
                    decoded.data.settings.enabledAlerts.pulseCountingEventLongAlert = ((bytes[8] &amp; 0b00000010) &gt; 0);

                } break;
            }

        }
            break;
        case 0x04: { // Parameter Values

            decoded.payloadType = &quot;Parameter Values&quot;;
            decoded.payloadTypeId = bytes[0];

            switch (bytes[0]) {
                // devEui Parameter
                case 0: {
                    let devEuiTemp = &quot;&quot;;
                    devEuiTemp += bytes[1].toString(16).padStart(2, '0').toUpperCase();
                    devEuiTemp += bytes[2].toString(16).padStart(2, '0').toUpperCase();
                    devEuiTemp += bytes[3].toString(16).padStart(2, '0').toUpperCase();
                    devEuiTemp += bytes[4].toString(16).padStart(2, '0').toUpperCase();
                    devEuiTemp += bytes[5].toString(16).padStart(2, '0').toUpperCase();
                    devEuiTemp += bytes[6].toString(16).padStart(2, '0').toUpperCase();
                    devEuiTemp += bytes[7].toString(16).padStart(2, '0').toUpperCase();
                    devEuiTemp += bytes[8].toString(16).padStart(2, '0').toUpperCase();

                    decoded.parameterType = &quot;devEui&quot;;
                    decoded.data.devEui = devEuiTemp;
                } break;
                // appEui Parameter
                case 1: {
                    let appEuiTemp = &quot;&quot;;
                    appEuiTemp += bytes[1].toString(16).padStart(2, '0').toUpperCase();
                    appEuiTemp += bytes[2].toString(16).padStart(2, '0').toUpperCase();
                    appEuiTemp += bytes[3].toString(16).padStart(2, '0').toUpperCase();
                    appEuiTemp += bytes[4].toString(16).padStart(2, '0').toUpperCase();
                    appEuiTemp += bytes[5].toString(16).padStart(2, '0').toUpperCase();
                    appEuiTemp += bytes[6].toString(16).padStart(2, '0').toUpperCase();
                    appEuiTemp += bytes[7].toString(16).padStart(2, '0').toUpperCase();
                    appEuiTemp += bytes[8].toString(16).padStart(2, '0').toUpperCase();

                    decoded.parameterType = &quot;appEui&quot;;
                    decoded.data.appEui = appEuiTemp;
                } break;
                // appKey Parameter
                case 2: {
                    decoded.parameterType = &quot;appKey&quot;;   // This is not enabled for security reasons
                } break;
                // Retry Parameter
                case 3: {
                    decoded.parameterType = &quot;retry&quot;;
                    decoded.data.retry = bytes[1];
                } break;
                // Confirm Mode Parameter
                case 4: {
                    decoded.parameterType = &quot;Confirm Mode&quot;;
                    decoded.data.confirmMode = bytes[1];
                } break;
                // Join Mode Parameter
                case 5: {
                    decoded.parameterType = &quot;Join Mode&quot;;
                    decoded.data.joinMode = bytes[1];
                } break;
                // ADR Parameter
                case 6: {
                    decoded.parameterType = &quot;ADR&quot;;
                    decoded.data.adr = bytes[1];
                } break;
                // Device Class Parameter
                case 7: {
                    decoded.parameterType = &quot;Device Class&quot;;
                    decoded.data.deviceClass = bytes[1];
                } break;
                // Duty Cycle Parameter
                case 8: {
                    decoded.parameterType = &quot;Duty Cycle&quot;;
                    decoded.data.dutyCycle = bytes[1];
                } break;
                // Datarate Parameter
                case 9: {
                    decoded.parameterType = &quot;Datarate&quot;;
                    decoded.data.datarate = bytes[1];
                } break;
                // Join Delay RX1 Parameter
                case 10: {
                    decoded.parameterType = &quot;Join Delay RX1&quot;;
                    decoded.data.joinDelayRx1 = UInt16(bytes[1] &lt;&lt; 8 | bytes[2]);
                } break;
                // Join Delay RX2 Parameter
                case 11: {
                    decoded.parameterType = &quot;Join Delay RX2&quot;;
                    decoded.data.joinDelayRx2 = UInt16(bytes[1] &lt;&lt; 8 | bytes[2]);
                } break;
                // Public Network Mode Parameter
                case 12: {
                    decoded.parameterType = &quot;Public Network Mode&quot;;
                    decoded.publicNetworkMode = bytes[1];
                } break;
                // RX1 Delay Parameter
                case 13: {
                    decoded.parameterType = &quot;RX1 Delay&quot;;
                    decoded.data.rx1Delay = UInt16(bytes[1] &lt;&lt; 8 | bytes[2]);
                } break;
                // RX2 Delay Parameter
                case 14: {
                    decoded.parameterType = &quot;RX2 Delay&quot;;
                    decoded.data.rx2Delay = UInt16(bytes[1] &lt;&lt; 8 | bytes[2]);
                } break;
                // RX2 Datarate Parameter
                case 15: {
                    decoded.parameterType = &quot;RX2 Datarate&quot;;
                    decoded.data.rx2Datarate = bytes[1];
                } break;
                // TX Power Parameter
                case 16: {
                    decoded.parameterType = &quot;TX Power&quot;;
                    decoded.data.txPower = bytes[1];
                } break;
                // Region Parameter
                case 17: {
                    decoded.parameterType = &quot;Region&quot;;
                    decoded.data.region = bytes[1];
                } break;
                // Channel Mask Parameter
                case 18: {
                    let channelMaskTemp = &quot;&quot;;
                    channelMaskTemp += bytes[1].toString(16).padStart(2, '0').toUpperCase();
                    channelMaskTemp += bytes[2].toString(16).padStart(2, '0').toUpperCase();

                    decoded.parameterType = &quot;Channel Mask&quot;;
                    decoded.data.channelMask = channelMaskTemp;
                } break;
                // Network Mode Parameter
                case 19: {
                    decoded.parameterType = &quot;Network Mode&quot;;
                    decoded.data.networkMode = bytes[1];
                } break;
                // Mode Parameter
                case 20: {
                    decoded.parameterType = &quot;Mode&quot;;
                    decoded.data.mode = bytes[1];
                } break;
                // Heartbeat Interval Parameter
                case 21: {
                    decoded.parameterType = &quot;Heartbeat Interval&quot;;
                    decoded.data.heartbeatInterval = UInt16(bytes[1] &lt;&lt; 8 | bytes[2]);
                } break;
                // Join Group Parameter
                case 22: {
                    decoded.parameterType = &quot;Join Group&quot;;
                    decoded.data.delayBetweenIterations = UInt16(bytes[1] &lt;&lt; 8 | bytes[2]);
                    decoded.data.delayBetweenSequence = UInt16(bytes[3] &lt;&lt; 8 | bytes[4]);
                    decoded.data.failCountToTriggerLongDelay = bytes[5];
                    decoded.data.longDelayBetweenSequence = UInt16(bytes[6] &lt;&lt; 8 | bytes[7]);


                } break;
                // Network Test Group Parameter
                case 23: {
                    decoded.parameterType = &quot;Network Test Group&quot;;
                    decoded.data.interval = UInt16(bytes[1] &lt;&lt; 8 | bytes[2]);
                    decoded.data.adr = bytes[3];
                    decoded.data.datarate = bytes[4];
                    decoded.data.txPower = bytes[5];
                } break;
                // Battery Group Parameter
                case 24: {
                    decoded.parameterType = &quot;Battery Group&quot;;
                    decoded.data.batteryMin = (bytes[1] * 2) / 100;
                    decoded.data.batteryMax = (bytes[2] * 2) / 100;
                    decoded.data.batteryType = bytes[3];
                } break;
                // No ACK Recovery Group Parameter
                case 25: {
                    decoded.parameterType = &quot;No ACK Recovery Group&quot;;
                    decoded.data.noAckRecoveryMode = bytes[1];
                    decoded.data.adrDisabled = bytes[2];
                    decoded.data.delay = UInt16(bytes[3] &lt;&lt; 8 | bytes[4]);
                    decoded.data.retryCount = bytes[5];
                    decoded.data.Retrydelay = UInt16(bytes[6] &lt;&lt; 8 | bytes[7]);
                } break;
                // Heartbeat Group Parameter
                case 26: {
                    decoded.parameterType = &quot;Heartbeat Group&quot;;
                    decoded.data.heartbeatId = bytes[1];
                    decoded.data.ack = bytes[2];
                    decoded.data.ackRetryCount = bytes[3];
                } break;
                // External Leak ACK Parameter
                case 27: {
                    decoded.parameterType = &quot;External Leak ACK&quot;;
                    decoded.data.ack = bytes[1];
                    decoded.data.ackRetryCount = bytes[2];
                } break;
                // Pin Leak ACK Parameter
                case 28: {
                    decoded.parameterType = &quot;Pin Leak ACK&quot;;
                    decoded.data.ack = bytes[1];
                    decoded.data.ackRetryCount = bytes[2];
                } break;
                // Tamper Detection ACK Parameter
                case 29: {
                    decoded.parameterType = &quot;Tamper Detection ACK&quot;;
                    decoded.data.ack = bytes[1];
                    decoded.data.ackRetryCount = bytes[2];
                } break;
                // Button Press ACK Parameter
                case 30: {
                    decoded.parameterType = &quot;Button Press ACK&quot;;
                    decoded.data.ack = bytes[1];
                    decoded.data.ackRetryCount = bytes[2];
                } break;
                // Temperature High ACK Parameter
                case 31: {
                    decoded.parameterType = &quot;Temperature High ACK&quot;;
                    decoded.data.ack = bytes[1];
                    decoded.data.ackRetryCount = bytes[2];
                } break;
                // Temperature Low ACK Parameter
                case 32: {
                    decoded.parameterType = &quot;Temperature Low ACK&quot;;
                    decoded.data.ack = bytes[1];
                    decoded.data.ackRetryCount = bytes[2];
                } break;
                // Humidity High ACK Parameter
                case 33: {
                    decoded.parameterType = &quot;Humidity High ACK&quot;;
                    decoded.data.ack = bytes[1];
                    decoded.data.ackRetryCount = bytes[2];
                } break;
                // Humidity Low ACK Parameter
                case 34: {
                    decoded.parameterType = &quot;Humidity Low ACK&quot;;
                    decoded.data.ack = bytes[1];
                    decoded.data.ackRetryCount = bytes[2];
                } break;
                // Pulse Count ACK Parameter
                case 35: {
                    decoded.parameterType = &quot;Pulse Count ACK&quot;;
                    decoded.data.ack = bytes[1];
                    decoded.data.ackRetryCount = bytes[2];
                } break;
                // Pulse Count Long Event ACK Parameter
                case 36: {
                    decoded.parameterType = &quot;Pulse Count Long Event ACK&quot;;
                    decoded.data.ack = bytes[1];
                    decoded.data.ackRetryCount = bytes[2];
                } break;
                // Parameter Uplink ACK Parameter
                case 37: {
                    decoded.parameterType = &quot;Parameter Uplink ACK&quot;;
                    decoded.data.ack = bytes[1];
                    decoded.data.ackRetryCount = bytes[2];
                } break;
                // Pin Leak Detection Parameter
                case 38: {
                    decoded.parameterType = &quot;Pin Leak Detection&quot;;
                    decoded.data.enabled = bytes[1];
                    decoded.data.triggerValue = UInt16(bytes[2] &lt;&lt; 8 | bytes[3]);
                    decoded.data.triggerDelay = bytes[4];
                } break;
                // Pin Leak Detection Buzzer Parameter
                case 39: {
                    decoded.parameterType = &quot;Pin Leak Detection Buzzer&quot;;
                    decoded.data.enabled = bytes[1];
                    decoded.data.silenceEnabled = bytes[2];
                    decoded.data.silenceCounter = UInt16(bytes[3] &lt;&lt; 8 | bytes[4]);
                    decoded.data.beepCount = bytes[5];
                    decoded.data.beepDuration = UInt16(bytes[6] &lt;&lt; 8 | bytes[7]);

                } break;
                // Pin Leak Detection All Parameter
                case 40: {
                    decoded.parameterType = &quot;Pin Leak Detection All&quot;;
                    decoded.data.pinLeakDetectionEnabled = ((bytes[1] &amp; 0b00000001) &gt; 0);
                    decoded.data.buzzerEnabled = ((bytes[1] &amp; 0b00000010) &gt; 0);
                    decoded.data.silenceEnabled = ((bytes[1] &amp; 0b00000100) &gt; 0);
                    decoded.data.triggerValue = UInt16(bytes[2] &lt;&lt; 8 | bytes[3]);
                    decoded.data.triggerDelay = bytes[4];
                    decoded.data.silenceCounter = UInt16(bytes[5] &lt;&lt; 8 | bytes[6]);
                    decoded.data.beepCount = bytes[7];
                    decoded.data.beepDuration = UInt16(bytes[8] &lt;&lt; 8 | bytes[9]);

                } break;
                // External Leak Detection Parameter
                case 41: {
                    decoded.parameterType = &quot;External Leak Detection&quot;;
                    decoded.data.enabled = bytes[1];
                    decoded.data.triggerValue = UInt16(bytes[2] &lt;&lt; 8 | bytes[3]);
                    decoded.data.triggerDelay = bytes[4];
                } break;
                // External Leak Detection Buzzer Parameter
                case 42: {
                    decoded.parameterType = &quot;External Leak Detection Buzzer&quot;;
                    decoded.data.enabled = bytes[1];
                    decoded.data.silenceEnabled = bytes[2];
                    decoded.data.silenceCounter = UInt16(bytes[3] &lt;&lt; 8 | bytes[4]);
                    decoded.data.beepCount = bytes[5];
                    decoded.data.beepDuration = UInt16(bytes[6] &lt;&lt; 8 | bytes[7]);
                } break;
                // External Leak Detection All Parameter
                case 43: {
                    decoded.parameterType = &quot;External Leak Detection All&quot;;
                    decoded.data.pinLeakDetectionEnabled = ((bytes[1] &amp; 0b00000001) &gt; 0);
                    decoded.data.buzzerEnabled = ((bytes[1] &amp; 0b00000010) &gt; 0);
                    decoded.data.silenceEnabled = ((bytes[1] &amp; 0b00000100) &gt; 0);
                    decoded.data.triggerValue = UInt16(bytes[2] &lt;&lt; 8 | bytes[3]);
                    decoded.data.triggerDelay = bytes[4];
                    decoded.data.silenceCounter = UInt16(bytes[5] &lt;&lt; 8 | bytes[6]);
                    decoded.data.beepCount = bytes[7];
                    decoded.data.beepDuration = UInt16(bytes[8] &lt;&lt; 8 | bytes[9]);
                } break;
                // Tamper Detection Parameter
                case 44: {
                    decoded.parameterType = &quot;Tamper Detection&quot;;
                    decoded.data.enabled = bytes[1];
                } break;
                // Tamper Detection Buzzer Parameter
                case 45: {
                    decoded.parameterType = &quot;Tamper Detection Buzzer&quot;;
                    decoded.data.enabled = bytes[1];
                    decoded.data.silenceEnabled = bytes[2];
                    decoded.data.silenceCounter = UInt16(bytes[3] &lt;&lt; 8 | bytes[4]);
                    decoded.data.beepCount = bytes[5];
                    decoded.data.beepDuration = UInt16(bytes[6] &lt;&lt; 8 | bytes[7]);
                } break;
                // Tamper Detection All Parameter
                case 46: {
                    decoded.parameterType = &quot;Tamper Detection All&quot;;
                    decoded.data.enabled = bytes[1];
                    decoded.data.buzzerEnabled = bytes[2];
                    decoded.data.silenceEnabled = bytes[3];
                    decoded.data.silenceCounter = UInt16(bytes[4] &lt;&lt; 8 | bytes[5]);
                    decoded.data.beepCount = bytes[6];
                    decoded.data.beepDuration = UInt16(bytes[7] &lt;&lt; 8 | bytes[8]);
                } break;
                // Button Pressed Parameter
                case 47: {
                    decoded.parameterType = &quot;Button Pressed&quot;;
                    decoded.data.enabled = bytes[1];
                } break;
                // Temperature High Parameter
                case 48: {
                    decoded.parameterType = &quot;Temperature High&quot;;
                    decoded.data.enabled = bytes[1];
                    decoded.data.triggerValue = (Int16(bytes[2] &lt;&lt; 8 | bytes[3])) / 100;
                    decoded.data.guardbandValue = (Int16(bytes[4] &lt;&lt; 8 | bytes[5])) / 100;
                    decoded.data.delayCount = bytes[6];
                } break;
                // Temperature High Buzzer Parameter
                case 49: {
                    decoded.parameterType = &quot;Temperature High Buzzer&quot;;
                    decoded.data.enabled = bytes[1];
                    decoded.data.silenceEnabled = bytes[2];
                    decoded.data.silenceCounter = UInt16(bytes[3] &lt;&lt; 8 | bytes[4]);
                    decoded.data.beepCount = bytes[5];
                    decoded.data.beepDuration = UInt16(bytes[6] &lt;&lt; 8 | bytes[7]);
                } break;
                // Temperature High All Parameter
                case 50: {
                    decoded.parameterType = &quot;Temperature High All&quot;;
                    decoded.data.enabled = ((bytes[1] &amp; 0b00000001) &gt; 0);
                    decoded.data.buzzerEnabled = ((bytes[1] &amp; 0b00000010) &gt; 0);
                    decoded.data.silenceEnabled = ((bytes[1] &amp; 0b00000100) &gt; 0);
                    decoded.data.triggerValue = (Int16(bytes[2] &lt;&lt; 8 | bytes[3])) / 100;
                    decoded.data.guardbandValue = (Int16(bytes[4] &lt;&lt; 8 | bytes[5])) / 100;
                    decoded.data.delayCount = bytes[6];
                    decoded.data.silenceCounter = bytes[7];
                    decoded.data.beepCount = bytes[8];
                    decoded.data.beepDuration = UInt16(bytes[9] &lt;&lt; 8 | bytes[10]);

                } break;
                // Temperature Low Parameter
                case 51: {
                    decoded.parameterType = &quot;Temperature Low&quot;;
                    decoded.data.enabled = bytes[1];
                    decoded.data.triggerValue = (Int16(bytes[2] &lt;&lt; 8 | bytes[3])) / 100;
                    decoded.data.guardbandValue = (Int16(bytes[4] &lt;&lt; 8 | bytes[5])) / 100;
                    decoded.data.delayCount = bytes[6];
                } break;
                // Temperature Low Buzzer Parameter
                case 52: {
                    decoded.parameterType = &quot;Temperature Low Buzzer&quot;;
                    decoded.data.enabled = bytes[1];
                    decoded.data.silenceEnabled = bytes[2];
                    decoded.data.silenceCounter = UInt16(bytes[3] &lt;&lt; 8 | bytes[4]);
                    decoded.data.beepCount = bytes[5];
                    decoded.data.beepDuration = UInt16(bytes[6] &lt;&lt; 8 | bytes[7]);
                } break;
                // Temperature Low All Parameter
                case 53: {
                    decoded.parameterType = &quot;Temperature Low All&quot;;
                    decoded.data.enabled = ((bytes[1] &amp; 0b00000001) &gt; 0);
                    decoded.data.buzzerEnabled = ((bytes[1] &amp; 0b00000010) &gt; 0);
                    decoded.data.silenceEnabled = ((bytes[1] &amp; 0b00000100) &gt; 0);
                    decoded.data.triggerValue = (Int16(bytes[2] &lt;&lt; 8 | bytes[3])) / 100;
                    decoded.data.guardbandValue = (Int16(bytes[4] &lt;&lt; 8 | bytes[5])) / 100;
                    decoded.data.delayCount = bytes[6];
                    decoded.data.silenceCounter = bytes[7];
                    decoded.data.beepCount = bytes[8];
                    decoded.data.beepDuration = UInt16(bytes[9] &lt;&lt; 8 | bytes[10]);
                } break;
                // Humidity High Parameter
                case 54: {
                    decoded.parameterType = &quot;Humidity High&quot;;
                    decoded.data.enabled = bytes[1];
                    decoded.data.triggerValue = (Int16(bytes[2] &lt;&lt; 8 | bytes[3])) / 100;
                    decoded.data.guardbandValue = (Int16(bytes[4] &lt;&lt; 8 | bytes[5])) / 100;
                    decoded.data.delayCount = bytes[6];
                } break;
                // Humidity High Buzzer Parameter
                case 55: {
                    decoded.parameterType = &quot;Humidity High Buzzer&quot;;
                    decoded.data.enabled = bytes[1];
                    decoded.data.silenceEnabled = bytes[2];
                    decoded.data.silenceCounter = UInt16(bytes[3] &lt;&lt; 8 | bytes[4]);
                    decoded.data.beepCount = bytes[5];
                    decoded.data.beepDuration = UInt16(bytes[6] &lt;&lt; 8 | bytes[7]);
                } break;
                // Humidity High All Parameter
                case 56: {
                    decoded.parameterType = &quot;Humidity High All&quot;;
                    decoded.data.enabled = ((bytes[1] &amp; 0b00000001) &gt; 0);
                    decoded.data.buzzerEnabled = ((bytes[1] &amp; 0b00000010) &gt; 0);
                    decoded.data.silenceEnabled = ((bytes[1] &amp; 0b00000100) &gt; 0);
                    decoded.data.triggerValue = (Int16(bytes[2] &lt;&lt; 8 | bytes[3])) / 100;
                    decoded.data.guardbandValue = (Int16(bytes[4] &lt;&lt; 8 | bytes[5])) / 100;
                    decoded.data.delayCount = bytes[6];
                    decoded.data.silenceCounter = bytes[7];
                    decoded.data.beepCount = bytes[8];
                    decoded.data.beepDuration = UInt16(bytes[9] &lt;&lt; 8 | bytes[10]);
                } break;
                // Humidity Low Parameter
                case 57: {
                    decoded.parameterType = &quot;Humidity Low&quot;;
                    decoded.data.enabled = bytes[1];
                    decoded.data.triggerValue = (Int16(bytes[2] &lt;&lt; 8 | bytes[3])) / 100;
                    decoded.data.guardbandValue = (Int16(bytes[4] &lt;&lt; 8 | bytes[5])) / 100;
                    decoded.data.delayCount = bytes[6];
                } break;
                // Humidity Low Buzzer Parameter
                case 58: {
                    decoded.parameterType = &quot;Humidity Low Buzzer&quot;;
                    decoded.data.enabled = bytes[1];
                    decoded.data.silenceEnabled = bytes[2];
                    decoded.data.silenceCounter = UInt16(bytes[3] &lt;&lt; 8 | bytes[4]);
                    decoded.data.beepCount = bytes[5];
                    decoded.data.beepDuration = UInt16(bytes[6] &lt;&lt; 8 | bytes[7]);
                } break;
                // Humidity Low All Parameter
                case 59: {
                    decoded.parameterType = &quot;Humidity Low All&quot;;
                    decoded.data.enabled = ((bytes[1] &amp; 0b00000001) &gt; 0);
                    decoded.data.buzzerEnabled = ((bytes[1] &amp; 0b00000010) &gt; 0);
                    decoded.data.silenceEnabled = ((bytes[1] &amp; 0b00000100) &gt; 0);
                    decoded.data.triggerValue = (Int16(bytes[2] &lt;&lt; 8 | bytes[3])) / 100;
                    decoded.data.guardbandValue = (Int16(bytes[4] &lt;&lt; 8 | bytes[5])) / 100;
                    decoded.data.delayCount = bytes[6];
                    decoded.data.silenceCounter = bytes[7];
                    decoded.data.beepCount = bytes[8];
                    decoded.data.beepDuration = UInt16(bytes[9] &lt;&lt; 8 | bytes[10]);
                } break;
                // Temperature Offset Parameter
                case 60: {
                    decoded.parameterType = &quot;Temperature Offset&quot;;
                    decoded.data.offset = (Int16(bytes[1] &lt;&lt; 8 | bytes[2])) / 100;
                } break;
                // Humidity Offset Parameter
                case 61: {
                    decoded.parameterType = &quot;Humidity Offset&quot;;
                    decoded.data.offset = (Int16(bytes[1] &lt;&lt; 8 | bytes[2])) / 100;
                } break;
                // Sense Interval Parameter
                case 62: {
                    decoded.parameterType = &quot;Sense Interval&quot;;
                    decoded.data.interval = UInt16(bytes[1] &lt;&lt; 8 | bytes[2]);
                } break;
                // Pulse Counting Parameter
                case 63: {
                    decoded.parameterType = &quot;Pulse Counting&quot;;
                    decoded.data.enabled = bytes[1];
                    decoded.data.deviceTypeId = bytes[2];
                    decoded.data.reportingInterval = UInt16(bytes[3] &lt;&lt; 8 | bytes[4]);
                    decoded.data.eventDelayValue = UInt16(bytes[5] &lt;&lt; 8 | bytes[6]);

                } break;
                // Pulse Counting Long Event Parameter
                case 64: {
                    decoded.parameterType = &quot;Pulse Counting Long Event&quot;;
                    decoded.data.enabled = bytes[1];
                    decoded.data.eventLongDelayValue = UInt16(bytes[2] &lt;&lt; 8 | bytes[3]);
                } break;
                case 65: {
                    decoded.parameterType = &quot;Jack Detected Event ACK&quot;;
                    decoded.data.ack = bytes[1];
                    decoded.data.ackRetryCount = bytes[2];
                } break;
                case 66: {
                    decoded.parameterType = &quot;Jack Detected Event&quot;;
                    decoded.data.enabled = bytes[1];
                    decoded.data.delayCount = bytes[2];
                } break;
                case 67: {
                    decoded.parameterType = &quot;Jack Detected Buzzer&quot;;
                    decoded.data.enabled = bytes[1];
                    decoded.data.silenceEnabled = bytes[2];
                    decoded.data.silenceCounter = UInt16(bytes[3] &lt;&lt; 8 | bytes[4]);
                    decoded.data.beepCount = bytes[5];
                    decoded.data.beepDuration = UInt16(bytes[6] &lt;&lt; 8 | bytes[7]);
                } break;
                case 68: {
                    decoded.parameterType = &quot;Jack Detected All&quot;;
                    decoded.data.enabled = bytes[1];
                    decoded.data.delayCount = bytes[2];
                    decoded.data.buzzerEnabled = bytes[3];
                    decoded.data.silenceEnabled = bytes[4];
                    decoded.data.silenceCounter = UInt16(bytes[5] &lt;&lt; 8 | bytes[6]);
                    decoded.data.beepCount = bytes[7];
                    decoded.data.beepDuration = UInt16(bytes[8] &lt;&lt; 8 | bytes[9]);
                } break;
                case 69: {
                    decoded.parameterType = &quot;Buzzer Disabled&quot;;
                    decoded.data.disabled = bytes[1];
                } break;
            }


        } break;
        default:
            decoded.unknown = &quot;Unknown data format&quot;;
            break;
    }
    return decoded;
}

// For TTN
function Decoder(bytes, fPort) {
    return DoDecode(fPort, bytes);
}

// For Chirpstack
function Decode(fPort, bytes, variables) {
    return DoDecode(fPort, bytes);
}

// Chirpstack v3 to v4 compatibility wrapper
function decodeUplink(input) {
    return {
        data: Decode(input.fPort, input.bytes, input.variables)
    };
}

var UInt4 = function (value) {
    return (value &amp; 0xF);
};

var Int4 = function (value) {
    var ref = UInt4(value);
    return (ref &gt; 0x7) ? ref - 0x10 : ref;
};

var UInt8 = function (value) {
    return (value &amp; 0xFF);
};

var Int8 = function (value) {
    var ref = UInt8(value);
    return (ref &gt; 0x7F) ? ref - 0x100 : ref;
};

var UInt16 = function (value) {
    return (value &amp; 0xFFFF);
};

var Int16 = function (value) {
    var ref = UInt16(value);
    return (ref &gt; 0x7FFF) ? ref - 0x10000 : ref;
};
</code></pre>
<h2 id="iqsv">IQSV</h2>
<p>IQSV devices are installed directly in the pipe and measure the water flow, temperature, pressure and contain a valve that can open and close the flow.</p>
<p><strong>There are 2 types of IQSV</strong></p>
<ul>
<li>IQSV V1 and V2 (older ones - until Sep/2025):</li>
</ul>
<p><strong>Attributes:</strong>
BatteryAlarm: bool<br />
BurstAlarm: bool (when pipe is damaged)<br />
CumulativeConsumption: decimal (water flow since the moment the device is turned ON) -&gt; * 264.172052 = value in gallons
EEPROMERROR: bool (no idea what is it)<br />
EmptyPipeAlarm: bool (when no flow)<br />
InstantConsumption: decimal (water flow in this moment PER HOUR) -&gt; * 264.172052 = value in gallons
LeakageAlarm: bool (when there is a leak in the device/pipe)
LowBatteryAlarm: bool (when the battery is low)
OverRangeAlarm: bool (no idea what is it)
OverTemperatureAlarm: bool (temperature defined in the firmware)
PreviousDayConsumption: decimal (water flow yesterday)  -&gt; * 264.172052 = value in gallons
ReverseCumulativeConsumption: decimal (if there is a flow in reverse) -&gt;  * 264.172052 = value in gallons
ReverseFlowAlarm: bool (when reverse flow)
ValveStatus: open/close
WaterPressure: decimal (in MPA) -&gt; * 145.038 to convert to PSI
WaterTemperature: decimal (in Celsius) -&gt; Need to convert to °F</p>
<p>Payload:</p>
<p>Bytes:
FEFE68201335465201740081259090002B612461002B812155002B000000003500000000652300810248091122092520000013161F…</p>
<p>Criptographic:
/v5oIBM1RlIBdACBJZCQACthJGEAK4EhVQArAAAAADUAAAAAZSMAgQJICREiCSUgAAATFh8=</p>
<p>Decoded:</p>
<pre><code class="language-json">{
    &quot;BatteryAlarm&quot;: false,
    &quot;BurstAlarm&quot;: false,
    &quot;CumulativeConsumption&quot;: &quot;612.461&quot;,
    &quot;EEPROMERROR&quot;: false,
    &quot;EmptyPipeAlarm&quot;: false,
    &quot;InstantConsumption&quot;: &quot;0.0000&quot;,
    &quot;LeakageAlarm&quot;: false,
    &quot;LowBatteryAlarm&quot;: false,
    &quot;OverRangeAlarm&quot;: false,
    &quot;OverTemperatureAlarm&quot;: false,
    &quot;PreviousDayConsumption&quot;: &quot;552.181&quot;,
    &quot;ReverseCumulativeConsumption&quot;: &quot;0.000&quot;,
    &quot;ReverseFlowAlarm&quot;: false,
    &quot;ValveStatus&quot;: &quot;open&quot;,
    &quot;WaterPressure&quot;: &quot;0.281&quot;,
    &quot;WaterTemperature&quot;: &quot;23.65&quot;
}
</code></pre>
<p>Payload Formatter (TTN):</p>
<pre><code class="language-js">function decodeUplink(input)
{
    var bytes = input.bytes;

    var bitst1, bitst1L, bitt, bittL, Bat, Battery, Code, Len, ID, Count, Unit, decimals, raw, output, Data1, Data2, Data3, Data4, Data5, Data6, Data7, Status, Err, Concat, Concat1, Concat2, Concat3, Concat4, Concat5, Concat6;
    var st1error5, st1error4, st1error3, st1error2, error7, error6, error5, error4, error3, error2, error1, error0;
    var Downlink;
    var interval, inte_unit;
    var deff = &quot;null&quot;;

    //METER SN DECODE
    if (bytes[0] == &quot;131&quot;)
    {
        //control code
        if (bytes[0] == &quot;131&quot;) { Code = bytes[0].toString(16); }

        //data length
        if (bytes[1] == &quot;10&quot;) { Len = &quot;Length of the Data Frame : &quot; + bytes[1]; }

        //data identification for meter SN uplink
        if (bytes[2] == &quot;129&quot; &amp; bytes[3] == &quot;10&quot;) { ID = &quot;Read Meter Serial Number&quot;; }

        //uplink data counter
        Count = &quot;Uplink Data Counter : &quot; + bytes[4];

        //meter SN indicator
        Data1 = bytes[5];
        Data2 = bytes[6];
        Data3 = bytes[7];
        Data4 = bytes[8];
        Data5 = bytes[9];
        Data6 = bytes[10];
        Data7 = bytes[11];
        if (Data1 &lt; 10) { Data1 = '0' + Data1.toString(16); } else { Data1 = Data1.toString(16); }
        if (Data2 &lt; 10) { Data2 = '0' + Data2.toString(16); } else { Data2 = Data2.toString(16); }
        if (Data3 &lt; 10) { Data3 = '0' + Data3.toString(16); } else { Data3 = Data3.toString(16); }
        if (Data4 &lt; 10) { Data4 = '0' + Data4.toString(16); } else { Data4 = Data4.toString(16); }
        if (Data5 &lt; 10) { Data5 = '0' + Data5.toString(16); } else { Data5 = Data5.toString(16); }
        if (Data6 &lt; 10) { Data6 = '0' + Data6.toString(16); } else { Data6 = Data6.toString(16); }
        if (Data7 &lt; 10) { Data7 = '0' + Data7.toString(16); } else { Data7 = Data7.toString(16); }
        Concat1 = Data7.concat(Data6);
        Concat2 = Data5.concat(Data4);
        Concat3 = Data3.concat(Data2);
        Concat4 = Concat1.concat(Concat2);
        Concat5 = Concat3.concat(Data1);
        Concat = Concat4.concat(Concat5);

        return {
        Command_Code: Code,
                Data_Length: Len,
                Data_Type: ID,
                Count: Count,
                Meter_Addr: Concat
        };
    }

    //METER TOTALIZER DECODE
    else if (bytes[0] == 0x81)
    {
        console.log(bytes[0])
        //control code
        if (bytes[0] == 0x81) { Code = bytes[0].toString(16); }

        //data length(not include battery indicator byte)
        if (bytes[1] == 0x0A) { Len = &quot;Length of the Data Frame : &quot; + bytes[1]; }

        //data identification for totalizer uplink
        if (bytes[2] == 0x144 &amp; bytes[3] == 0x31) { ID = &quot;Read Meter Cumulative Value&quot;; }

        //uplink data counter
        Count = &quot;Uplink Data Counter : &quot; + bytes[4];

        //decimals
        if (bytes[5] == 0x2B) { Unit = &quot;Cubic Meter&quot;; decimals = 1000; }
        else if (bytes[5] == 0x2C) { Unit = &quot;Cubic Meter&quot;; decimals = 100; }

        //totalizer
        a = bytes[6];
        b = bytes[7];
        c = bytes[8];
        d = bytes[9];
        if (a &lt; 0x10) { a = '0' + a.toString(16); } else { a = a.toString(16); }
        if (b &lt; 0x10) { b = '0' + b.toString(16); } else { b = b.toString(16); }
        if (c &lt; 0x10) { c = '0' + c.toString(16); } else { c = c.toString(16); }
        if (d &lt; 0x10) { d = '0' + d.toString(16); } else { d = d.toString(16); }
        concat1 = d.concat(c);
        concat2 = b.concat(a);
        raw = concat1.concat(concat2);
        output = raw / decimals;


        //valve indicator
        if (bytes[10] == 0x01) { Status = &quot;Valve Control : Available&quot;; } else { Status = &quot;Valve Control : Not Available&quot;; }

        //error bits ST1
        bitst1 = bytes[10];
        bitst1 = bitst1.toString(2);
        bitst1 = ('000000000' + bitst1).slice(-8);
        if (bitst1[5] == &quot;1&quot;) { st1error5 = &quot;Leakage Alert, &quot;; } else { st1error5 = &quot;&quot;; }
        if (bitst1[4] == &quot;1&quot;) { st1error4 = &quot;Burst Alert, &quot;; } else { st1error4 = &quot;&quot;; }
        if (bitst1[3] == &quot;1&quot;) { st1error3 = &quot;Tamper Alert, &quot;; } else { st1error3 = &quot;&quot;; }
        if (bitst1[2] == &quot;1&quot;) { st1error2 = &quot;Freezing Alert, &quot;; } else { st1error2 = &quot;&quot;; }
        bitst1L = st1error5 + st1error4 + st1error3 + st1error2;
        bitst1L = bitst1L.substr(0, bitst1L.length - 2);
        if (bitst1L.length == 0) { bitst1L = &quot;No st1error&quot;; }
        //if (bytes[11] == &quot;8&quot;) { Err = &quot;Transducer Outlet Error&quot;; }
        //if (bytes[11] == &quot;7&quot;) { Err = &quot;Transducer Inlet Error&quot;; }
        //if (bytes[11] == &quot;6&quot;) { Err = &quot;EEPROM Error&quot;; }
        //if (bytes[11] == &quot;5&quot;) { Err = &quot;Temperature Alert&quot;; }
        //if (bytes[11] == &quot;4&quot;) { Err = &quot;Over Range/Flow Alert&quot;; }
        //if (bytes[11] == &quot;3&quot;) { Err = &quot;Reverse Flow Alert&quot;; }
        //if (bytes[11] == &quot;2&quot;) { Err = &quot;Empty Pipe Alert&quot;; }
        //if (bytes[11] == &quot;1&quot;) { Err = &quot;Battery Alert&quot;; }
        //if (bytes[11] == &quot;0&quot;) { Err = &quot;No Error&quot;; }


        //error bits ST2
        bitt = bytes[11];
        bitt = bitt.toString(2);
        bitt = ('000000000' + bitt).slice(-8);
        if (bitt[7] == &quot;1&quot;) { error7 = &quot;Battery Alert, &quot;; } else { error7 = &quot;&quot;; }
        if (bitt[6] == &quot;1&quot;) { error6 = &quot;Empty Pipe Alert, &quot;; } else { error6 = &quot;&quot;; }
        if (bitt[5] == &quot;1&quot;) { error5 = &quot;Reverse Flow Alert, &quot;; } else { error5 = &quot;&quot;; }
        if (bitt[4] == &quot;1&quot;) { error4 = &quot;Over Range/Flow Alert, &quot;; } else { error4 = &quot;&quot;; }
        if (bitt[3] == &quot;1&quot;) { error3 = &quot;Temperature Alert, &quot;; } else { error3 = &quot;&quot;; }
        if (bitt[2] == &quot;1&quot;) { error2 = &quot;EEPROM Error, &quot;; } else { error2 = &quot;&quot;; }
        if (bitt[1] == &quot;1&quot;) { error1 = &quot;Transducer Inlet Error, &quot;; } else { error1 = &quot;&quot;; }
        if (bitt[0] == &quot;1&quot;) { error0 = &quot;Transducer Outlet Error, &quot;; } else { error0 = &quot;&quot;; }
        bittL = error7 + error6 + error5 + error4 + error3 + error2 + error1 + error0;
        bittL = bittL.substr(0, bittL.length - 2);
        if (bittL.length == 0) { bittL = &quot;No Error&quot;; }
        //if (bytes[11] == &quot;8&quot;) { Err = &quot;Transducer Outlet Error&quot;; }
        //if (bytes[11] == &quot;7&quot;) { Err = &quot;Transducer Inlet Error&quot;; }
        //if (bytes[11] == &quot;6&quot;) { Err = &quot;EEPROM Error&quot;; }
        //if (bytes[11] == &quot;5&quot;) { Err = &quot;Temperature Alert&quot;; }
        //if (bytes[11] == &quot;4&quot;) { Err = &quot;Over Range/Flow Alert&quot;; }
        //if (bytes[11] == &quot;3&quot;) { Err = &quot;Reverse Flow Alert&quot;; }
        //if (bytes[11] == &quot;2&quot;) { Err = &quot;Empty Pipe Alert&quot;; }
        //if (bytes[11] == &quot;1&quot;) { Err = &quot;Battery Alert&quot;; }
        //if (bytes[11] == &quot;0&quot;) { Err = &quot;No Error&quot;; }

        //battery indicator
        Bat = (bytes[12] - 1) / 253;
        Battery = (Bat * 100).toFixed(2);
        return {
        Command_Code: Code,
                Data_Length: Len,
                Data_Type: ID,
                Count: Count,
                Unit: Unit,
                Water_Flow_in_Cubic_Meter: output,
                Valve_Status: Status,
                Error_Status_ST2: bittL,
                Error_Status_ST1: bitst1L,
                Battery: Battery,
                Raw_Data: raw
                };
    }

    //SENDING INTERVAL DECODE
    else if (bytes[0] == &quot;34&quot;)
    {
        //control code
        if (bytes[0] == &quot;34&quot;) { Code = bytes[0].toString(16); }
        ID = &quot;Modify Meter Uplink Interval&quot;;


        //data length(not include battery indicator byte)
        if (bytes[1] == &quot;10&quot;) { Len = &quot;Length of the Data Frame : &quot; + bytes[1]; }

        //interval
        a = bytes[5].toString(16);
        b = bytes[6].toString(16);
        concat2 = b.concat(a);
        interval = parseInt(concat2, 16);
        inte_unit = &quot;minutes&quot;;

        return {
        Command_Code: Code,
                Data_Length: Len,
                Data_Type: ID,
                Uplink_Interval: interval,
                Interval_Unit: inte_unit
                };
    }

    else if(bytes[0] == &quot;81&quot;){

        if (bytes.substring(10, 12) == &quot;2B&quot;) 
        { 
            Unit = &quot;Cubic Meter&quot;; 
            decimals = 1000; 
        }
        var unit = Unit;

        a = bytes.substring(12, 14);
        b = bytes.substring(14, 16);
        c = bytes.substring(16, 18);
        d = bytes.substring(18, 20);

        a = a.toString(10);
        b = b.toString(10);
        c = c.toString(10);
        d = d.toString(10);

        concat1 = d.concat(c);
        concat2 = b.concat(a);
        raw = concat1.concat(concat2);
        var waterFlowInCubicMeter = raw / decimals;

        console.log(bytes.substring(24, 26).toString(10))

        Bat = (bytes.substring(24, 26).toString(10) - 1) / 253;
        Battery = (Bat * 100).toFixed(2);
        var battery = Battery; 

        return {
            data: {
                Unit: unit,
                WaterFlowInCubicMeter: waterFlowInCubicMeter,
                Battery: battery
            },
            };
    }

    else if(bytes[0].toString(16) == &quot;fe&quot;){

        //Cumulative Consumption
        var unitCumulativeConsuption = bytes[16];
        var base16UCC = unitCumulativeConsuption.toString(16)
        var doubleUCC = 0.001
        var decimalsToFixed = 3;
        if(base16UCC == &quot;2b&quot;){
            doubleUCC = 0.001
            decimalsToFixed = 3
        }
        else if(base16UCC == &quot;2c&quot;){
            doubleUCC = 0.01
            decimalsToFixed = 2
        }
        else if(base16UCC == &quot;2e&quot;){
            doubleUCC = 1
            decimalsToFixed = 0
        }
        else if(base16UCC == &quot;35&quot;){
            doubleUCC = 0.0001
            decimalsToFixed = 4
        }

        var cumulativeConsuption1 = bytes[20];
        var cumulativeConsuption2 = bytes[19];
        var cumulativeConsuption3 = bytes[18];
        var cumulativeConsuption4 = bytes[17];

        var base16CC1 = cumulativeConsuption1.toString(16).padStart(2, '0');
        var base16CC2 = cumulativeConsuption2.toString(16).padStart(2, '0');
        var base16CC3 = cumulativeConsuption3.toString(16).padStart(2, '0');
        var base16CC4 = cumulativeConsuption4.toString(16).padStart(2, '0');

        var base16CC = base16CC1 + base16CC2 + base16CC3 + base16CC4
        var floatCC = parseFloat(base16CC)
        var realCumulativeConsumption = (floatCC * doubleUCC).toFixed(decimalsToFixed)

        //Previous day Consumption
        var unitPreviousDayConsuption = bytes[21];
        var base16UPDC = unitPreviousDayConsuption.toString(16)
        var doubleUDPC = 0.001
        if(base16UPDC == &quot;2b&quot;){
            doubleUDPC = 0.001
            decimalsToFixed = 3
        }
        else if(base16UPDC == &quot;2c&quot;){
            doubleUDPC = 0.01
            decimalsToFixed = 2
        }
        else if(base16UPDC == &quot;2e&quot;){
            doubleUDPC = 1
            decimalsToFixed = 0
        }
        else if(base16UPDC == &quot;35&quot;){
            doubleUDPC = 0.0001
            decimalsToFixed = 4
        }


        var prevDayConsuption1 = bytes[25];
        var prevDayConsuption2 = bytes[24];
        var prevDayConsuption3 = bytes[23];
        var prevDayConsuption4 = bytes[22];

        var base16PDC1 = prevDayConsuption1.toString(16).padStart(2, '0');
        var base16PDC2 = prevDayConsuption2.toString(16).padStart(2, '0');
        var base16PDC3 = prevDayConsuption3.toString(16).padStart(2, '0');
        var base16PDC4 = prevDayConsuption4.toString(16).padStart(2, '0');

        var base16PDC = base16PDC1 + base16PDC2 + base16PDC3 + base16PDC4
        var floatPDC = parseFloat(base16PDC)
        var realPrevDayConsumption = (floatPDC * doubleUDPC).toFixed(decimalsToFixed)

        //Reverse Cumulative Consumption
        var unitReverseCumulativeConsumption = bytes[26];
        var base16URCC = unitReverseCumulativeConsumption.toString(16)
        var doubleURCC = 0.001
        if(base16URCC == &quot;2b&quot;){
            doubleURCC = 0.001
            decimalsToFixed = 3
        }
        else if(base16URCC == &quot;2c&quot;){
            doubleURCC = 0.01
            decimalsToFixed = 2
        }
        else if(base16URCC == &quot;2e&quot;){
            doubleURCC = 1
            decimalsToFixed = 0
        }
        else if(base16URCC == &quot;35&quot;){
            doubleURCC = 0.0001
            decimalsToFixed = 4
        }

        var reverseCumulativeConsumption1 = bytes[30];
        var reverseCumulativeConsumption2 = bytes[29];
        var reverseCumulativeConsumption3 = bytes[28];
        var reverseCumulativeConsumption4 = bytes[27];

        var base16RCC1 = reverseCumulativeConsumption1.toString(16).padStart(2, '0');
        var base16RCC2 = reverseCumulativeConsumption2.toString(16).padStart(2, '0');
        var base16RCC3 = reverseCumulativeConsumption3.toString(16).padStart(2, '0');
        var base16RCC4 = reverseCumulativeConsumption4.toString(16).padStart(2, '0');

        var base16RCC = base16RCC1 + base16RCC2 + base16RCC3 + base16RCC4
        var floatRCC = parseFloat(base16RCC)
        var realReverseCumulativeConsumption = (floatRCC * doubleURCC).toFixed(decimalsToFixed)

        //Instant Consumption
        var unitInstantConsumption = bytes[31];
        var base16UIC = unitInstantConsumption.toString(16)
        var doubleUIC = 0.001
        if(base16UIC == &quot;2b&quot;){
            doubleUIC = 0.001
            decimalsToFixed = 3
        }
        else if(base16UIC == &quot;2c&quot;){
            doubleUIC = 0.01
            decimalsToFixed = 2
        }
        else if(base16UIC == &quot;2e&quot;){
            doubleUIC = 1
            decimalsToFixed = 0
        }
        else if(base16UIC == &quot;35&quot;){
            doubleUIC = 0.0001
            decimalsToFixed = 4
        }

        var instanceConsumption1 = bytes[35];
        var instanceConsumption2 = bytes[34];
        var instanceConsumption3 = bytes[33];
        var instanceConsumption4 = bytes[32];

        var base16IC1 = instanceConsumption1.toString(16).padStart(2, '0');
        var base16IC2 = instanceConsumption2.toString(16).padStart(2, '0');
        var base16IC3 = instanceConsumption3.toString(16).padStart(2, '0');
        var base16IC4 = instanceConsumption4.toString(16).padStart(2, '0');

        var base16IC = base16IC1 + base16IC2 + base16IC3 + base16IC4
        var floatIC = parseFloat(base16IC)
        var realInstantConsumption = (floatIC * doubleUIC).toFixed(decimalsToFixed)

        //Water Temperature
        var waterTemperature1 = bytes[38];
        var waterTemperature2 = bytes[37];
        var waterTemperature3 = bytes[36];

        var base16WT1 = waterTemperature1.toString(16).padStart(2, '0');
        var base16WT2 = waterTemperature2.toString(16).padStart(2, '0');
        var base16WT3 = waterTemperature3.toString(16).padStart(2, '0');

        var base16WT = base16WT1 + base16WT2 + base16WT3
        var floatWT = parseFloat(base16WT)
        var realWaterTemperature = (floatWT * 0.01).toFixed(2)

        //Water Pressure
        var waterPressure1 = bytes[40];
        var waterPressure2 = bytes[39];

        var base16WP1 = waterPressure1.toString(16).padStart(2, '0');
        var base16WP2 = waterPressure2.toString(16).padStart(2, '0');

        var base16WP = base16WP1 + base16WP2
        var floatWP = parseFloat(base16WP)
        var realWaterPressure = (floatWP * 0.001).toFixed(3)


        var ST1 = bytes[48];
        var ST1Binary = ST1.toString(2).padStart(8, '0');

        valveStatusBinary = ST1Binary.substring(6)
        var valveStatus = &quot;open&quot;
        if(valveStatusBinary == &quot;00&quot;){
            valveStatus = &quot;open&quot;
        } else if(valveStatusBinary == &quot;01&quot;){
            valveStatus = &quot;close&quot;
        } else if(valveStatusBinary == &quot;11&quot;){
            valveStatus = &quot;abnormal&quot;
        }

        var batteryAlarmBinary = ST1Binary.substring(5, 6)
        var batteryAlarm = batteryAlarmBinary == &quot;0&quot; ? false : true

        var ST2 = bytes[49];
        var ST2Binary = ST2.toString(2).padStart(8, '0');

        var lowBatteryAlarmBinary = ST2Binary.substring(7)
        var lowBatteryAlarm = lowBatteryAlarmBinary == &quot;0&quot; ? false : true

        var emptyPipeAlarmBinary = ST2Binary.substring(6,7)
        var emptyPipeAlarm = emptyPipeAlarmBinary == &quot;0&quot; ? false : true

        var reverseFlowAlarmBinary = ST2Binary.substring(5,6)
        var reverseFlowAlarm = reverseFlowAlarmBinary == &quot;0&quot; ? false : true

        var overRangeAlarmBinary = ST2Binary.substring(4,5)
        var overRangeAlarm = overRangeAlarmBinary == &quot;0&quot; ? false : true

        var overTemperatureAlarmBinary = ST2Binary.substring(3,4)
        var overTemperatureAlarm = overTemperatureAlarmBinary == &quot;0&quot; ? false : true

        var EEPROMErrorBinary = ST2Binary.substring(2,3)
        var EEPROMError = EEPROMErrorBinary == &quot;0&quot; ? false : true

        var leakageAlarmBinary = ST2Binary.substring(1,2)
        var leakageAlarm = leakageAlarmBinary == &quot;0&quot; ? false : true

        var burstAlarmBinary = ST2Binary.substring(0,1)
        var burstAlarm = burstAlarmBinary == &quot;0&quot; ? false : true

        return {
            data: {
                CumulativeConsumption: realCumulativeConsumption,
                PreviousDayConsumption: realPrevDayConsumption,
                ReverseCumulativeConsumption: realReverseCumulativeConsumption,
                InstantConsumption: realInstantConsumption,
                WaterTemperature: realWaterTemperature,
                WaterPressure: realWaterPressure,
                ValveStatus: valveStatus,
                BatteryAlarm: batteryAlarm,
                LowBatteryAlarm: lowBatteryAlarm,
                EmptyPipeAlarm: emptyPipeAlarm,
                ReverseFlowAlarm: reverseFlowAlarm,
                OverRangeAlarm: overRangeAlarm,
                OverTemperatureAlarm: overTemperatureAlarm,
                EEPROMERROR: EEPROMError,
                LeakageAlarm: leakageAlarm,
                BurstAlarm: burstAlarm
            },
        };
    }
}
</code></pre>
<ul>
<li>IQSV DC and BP (new ones - from Sep/2025):</li>
</ul>
<p><strong>Attributes:</strong>
BatteryAlarm: bool<br />
CumulativeConsumption: decimal (water flow since the moment the device is turned ON) -&gt; * 264.172052 = value in gallons
EEPROMERROR: bool (no idea what is it)<br />
EmptyPipeAlarm: bool (when no flow)<br />
InstantConsumption: decimal (water flow in this moment PER HOUR) -&gt; * 264.172052 = value in gallons
LeakageAlarm: bool (when there is a leak in the device/pipe)
LowBatteryAlarm: bool (when the battery is low)
OverRangeAlarm: bool (no idea what is it)
OverTemperatureAlarm: bool (temperature defined in the firmware)
PreviousDayConsumption: decimal (water flow yesterday)  -&gt; * 264.172052 = value in gallons
ReverseCumulativeConsumption: decimal (if there is a flow in reverse) -&gt;  * 264.172052 = value in gallons
ReverseFlowAlarm: bool (when reverse flow)
ValveStatus: open/close/ <strong>half-open (25%, 50% or 75%)</strong>
WaterPressure: decimal (in MPA) -&gt; * 145.038 to convert to PSI
WaterTemperature: decimal (in Celsius) -&gt; Need to convert to °F
<strong>PowerSupply: Battery/External Power Supply</strong></p>
<p>Payload:</p>
<p>Bytes:
FEFE68100000000000000000000000002324000000000200C11615</p>
<p>Criptographic:
/v5oEAAAAAAAAAAAAAAAACMkAAAAAAIAwRYV</p>
<p>Decoded:</p>
<pre><code class="language-json">{
    &quot;BatteryAlarm&quot;: false,
    &quot;BurstAlarm&quot;: false,
    &quot;CumulativeConsumption&quot;: &quot;612.461&quot;,
    &quot;EEPROMERROR&quot;: false,
    &quot;EmptyPipeAlarm&quot;: false,
    &quot;InstantConsumption&quot;: &quot;0.0000&quot;,
    &quot;LeakageAlarm&quot;: false,
    &quot;LowBatteryAlarm&quot;: false,
    &quot;OverRangeAlarm&quot;: false,
    &quot;OverTemperatureAlarm&quot;: false,
    &quot;PreviousDayConsumption&quot;: &quot;552.181&quot;,
    &quot;ReverseCumulativeConsumption&quot;: &quot;0.000&quot;,
    &quot;ReverseFlowAlarm&quot;: false,
    &quot;ValveStatus&quot;: &quot;open&quot;,
    &quot;WaterPressure&quot;: &quot;0.281&quot;,
    &quot;WaterTemperature&quot;: &quot;23.65&quot;
}
</code></pre>
<p>Payload Formatter (TTN):</p>
<pre><code class="language-js">function decodeUplink(input) {
  const bytes = input.bytes;
  const toLEHex = (arr) =&gt;
    arr.map(b =&gt; b.toString(16).padStart(2, &quot;0&quot;)).reverse().join(&quot;&quot;).toUpperCase();

  const applyScale = (digitStr, scale) =&gt; {
    const s = digitStr.replace(/[^0-9]/g, &quot;&quot;);
    let core = s.replace(/^0+/, &quot;&quot;);
    if (core.length === 0) core = &quot;0&quot;;

    if (core.length &lt;= scale) core = core.padStart(scale + 1, &quot;0&quot;);

    const p = core.length - scale;
    const withPoint = core.slice(0, p) + &quot;.&quot; + core.slice(p);
    return withPoint.startsWith(&quot;.&quot;) ? &quot;0&quot; + withPoint : withPoint;
  };

  let off = 4;

  const cumulativeHex = toLEHex(bytes.slice(off, off + 4)); off += 4;
  const cumulativeStr = applyScale(cumulativeHex, 3);

  const reverseHex = toLEHex(bytes.slice(off, off + 4)); off += 4;
  const reverseStr = applyScale(reverseHex, 3);

  const flowHex = toLEHex(bytes.slice(off, off + 4)); off += 4;
  const flowStr = applyScale(flowHex, 4);

  const tempHex = toLEHex(bytes.slice(off, off + 3)); off += 3;
  const tempStr = applyScale(tempHex, 2);

  const pressureHex = toLEHex(bytes.slice(off, off + 2)); off += 2;
  const pressureStr = applyScale(pressureHex, 3);

  const st1 = bytes[off++];
  const valveBits = st1 &amp; 0b11;
  const ValveStatus = (valveBits === 0b00) ? &quot;open&quot;
                    : (valveBits === 0b01) ? &quot;close&quot;
                    : (valveBits === 0b10) ? &quot;half-open&quot;
                    : &quot;abnormal&quot;;
  const BatteryAlarm = (st1 &amp; 0b00000100) !== 0;

  const st2 = bytes[off++];
  const LowBatteryAlarm    = (st2 &amp; 0b00000001) !== 0;
  const EmptyPipeAlarm     = (st2 &amp; 0b00000010) !== 0;
  const ReverseFlowAlarm   = (st2 &amp; 0b00000100) !== 0;
  const OverRangeAlarm     = (st2 &amp; 0b00001000) !== 0;
  const OverTemperatureAlarm = (st2 &amp; 0b00010000) !== 0;
  const EEPROMERROR        = (st2 &amp; 0b00100000) !== 0;
  const LeakageAlarm       = (st2 &amp; 0b01000000) !== 0;

  const powerSupplyByte = bytes[off++];
  const PowerSupply = (powerSupplyByte === 0x00) ? &quot;Battery&quot; : &quot;Connected&quot;;


  return {
    data: {
      CumulativeConsumption: cumulativeStr,         
      ReverseCumulativeConsumption: reverseStr,
      InstantConsumption: flowStr,
      WaterTemperature: tempStr,
      WaterPressure: pressureStr,
      LowBatteryAlarm,
      EmptyPipeAlarm,
      ReverseFlowAlarm,
      OverRangeAlarm,
      OverTemperatureAlarm,
      EEPROMERROR,
      LeakageAlarm,
      ValveStatus,
      BatteryAlarm,
      PowerSupply
    }
  }
}
</code></pre>
<h2 id="iqwm">IQWM</h2>
<p>IQWM devices are installed directly in the pipe and measure the water flow. It sends one uplink every 6 hours and has the history of water consumption in the last 12 hours.<br />
If one uplink failes, the consumption can be recovered in the next uplink, since the next one will be sent after 6 hours and it contains the last 12 hours of consumption history </p>
<p><strong>Attributes:</strong>
batteryStatus: decimal
clockDate: 09/22 (date - example: Sep 22th)
clockTime: 11:16 (time - example 11h16m)
currentReading: decimal (water flow since the moment the device is turned ON) -&gt; * 264.172052 = value in gallons
burstAlarm: bool (same as IQSV)
eepromError: bool (same as IQSV)
emptyPipeAlarm: bool (same as IQSV)
freezingAlarm: bool (when freezed)
leakageAlarm: bool (same as IQSV)
lowBatteryAlarm: bool (same as IQSV)
overRangeAlarm: bool  (same as IQSV)
overTemperatureAlarm: bool  (same as IQSV)
reverseFlowAlarm: bool  (same as IQSV)
tamperAlarm: bool (when moved) 
log-1: decimal (* 264.172052 = consumption gallons)
log-1-Time: "23:00 00:00" (initial and final time reading)
...
log-12: decimal,
log-12-Time: "10:00 11:00" (initial and final time reading)</p>
<p>Payload:</p>
<p>Bytes:
FEFEBA9003006D000F00080012000600000008001D00EF001B00040007000006092211167BFE</p>
<p>Criptographic:
/v66kAMAbQAPAAgAEgAGAAAACAAdAO8AGwAEAAcAAAYJIhEWe/4=</p>
<p>Decoded:</p>
<pre><code class="language-json">{
    &quot;batteryStatus&quot;: 100,
    &quot;clockDate&quot;: &quot;09/22&quot;,
    &quot;clockTime&quot;: &quot;11:16&quot;,
    &quot;currentReading&quot;: 233.658,
    &quot;meterStatus&quot;: {
      &quot;flags&quot;: {
        &quot;burstAlarm&quot;: false,
        &quot;eepromError&quot;: false,
        &quot;emptyPipeAlarm&quot;: true,
        &quot;freezingAlarm&quot;: false,
        &quot;leakageAlarm&quot;: false,
        &quot;lowBatteryAlarm&quot;: false,
        &quot;overRangeAlarm&quot;: false,
        &quot;overTemperatureAlarm&quot;: false,
        &quot;reserved1&quot;: false,
        &quot;reserved2&quot;: false,
        &quot;reserved3&quot;: false,
        &quot;reserved4&quot;: false,
        &quot;reserved5&quot;: false,
        &quot;reserved6&quot;: false,
        &quot;reverseFlowAlarm&quot;: true,
        &quot;tamperAlarm&quot;: false
      },
      &quot;raw&quot;: 1536
    },
    &quot;parameters&quot;: [
      {
        &quot;log-1&quot;: 0.109,
        &quot;log-1-Time&quot;: &quot;23:00 00:00&quot;
      },
      {
        &quot;log-2&quot;: 0.015,
        &quot;log-2-Time&quot;: &quot;00:00 01:00&quot;
      },
      {
        &quot;log-3&quot;: 0.008,
        &quot;log-3-Time&quot;: &quot;01:00 02:00&quot;
      },
      {
        &quot;log-4&quot;: 0.018,
        &quot;log-4-Time&quot;: &quot;02:00 03:00&quot;
      },
      {
        &quot;log-5&quot;: 0.006,
        &quot;log-5-Time&quot;: &quot;03:00 04:00&quot;
      },
      {
        &quot;log-6&quot;: 0,
        &quot;log-6-Time&quot;: &quot;04:00 05:00&quot;
      },
      {
        &quot;log-7&quot;: 0.008,
        &quot;log-7-Time&quot;: &quot;05:00 06:00&quot;
      },
      {
        &quot;log-8&quot;: 0.029,
        &quot;log-8-Time&quot;: &quot;06:00 07:00&quot;
      },
      {
        &quot;log-9&quot;: 0.239,
        &quot;log-9-Time&quot;: &quot;07:00 08:00&quot;
      },
      {
        &quot;log-10&quot;: 0.027,
        &quot;log-10-Time&quot;: &quot;08:00 09:00&quot;
      },
      {
        &quot;log-11&quot;: 0.004,
        &quot;log-11-Time&quot;: &quot;09:00 10:00&quot;
      },
      {
        &quot;log-12&quot;: 0.007,
        &quot;log-12-Time&quot;: &quot;10:00 11:00&quot;
      }
    ]
}
</code></pre>
<p>Payload Formatter (TTN):</p>
<pre><code class="language-js">function decodeUplink(input) {
  const bytes = input.bytes;

  // Fixed sizes
  const startBytesSize = 4; // 4 bytes
  const logEntriesSize = 12 * 2; // 12 logs, each 2 bytes
  const meterStatusSize = 2; // 2 bytes
  const timestampSize = 4; // 4 bytes (clock format)
  const batteryStatusSize = 1; // 1 byte (last byte)

  const fixedSize = startBytesSize + logEntriesSize + meterStatusSize + timestampSize + batteryStatusSize;

  // Validate byte array length
  if (bytes.length &lt;= fixedSize) {
    return { data: {}, warnings: [], errors: [&quot;Invalid byte array length. Expected fixed size.&quot;] };
  }


  let hexString = bytes.map((byte) =&gt; byte.toString(16).padStart(2, '0')).join('');
  hexString = hexString.substring(4); // Remove the first 2 bytes

  // Extract Current Reading (first 4 bytes) and convert to integer (Little Endian)
  const currentReadingHex = hexString.substring(0, 8);
  const currentReadingLittleEndian =
    currentReadingHex.substring(6, 8) +
    currentReadingHex.substring(4, 6) +
    currentReadingHex.substring(2, 4) +
    currentReadingHex.substring(0, 2);
  const currentReading = (parseInt(currentReadingLittleEndian, 16) / 1000).toFixed(3);

  // Extract 12 log entries (convert each to Little Endian signed 16-bit integer)
  const parameters = [];
  let index = 8; // Start after currentReading
  for (let i = 0; i &lt; 12; i++) {
    const paramHex = hexString.substring(index, index + 4);
    const littleEndianHex = paramHex.substring(2, 4) + paramHex.substring(0, 2);
    const paramInt = toSignedInt16(parseInt(littleEndianHex, 16))/1000;
    parameters.push(paramInt);
    index += 4;
  }

  // Extract Meter Status (2 bytes) and parse flags
  const meterStatusHex = hexString.substring(index, index + 4);
  const littleEndianMeterStatus =
    meterStatusHex.substring(2, 4) + meterStatusHex.substring(0, 2);
  const meterStatus = parseInt(littleEndianMeterStatus, 16);

  const meterStatusFlags = {};
  const firstByte = parseInt(littleEndianMeterStatus.substring(0, 2), 16);
  meterStatusFlags.lowBatteryAlarm = Boolean(firstByte &amp; 0b00000001);
  meterStatusFlags.emptyPipeAlarm = Boolean(firstByte &amp; 0b00000010);
  meterStatusFlags.reverseFlowAlarm = Boolean(firstByte &amp; 0b00000100);
  meterStatusFlags.overRangeAlarm = Boolean(firstByte &amp; 0b00001000);
  meterStatusFlags.overTemperatureAlarm = Boolean(firstByte &amp; 0b00010000);
  meterStatusFlags.eepromError = Boolean(firstByte &amp; 0b00100000);
  meterStatusFlags.reserved1 = Boolean(firstByte &amp; 0b01000000);
  meterStatusFlags.reserved2 = Boolean(firstByte &amp; 0b10000000);

  const secondByte = parseInt(littleEndianMeterStatus.substring(2, 4), 16);
  meterStatusFlags.leakageAlarm = Boolean(secondByte &amp; 0b00000100);
  meterStatusFlags.burstAlarm = Boolean(secondByte &amp; 0b00001000);
  meterStatusFlags.tamperAlarm = Boolean(secondByte &amp; 0b00010000);
  meterStatusFlags.freezingAlarm = Boolean(secondByte &amp; 0b00100000);
  meterStatusFlags.reserved3 = Boolean(secondByte &amp; 0b00000001);
  meterStatusFlags.reserved4 = Boolean(secondByte &amp; 0b00000010);
  meterStatusFlags.reserved5 = Boolean(secondByte &amp; 0b01000000);
  meterStatusFlags.reserved6 = Boolean(secondByte &amp; 0b10000000);

  index += 4;

  // Extract Clock Time (4 bytes)
  const clockHex = hexString.substring(index, index + 8);

  const hours = parseInt(clockHex.substring(4, 6), 10); // First 2 hex digits represent hours
  const minutes = parseInt(clockHex.substring(6, 8), 10); // Last 2 hex digits represent minutes
  const clockTime = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;

  const day = parseInt(clockHex.substring(0, 2), 10); // Last 2 hex digits represent minutes

  const month = parseInt(clockHex.substring(2, 4), 10); // Last 2 hex digits represent minutes
  const clockDate = `${day.toString().padStart(2, '0')}/${month.toString().padStart(2, '0')}`;


  index += 8;

  var hrs = hours;

// Initialize the combined array
var combined_time_array = [];

// Generate the past 12 entries
for (let i = 0; i &lt; 12; i++) {
  // Format the current hour and minute as HH:MM
  let currentTime = `${hrs.toString().padStart(2, '0')}:00`;

  // Calculate the previous hour
  let previousHrs = hrs - 1;
  if (previousHrs &lt; 0) {
    previousHrs = 23; // Handle rollover to the previous day
  }

  // Format the previous hour and minute as HH:MM
  let previousTime = `${previousHrs.toString().padStart(2, '0')}:00`;

  // Combine the two times and add to the array
  combined_time_array.push(`${previousTime} ${currentTime}`);

  // Decrement the hour
  hrs -= 1;

  // Handle rollover to the previous day
  if (hrs &lt; 0) {
    hrs = 23;
  }
}

  // Extract Battery Status (1 byte, last byte of the array) and divide by 2.54
  const batteryStatusRaw = parseInt(hexString.substring(hexString.length - 2), 16);
  const batteryStatus = (batteryStatusRaw / 2.54).toFixed(2);

  // Prepare the response
  return {
    data: {
      currentReading: parseFloat(currentReading), // Convert back to number for output
      parameters: parameters.map((param, i) =&gt; ({ [`log-${i + 1}`]: param , [`log-${i + 1}-Time`]: combined_time_array[11-i]})), // Signed 16-bit integers
      meterStatus: {
        raw: meterStatus,
        flags: meterStatusFlags
      },
      clockTime, // Time as HH:MM
      clockDate, // Month/Day 
      batteryStatus: parseFloat(batteryStatus), // Convert back to number for output
    },
    warnings: [],
    errors: []
  };
}

// Helper function to convert int16_t to signed number
function toSignedInt16(value) {
  value = value &amp; 0xFFFF; // Ensure 16 bits
  if (value &amp; 0x8000) { // Check MSB for negative
    return value - 0x10000; // Convert to signed
  }
  return value; // Positive values remain unchanged
}
</code></pre>
<h2 id="lambdas-for-example">Lambdas for example</h2>
<h3 id="lambda-functions">Lambda Functions</h3>
<p>The Lambda functions are the <strong>core</strong> of the system.<br />
They handle all calculations and business logic decisions.</p>
<h1 id="lambda-function-process_iqsl">Lambda Function: <code>Process_iqsl</code></h1>
<h2 id="purpose">Purpose</h2>
<p>Only for Water Leak Devices of type IQSL. Doesn't include Toilet Sensors</p>
<h2 id="main-operations-and-algorithms">Main Operations and Algorithms:</h2>
<ul>
<li>
<p>Temperature: from Celcius to Fahrenheit</p>
</li>
<li>
<p>Saves all connected gateways in a list and saves it in the database.</p>
</li>
<li>
<p>Saves data in the iqwl_data table and updates the latest data in the devices_last_data table.</p>
</li>
</ul>
<p>Note: Alerts are not sent by this Lambda. This Lambda sends data to another Lambda (SendAlertNotification) and that one will decide whether to send an alert.</p>
<hr />
<h2 id="input-source">Input Source</h2>
<p>Receives messages from the following SQS queue:<br />
<strong><code>iqsl_uplink_queue</code></strong></p>
<h2 id="output-destinations">Output Destinations</h2>
<ul>
<li>Sends data to Lambda: <strong><code>SendAlertNotification</code></strong></li>
<li>Stores data in the following tables:</li>
<li><code>devices_details</code></li>
<li><code>iqsl_data</code></li>
<li><code>devices_last_data</code></li>
</ul>
<hr />
<h2 id="input-format-json">Input Format (JSON)</h2>
<pre><code class="language-json">{
    &quot;device_id&quot;: &quot;123&quot;,
    &quot;application_id&quot;: &quot;app1&quot;,
    &quot;dev_eui&quot;: &quot;1234&quot;,
    &quot;read_time&quot;: &quot;2025-07-02T19:16:38.982846975Z&quot;,
    &quot;payload_type&quot;: &quot;Heartbeat&quot;,
    &quot;payload_type_id&quot;: 1,
    &quot;battery_percentage&quot;: 38,
    &quot;battery_voltage&quot;: 3.16,
    &quot;external_leak_detection_enabled&quot;: true,
    &quot;pin_leak_detection_enabled&quot;: true,
    &quot;tamper_detection_enabled&quot;: true,
    &quot;humidity&quot;: 54.2,
    &quot;last_rssi&quot;: -42,
    &quot;last_snr&quot;: 13,
    &quot;external_leak_detected&quot;: false,
    &quot;jack_detected&quot;: false,
    &quot;magnet_detected&quot;: false,
    &quot;pin_leak_detected&quot;: false,
    &quot;power_detected&quot;: false,
    &quot;state_as_uint8&quot;: 7,
    &quot;temperature&quot;: 24.33,
    &quot;frame_count&quot;: 2677,
    &quot;metadata&quot;: [
        {
            &quot;gateway_ids&quot;: {
                &quot;gateway_id&quot;: &quot;eui-58a0cbfffe8040c1&quot;,
                &quot;eui&quot;: &quot;58A0CBFFFE8040C1&quot;
            },
            &quot;time&quot;: &quot;2025-07-02T19:16:38.982846975Z&quot;,
            &quot;timestamp&quot;: 2143403483,
            &quot;rssi&quot;: -63,
            &quot;channel_rssi&quot;: -63,
            &quot;snr&quot;: 9.25,
            &quot;uplink_token&quot;: &quot;CiIKIAoUZXVpLTU4YTBjYmZmZmU4MDQwYzESCFigy//+gEDBENv7hv4HGgwIl4uWwwYQyZ28jAEg+L625rA+&quot;,
            &quot;received_at&quot;: &quot;2025-07-02T19:16:39.241239981Z&quot;
        },
        {
            &quot;gateway_ids&quot;: {
                &quot;gateway_id&quot;: &quot;iqgw-tk-20&quot;,
                &quot;eui&quot;: &quot;647FDAFFFE01F36D&quot;
            },
            &quot;timestamp&quot;: 1245444315,
            &quot;rssi&quot;: -78,
            &quot;channel_rssi&quot;: -78,
            &quot;snr&quot;: 9.5,
            &quot;uplink_token&quot;: &quot;ChgKFgoKaXFndy10ay0yMBIIZH/a//4B820Q2/Hv0QQaDAiXi5bDBhCLqciXASD4rpDSn+UU&quot;,
            &quot;received_at&quot;: &quot;2025-07-02T19:16:39.125916168Z&quot;
        }
    ]
}
</code></pre>
<h1 id="lambda-function-process_long_flush_iqsl">Lambda Function: <code>Process_long_flush_iqsl</code></h1>
<h2 id="purpose_1">Purpose</h2>
<p>Only for Toilet Sensor Devices from type IQSL filtered by the uplinks of type LONG_FLUSH (payload_type_id = 10).</p>
<h2 id="main-operations-and-algorithms_1">Main Operations and Algorithms:</h2>
<h3 id="how-does-long-flush-work">How Does Long Flush Work?</h3>
<p>The device only sends the uplink <strong>after 3 minutes (default)</strong> of continuous flushing.<br />
In other words, when the uplink is received, the flushing has already been occurring for 3 minutes.<br />
Because of that, the Lambda must register that the flush <strong>started 3 minutes earlier</strong>.</p>
<hr />
<h3 id="end-of-flush">End of Flush</h3>
<p>When a flush ends, a different type of uplink is sent:<br />
<strong>Last Event Water Usage</strong> (<code>payload_type_id = 11</code>).<br />
However, this uplink is processed by <strong>another Lambda</strong>:<br />
<code>Process_water_usage_iqsl</code>.</p>
<hr />
<h3 id="custom-long-flush-duration">Custom Long Flush Duration</h3>
<p>The user can request the device to register a flush <strong>only after 4 or more minutes</strong>. In this case:</p>
<ol>
<li>An external API (not the Lambda) stores on the device the setting that long flush should be recorded after 4+ minutes.</li>
<li>The Lambda checks the device settings in the database.</li>
<li>Based on the setting:</li>
<li><strong>If it's set to 3 minutes (default):</strong><br />
     The long flush is recorded normally.</li>
<li><strong>If it's set to more than 3 minutes (late long flush):</strong>  <ul>
<li>The long flush is saved to the database.  </li>
<li>The property <code>long_event_hide_on_dashboard</code> is set to <code>False</code>, so it <strong>won't appear on the Dashboard</strong>.  </li>
<li>A <strong>schedule is created in EventBridge</strong> to trigger the long flush later via the <code>LateLongFlush</code> Lambda.</li>
</ul>
</li>
</ol>
<hr />
<h3 id="notes">Notes</h3>
<ul>
<li>
<p>There is <strong>no information</strong> about gallons used in the flush in this uplink.<br />
  This data will arrive in a separate uplink of type <strong>Last Event Water Usage</strong> (<code>payload_type_id = 11</code>).</p>
</li>
<li>
<p>The device is renamed with a <code>-flow</code> suffix to distinguish Toilet Sensor data from Leak Sensor data,<br />
  since <strong>IQSL includes both sensor types</strong> in the same transmitter.</p>
</li>
</ul>
<hr />
<h2 id="input-source_1">Input Source</h2>
<p>Receives messages from the following SQS queue:<br />
<strong><code>iqsl_long_flush_uplink_queue</code></strong></p>
<h2 id="output-destinations_1">Output Destinations</h2>
<ul>
<li>Sends data to Lambda: <strong><code>SendAlertToiletNotification</code></strong>, <strong><code>LateLongFlush</code></strong></li>
<li>Stores data in the following tables:</li>
<li><code>devices_details</code></li>
<li><code>iqsl_alerts_data</code></li>
<li><code>devices_last_data</code></li>
</ul>
<hr />
<h2 id="input-format-json_1">Input Format (JSON)</h2>
<pre><code class="language-json">{
    &quot;device_id&quot;: &quot;123&quot;,
    &quot;application_id&quot;: &quot;app2&quot;,
    &quot;dev_eui&quot;: &quot;1234&quot;,
    &quot;read_time&quot;: &quot;2025-07-02T19:11:57.283046007Z&quot;,
    &quot;payload_type&quot;: &quot;Alert&quot;,
    &quot;payload_type_id&quot;: 10,
    &quot;alert_type&quot;: &quot;Pulse Counting (Long Event Alert)&quot;,
    &quot;current_status&quot;: 1,
    &quot;pulse_duration_trigger&quot;: 180000,
    &quot;frame_count&quot;: 3642
}
</code></pre>
<h1 id="lambda-function-process_water_usage_iqsl">Lambda Function: <code>Process_water_usage_iqsl</code></h1>
<h2 id="purpose_2">Purpose</h2>
<p>Only for Toilet Sensor Devices from type IQSL filtered by the uplinks of type WATER_USAGE (payload_type_id = 11).</p>
<h2 id="main-operations-and-algorithms_2">Main Operations and Algorithms:</h2>
<h3 id="how-does-water-usage-work">How Does Water Usage Work?</h3>
<p>Gallons_spent = Pulse_total_pulses * 0.264172</p>
<p>Water usage can occur after a normal flush or after a Long Flush.</p>
<p>If it is after a normal flush, then it simply records in the database that a flush occurred without needing to calculate when the flush started. However, there can be two types:</p>
<ul>
<li>Above 1 gallon: <strong>"normal flush"</strong></li>
<li>Equal to or less than 1 gallon: <strong>"escape"</strong> (value too low to be a real flush)</li>
</ul>
<p>If it is after a Long Flush, then:</p>
<ul>
<li>If the Long Flush has already been registered, then this Water Usage must be recorded at the moment the Long Flush started. The type of this flush must be <strong>"long"</strong>.</li>
<li>If the Long Flush has not yet been registered on the dashboard [see late long flush], then the Long Flush should not appear on the dashboard. Instead, it should appear as a normal flush, without the need to calculate when the flush started.</li>
</ul>
<hr />
<h2 id="input-source_2">Input Source</h2>
<p>Receives messages from the following SQS queue:<br />
<strong><code>iqsl_water_usage_uplink_queue</code></strong></p>
<h2 id="output-destinations_2">Output Destinations</h2>
<ul>
<li>Sends data to Lambda: <strong><code>SendAlertToiletNotification</code></strong></li>
<li>Stores data in the following tables:</li>
<li><code>devices_details</code></li>
<li><code>iqsl_alerts_data</code></li>
<li><code>devices_last_data</code></li>
</ul>
<hr />
<h2 id="input-format-json_2">Input Format (JSON)</h2>
<pre><code class="language-json">{
    &quot;device_id&quot;: &quot;123&quot;,
    &quot;application_id&quot;: &quot;app1&quot;,
    &quot;dev_eui&quot;: &quot;1234&quot;,
    &quot;read_time&quot;: &quot;2025-07-02T20:13:31.984311103Z&quot;,
    &quot;payload_type&quot;: &quot;Alert&quot;,
    &quot;payload_type_id&quot;: 11,
    &quot;alert_type&quot;: &quot;Pulse Counting Event (Last Event Usage)&quot;,
    &quot;humidity&quot;: 54.33,
    &quot;temperature&quot;: 23.64,
    &quot;pulse_device_type_id&quot;: 1,
    &quot;pulse_total_pulses&quot;: 2902,
    &quot;pulse_total_liters&quot;: 2.694521819870009,
    &quot;frame_count&quot;: 24465
}
</code></pre>
<h1 id="lambda-function-process_toilet_heartbeat_iqsl">Lambda Function: <code>Process_toilet_heartbeat_iqsl</code></h1>
<h2 id="purpose_3">Purpose</h2>
<p>Only for Toilet Sensor Devices from Type IQSL filtered by the uplinks of type HEARTBEAT (payload_type_id = 9).</p>
<h2 id="main-operations-and-algorithms_3">Main Operations and Algorithms:</h2>
<h3 id="how-does-the-heartbeat-work">How Does the Heartbeat Work?</h3>
<p>The heartbeat shows what has occurred since the last heartbeat:</p>
<ul>
<li>Number of flushes  </li>
<li>Gallons spent  </li>
</ul>
<hr />
<p><strong>Note:</strong><br />
If a long flush is currently happening and has not yet finished, and a heartbeat is sent,<br />
then the gallons spent during this ongoing long flush are <strong>pre-calculated</strong>.</p>
<hr />
<h2 id="input-source_3">Input Source</h2>
<p>Receives messages from the following SQS queue:<br />
<strong><code>IQWLWaterLeakUplinkQueue</code></strong></p>
<h2 id="output-destinations_3">Output Destinations</h2>
<ul>
<li>Sends data to Lambda: <strong><code>iqsl_toilet_heartbeat_uplink_queue</code></strong></li>
<li>Stores data in the following tables:</li>
<li><code>devices_details</code></li>
<li><code>iqsl_alerts_data</code></li>
<li><code>devices_last_data</code></li>
</ul>
<hr />
<h2 id="input-format-json_3">Input Format (JSON)</h2>
<pre><code class="language-json">{
    &quot;device_id&quot;: &quot;123&quot;,
    &quot;application_id&quot;: &quot;app1&quot;,
    &quot;dev_eui&quot;: &quot;1234&quot;,
    &quot;read_time&quot;: &quot;2025-07-02T20:18:57.869425058Z&quot;,
    &quot;payload_type&quot;: &quot;Alert&quot;,
    &quot;payload_type_id&quot;: 9,
    &quot;alert_type&quot;: &quot;Pulse Counting (Total Events)&quot;,
    &quot;pulse_long_event_triggered&quot;: 0,
    &quot;pulse_alert_interval&quot;: 500,
    &quot;pulse_device_type_id&quot;: 1,
    &quot;pulse_total_events&quot;: 11,
    &quot;pulse_total_pulses&quot;: 11,
    &quot;pulse_total_liters&quot;: 0.01021355617455896,
    &quot;frame_count&quot;: 325
}
</code></pre>
<h1 id="lambda-function-process_alerts_iqsl">Lambda Function: <code>Process_alerts_iqsl</code></h1>
<h2 id="purpose_4">Purpose</h2>
<p>Only for Leak Sensor and Toilet Sensor Devices of type IQSL filtered by the uplinks of payload_type_id = 1,2,3,4,5,6,7,8 and 12.</p>
<h2 id="main-operations-and-algorithms_4">Main Operations and Algorithms:</h2>
<h3 id="processing-based-on-payload_type_id">Processing Based on <code>payload_type_id</code></h3>
<p>Depending on the <code>payload_type_id</code>, the processing is different:</p>
<ul>
<li>
<p><strong>payload_type_id = 1</strong> → Leak Detected External (LEAK SENSOR)<br />
  Saves the event and calls the Lambda <strong>SendAlertNotification</strong> to send an alert.</p>
</li>
<li>
<p><strong>payload_type_id = 2</strong> → Leak Detected Local (LEAK SENSOR)<br />
  Saves the event and calls the Lambda <strong>SendAlertNotification</strong> to send an alert.</p>
</li>
<li>
<p><strong>payload_type_id = 3</strong> → Tamper (LEAK SENSOR)<br />
  Saves the event. This uplink is sent when the device comes into contact with the magnet (not actual movement).</p>
</li>
<li>
<p><strong>payload_type_id = 4</strong> → Button Pressed (LEAK SENSOR)<br />
  Saves the event.</p>
</li>
<li>
<p><strong>payload_type_id = 5</strong> → High Temperature (LEAK SENSOR)<br />
  Saves the event and calls the Lambda <strong>SendAlertNotification</strong> to send an alert.</p>
</li>
<li>
<p><strong>payload_type_id = 6</strong> → Low Temperature (LEAK SENSOR)<br />
  Saves the event and calls the Lambda <strong>SendAlertNotification</strong> to send an alert.</p>
</li>
<li>
<p><strong>payload_type_id = 7</strong> → High Humidity (LEAK SENSOR)<br />
  Saves the event and calls the Lambda <strong>SendAlertNotification</strong> to send an alert.</p>
</li>
<li>
<p><strong>payload_type_id = 8</strong> → Low Humidity (LEAK SENSOR)<br />
  Saves the event and calls the Lambda <strong>SendAlertNotification</strong> to send an alert.</p>
</li>
<li>
<p><strong>payload_type_id = 12</strong> → Headphone Jack Alert (LEAK SENSOR)<br />
  Saves the event.</p>
</li>
</ul>
<hr />
<h2 id="input-source_4">Input Source</h2>
<p>Receives messages from the following SQS queue:<br />
<strong><code>iqsl_alerts_uplink_queue</code></strong></p>
<h2 id="output-destinations_4">Output Destinations</h2>
<ul>
<li>Sends data to Lambda: <strong><code>SendAlertNotification</code></strong>, <strong><code>SendAlertToiletNotification</code></strong></li>
<li>Stores data in the following tables:</li>
<li><code>devices_details</code></li>
<li><code>iqsl_data</code></li>
<li><code>iqsl_alerts_data</code></li>
<li><code>devices_last_data</code></li>
</ul>
<hr />
<h2 id="input-format-json-example-only-for-payload_type_id-2">Input Format (JSON) - example only for payload_type_id = 2</h2>
<pre><code class="language-json">{
    &quot;device_id&quot;: &quot;123&quot;,
    &quot;application_id&quot;: &quot;app4&quot;,
    &quot;dev_eui&quot;: &quot;1234&quot;,
    &quot;read_time&quot;: &quot;2025-07-02T18:46:19.129642963Z&quot;,
    &quot;payload_type&quot;: &quot;Alert&quot;,
    &quot;payload_type_id&quot;: 2,
    &quot;alert_type&quot;: &quot;Local Leak Detection (Via Bottom Contact Pins)&quot;,
    &quot;current_status&quot;: 0,
    &quot;current_value&quot;: 3044,
    &quot;humidity&quot;: 49.23,
    &quot;temperature&quot;: 23.68,
    &quot;delay_count&quot;: 1,
    &quot;trigger_value&quot;: 5000,
    &quot;frame_count&quot;: 2789
}
</code></pre>
<h2 id="downlinks">Downlinks</h2>
<p>Tip: use this site to facilitate the convert from base to hex <a href="https://cryptii.com/pipes/base64-to-hex">base64-to-hex</a></p>
<h3 id="working-on">Working on...</h3>
<p>Downlinks
Alerts</p>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8z"/></svg>
  Back to top
</button>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      <script id="__config" type="application/json">{"base": ".", "features": ["navigation.instant", "navigation.tabs", "navigation.top", "search.suggest", "search.highlight", "content.code.copy"], "search": "assets/javascripts/workers/search.d50fe291.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
    
    
      <script src="assets/javascripts/bundle.56ea9cef.min.js"></script>
      
    
  </body>
</html>