{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"arkIQ System Documentation","text":""},{"location":"#ttn-to-aws","title":"TTN to AWS","text":"<ol> <li> <p>Uplink sent from TTN to AWS</p> </li> <li> <p>AWS IoT Core receives the uplinks.    A separate IoT Core Rule is defined for each device type, extracting the necessary information from each uplink.</p> </li> <li> <p>The extracted data is sent to a dedicated queue for each device type.</p> </li> <li> <p>Each queue triggers a separate Lambda function, which processes the received data and follows a distinct path depending on the device.</p> </li> <li> <p>Alerts If necessary, alerts are sent via email and SMS.</p> </li> <li> <p>Database Storage Processed data is stored in the database.</p> </li> </ol> <p>From now on (September, 2025) the new devices should be onboarded on AWS IoT Core</p>"},{"location":"#device-types","title":"Device Types:","text":"<p>arkIQ has different types of devices</p> <p>1- IQWL: Leak Sensor 2- IQSL: Leak Sensor + Toilet Sensor 3- IQWM: Water Meter 4- IQSV: Smart Valve  </p>"},{"location":"#iqwl","title":"IQWL","text":"<p>Attributes: Water Leak Detected: boolean Tamper Detected: boolean Button Pressed: boolean Temperature (Celsius): decimal Humidity (%): decimal Battery (V): decimal</p> <p>Payload:</p> <p>Bytes: 00 08 d2 00 3e</p> <p>Criptographic: AAjSAD4=</p> <p>Decoded:</p> <pre><code>{\n  \"battery_volt\": 2.9,\n  \"button\": 0,\n  \"humi\": 62,\n  \"tamper\": 0,\n  \"temperature\": 21,\n  \"water\": 0\n}\n</code></pre> <p>Payload Formatter (TTN):</p> <pre><code>function hex2bin(hex){\n  return (parseInt(hex, 16).toString(2)).padStart(8, '0');\n}\n\n//IQWL sensor\nfunction decodeUplink(input) {\n    let fPort = input.fPort;\n    let payloadlens = input.bytes.length;\n    if(fPort==126 &amp;&amp; payloadlens==5){\n        let intput_list = input.bytes;\n        let battery_int=intput_list[1];// battery calculate\n        battery_volt = (21+battery_int)/10;\n        temperature_hex= (intput_list[3].toString(16).padStart(2, '0'))+(intput_list[2].toString(16).padStart(2, '0'));  //temperature calculate\n        if((parseInt(temperature_hex, 16))&gt;1250){\n            temperature = ((parseInt(temperature_hex, 16))-65536)/10;\n        }\n        else{\n            temperature = (parseInt(temperature_hex, 16))/10;\n        }\n\n        humi =  intput_list[4]; //Humidity calculate\n        let water_hex = intput_list[0].toString(16).padStart(2, '0'); // Sensor Status calculate\n        let water_binary = hex2bin(water_hex); \n        let water_st = water_binary.substring(7, 8); \n        let button_st = water_binary.substring(6, 7); \n        let tamper_st = water_binary.substring(5, 6); \n\n        water = parseInt(water_st); // water status\n        button = parseInt(button_st); // Button pressed\n        tamper = parseInt(tamper_st); // Tamper detected\n\n        return {\n        data: {\n        battery_volt,\n        temperature,\n        humi,\n        water,\n        button,\n        tamper\n        },\n        };\n    }\n    else if (fPort==126 &amp;&amp; payloadlens==4){\n        let intput_list = input.bytes;\n        let battery_int=intput_list[1];// battery calculate\n        battery_volt = (21+battery_int)/10;\n        temperature_int= intput_list[2]; //temperature calculate\n        if(temperature_int&gt;125){\n            temperature = temperature_int-256;\n        }\n        else{\n            temperature = temperature_int;\n        }\n        humi =  intput_list[3]; //Humidity calculate\n\n        let water_hex = intput_list[0].toString(16).padStart(2, '0'); // Sensor Status calculate\n        let water_binary = hex2bin(water_hex); \n        let water_st = water_binary.substring(7, 8); \n        let button_st = water_binary.substring(6, 7); \n        let tamper_st = water_binary.substring(5, 6); \n\n        water = parseInt(water_st); // water status\n        button = parseInt(button_st); // Button pressed\n        tamper = parseInt(tamper_st); // Tamper detected\n\n        return {\n        data: {\n        battery_volt,\n        temperature,\n        humi,\n        water,\n        button,\n        tamper\n        },\n        };\n    }\n    //Fireware Info\n    else if (fPort==204 &amp;&amp; payloadlens==9){\n    let message = 'This is fireware info.';\n    byteArray = input.bytes;\n    let payload = byteArray.map(byte =&gt; byte.toString(16).padStart(2, '0')).join('');\n    return {\n      data: {\n              fPort,\n                message,\n                payload\n              },\n            };\n    }\n    //Configuration Info\n    else if (fPort==204 &amp;&amp; payloadlens==11){\n    let message = 'This is configuration info.';\n    byteArray = input.bytes;\n    let payload = byteArray.map(byte =&gt; byte.toString(16).padStart(2, '0')).join('');\n    return {\n      data: {\n              fPort,\n                message,\n                payload\n              },\n            };\n    }\n    else{\n            let fPort = input.fPort;\n            let payloadlength = input.bytes.length;\n            let message = 'Invalid fPort or payload length';\n            return {\n              data: {\n                fPort,\n                payloadlength,\n                message,\n              },\n            };\n    }\n}\n</code></pre>"},{"location":"#iqwl-dual-chip","title":"IQWL Dual Chip","text":"<p>Some IQWL has dual chip: 1. Lorawan 2. Sidewalk</p> <p>By default, when it's turned ON, it will try to connect to Lorawan.</p> <p>If after 3 attempts, it doesn't connect to Lorawan, it will connect to AMAZON Sidewalk.</p>"},{"location":"#what-are-the-difference-between-iqwl-chip-lorawan-and-iqwl-chip-sidewalk","title":"What are the difference between IQWL chip Lorawan and IQWL chip Sidewalk","text":"<ul> <li>Lorawan needs to be connected to a network and be cover by a LoRaWAN gateway. Sidewalk doesn't need Gateways.</li> <li>Sidewalk uses the devices from Amazon to spread the connection</li> <li>Sidewalk nowadays (year 2025) only work in United States, but soon it will be active to other countries as well (coverage.sidewalk.amazon)</li> </ul> <p>In September 2025, the Sidewalk devices are not in arkIQ cloud. It's in another cloud. The uplinks are forwarded via a Lambda that is connected to an AWS IoT Core Rule from the other AWS Account. We are working to bring all the Sidewalk chips to our cloud</p>"},{"location":"#iqsl","title":"IQSL","text":"<p>This device is in the same time a Leak Sensor and a Transmitter: </p> <ol> <li> <p>Leak Sensor: detects leak using its probs (Similar to IQWL devices).</p> </li> <li> <p>Transmitter: it's possible to connect a headphone jack wth two functionalities:</p> </li> <li> <p>Extends Leak Sensor capacity. Another device can be connected to the IQSL that detects Water Leaks. So, using the Headphone Jack, the other device will let the IQSL know that there is an external Leak. Attribute externalLeakDetectionEnabled = TRUE to extend the Leak Detection to the headphone jack. Attribute externalLeakDetected = TRUE if the extensor detects leak.</p> </li> <li> <p>Connect a Toilet Sensor. The Toilet Sensor is a device that can be connected directly on a Toilet Pipe and it will give information about flushes and water usage. It can be connected using the Headphone Jack and will send toilet information to the transmitter. attribute externalLeakDetected = FALSE to make Toilet Sensor works. </p> </li> </ol> <p>The platform need to show if the IQSL is connected to a Leak Sensor, or to a Toilet Sensor, or if there's no headphone jack connected</p> <p>1- Heartbeat Packet (fPort = 0x01) Attributes: Battery Voltage (V) batteryPercentage (%) Temperature (Celsius) Humidity (%) pinLeakDetectionEnabled: boolean (default: true) externalLeakDetectionEnabled: boolean (TRUE to work the Leak Sensor extensor. FALSE to work the Toilet Sensor) tamperDetectionEnabled: boolean pinLeakDetected: boolean (if it's occuring a leak right now) externalLeakDetected: boolean (if Toilet Sensor connected, then always FALSE) powerDetected: boolean (No idea what is this) jackDetected: boolean (True, if connected to a Toilet Sensor) magnetDetected: boolean (Tamper detection using a magnet)</p> <p>Water Leak Detected: boolean Tamper Detected: boolean Button Pressed: boolean Temperature (Celsius): decimal Humidity (%): decimal</p> <p>Payload:</p> <p>Bytes: 01B06408D614720BFFB405</p> <p>Criptographic: AbBkCNYUcgv/tAU=</p> <p>Decoded:</p> <pre><code>        \"data\": {\n          \"batteryPercentage\": 100,\n          \"batteryVoltage\": 3.52,\n          \"enabledAlerts\": {\n            \"externalLeakDetectionEnabled\": false,\n            \"pinLeakDetectionEnabled\": true,\n            \"tamperDetectionEnabled\": true\n          },\n          \"humidity\": 52.34,\n          \"lastRssi\": -76,\n          \"lastSnr\": 11,\n          \"state\": {\n            \"externalLeakDetected\": false,\n            \"jackDetected\": false,\n            \"magnetDetected\": false,\n            \"pinLeakDetected\": false,\n            \"powerDetected\": false\n          },\n          \"stateAsUint8\": 5,\n          \"temperature\": 22.62\n        },\n        \"payloadType\": \"Heartbeat\",\n        \"payloadTypeId\": 1\n</code></pre> <p>2- Alert Packets (fPort = 0x02) Triggered when a specific event occurs. The first byte (bytes[0]) defines the alert type:</p> <p>Case 1: External Leak (via headphone jack) - not applied, because the Toilet Sensor will be connected to the headphone Jack, not a Leak Sensor Extensor. Attributes: triggerValue: (No idea what is it) currentValue: int (how moisture is it. Can define the level to consider it a leak detected) temperature  humidity  delayCount (No idea what is it) currentState: boolean (true = leak detected. false = leak cleared) </p> <p>(IMPORTANT) Case 2: Local Leak (via bottom contact pins) Only activate if the attribute pinLeakDetectionEnabled = true Attributes: triggerValue: (No idea what is it) currentValue: int (how moisture is it. Can define the level to consider it a leak detected) temperature  humidity  delayCount (No idea what is it) currentState: boolean (true = leak detected. false = leak cleared) </p> <p>Case 3: Tamper (magnet detected) - Activate when the magnet touch the device, simulating a tamper. Only activate if the attribute tamperDetectionEnabled = true</p> <p>Case 4: Push button pressed - Activated when button is pressed</p> <p>Case 5: Temperature High. Defined by downlink th hreshold Case 6: Temperature Low. Case 7: Humidity High. Case 8: Humidity Low.   From 5 to 8: Each includes current value, trigger threshold, guardband (safety margin), delay, and state.</p> <p>(IMPORTANT) Case 9: Total Events (cumulative counter): Toilet Sensor Heartbeat Attributes: longEventTriggered: boolean (is it occuring a Long Flush right now? True = yes. False = No) alertInterval (no Idea what is it) deviceTypeId (no Idea what is it) totalEvents: int (How many flushes occured since the last heartbeat) totalLiters: decimal (How many litters were spent since the last heartbeat) -&gt; Convert to Gallons (litters ** 0.264172) totalPulses: decimal (How many pulses were spent since the last heartbeat)</p> <p>Payload:</p> <p>Bytes: 0900001661000101000005</p> <p>Criptographic: CQAAFmEAAQEAAAU=</p> <p>Decoded:</p> <pre><code>{\n        \"alertType\": \"Pulse Counting (Total Events)\",\n        \"data\": {\n          \"longEventTriggered\": 0,\n          \"settings\": {\n            \"alertInterval\": 500,\n            \"deviceTypeId\": 1\n          },\n          \"totalEvents\": 1,\n          \"totalLiters\": 5.319405756731662,\n          \"totalPulses\": 5729\n        },\n        \"payloadType\": \"Alert\",\n        \"payloadTypeId\": 9\n      }\n</code></pre> <p>(IMPORTANT) Case 10: Long Event Alert (long-duration events): Toilet Sensor Long Event detected</p> <p>Attriubtes: currentState: boolean (True = started. False: Ended) durationTrigger: int (How many time flushing is consider a Long Flush and it will trigger this payload - in milliseconds)</p> <p>Note: this payload will only be triggered after the pulse_duration_trigger interval. So we don't know when the flush started, but we know when the flush is running for a long time. So in order to identify when the flush started, it has to subtract the pulse_duration_trigger value.</p> <p>Payload:</p>"},{"location":"#bytes","title":"Bytes:","text":""},{"location":"#criptographic","title":"Criptographic:","text":"<p>Decoded:</p> <pre><code>{\n        \"alertType\": \"Pulse Counting (Long Event Alert)\",\n        \"data\": {\n          \"currentState\": 1,\n          \"settings\": {\n            \"durationTrigger\": 180000\n          },\n        },\n        \"payloadType\": \"Alert\",\n        \"payloadTypeId\": 10\n      }\n</code></pre> <p>(IMPORTANT) Case 11: Last Event Usage (usage of the last event): Toilet Sensor water usage when a flush (normal or long) ends</p> <p>Attriubtes: totalLiters: decimal (how many litters was spent in the last flush)  -&gt; Convert to Gallons (litters x 0.264172) totalPulses: decimal (how many pulses was spent in the last flush) humidity (%) temperature (Celsius)</p> <p>Note: this payload will be triggered only after a flush (normal or long).  - If this flush was a normal flush, we don't know how much time this flush was running. However, we know by this payload when it finished. - If this flush was a long flush, we know when it started, because the Long Flush payload (type: 10) was triggered before this payload of Last Event Usage (type: 11). - One challenge is to assign the Last Event Usage payload (type: 11) with the Long Flush payload (type: 10), because the payloads will be triggered in different moments. Also, the Last Event Usage payload doesn't indicate if the last event usage was long or a normal flush. - If the last flush spent less then 1 gallon. So this is consider a Scape, not a normal flush </p> <p>Payload:</p> <p>Bytes: 0B00001CCC01088115FF</p> <p>Criptographic: CwAAHMwBCIEV/w==</p> <p>Decoded:</p> <pre><code>{\n  \"alertType\": \"Pulse Counting Event (Last Event Usage)\",\n  \"data\": {\n    \"humidity\": 56.31,\n    \"settings\": {\n      \"deviceTypeId\": 1\n    },\n    \"temperature\": 21.77,\n    \"totalLiters\": 6.84493964716806,\n    \"totalPulses\": 7372\n  },\n  \"payloadType\": \"Alert\",\n  \"payloadTypeId\": 11\n}\n</code></pre> <p>(IMPORTANT) Case 12: Jack connected / disconnected Attriubtes: jackConnected: Boolean (true: yes. false: no)</p> <p>Payload:</p>"},{"location":"#bytes_1","title":"Bytes:","text":""},{"location":"#criptographic_1","title":"Criptographic:","text":"<p>3- System Packets (fPort = 0x03) Maintenance/system packets.</p> <p>Case 0x01: Network Test Packet \u2192 reports SNR and RSSI.</p> <p>Case 0x02: Joined Uplink Packet \u2192 confirms joining the network and sends configs:</p> <p>firmwareVersion, heartbeatInterval, sensorCheckInterval.</p> <p>Which alerts are enabled (bitmasks in bytes[7] and bytes[8]).</p> <p>Used for network testing and initial configuration after join.</p> <p>4- Parameter Values (fPort = 0x04)</p> <p>Here we have many subtypes (dozens). These are configuration/parameterization packets. The first byte (bytes[0]) indicates which parameter. Examples: Identifiers * Case 0: devEui. * Case 1: appEui. * Case 2: appKey (disabled for security reasons). Network and operation configs * Case 3\u20139: retry, confirm mode, join mode, ADR, device class, duty cycle, datarate. * Case 10\u201315: RX1/RX2 delays, datarate, TX power. * Case 16\u201319: region, channel mask, network mode, mode. Operation groups * Case 21\u201326: heartbeat interval, join group, network test group, battery group, no-ack recovery, heartbeat group. Event acknowledgements * Case 27\u201337: Individual acks for external leak, pin leak, tamper, button, temp high/low, humidity high/low, pulse count, etc. Detailed sensor configs * Cases 38\u201346: Leak detection (pin/external) + buzzer + all-in-one parameters. * Cases 47\u201359: Button, high/low temperature, high/low humidity, all with buzzer/guardband/delay. * Case 60\u201361: temperature/humidity offsets. * Case 62: sensing interval. * Case 63\u201364: pulse counting configs. * Case 65\u201369: Jack detection (enabled, buzzer, ack, etc.) and global buzzer control.</p> <p>Summary of the Payload Packets:</p> <ul> <li>Heartbeat (0x01): general status (battery, SNR, sensors, flags).</li> <li>Alerts (0x02): triggered events (leak, tamper, button, temperature, humidity, pulses, jack).</li> <li>System (0x03): network/system packets (tests, join, firmware).</li> <li>Parameters (0x04): massive set of configuration parameters (network, ADR, alerts, delays, buzzer, offsets, etc.).</li> </ul>"},{"location":"#iqsl-payload-formatter-ttn","title":"IQSL Payload Formatter (TTN):","text":"<pre><code>function DoDecode(fPort, bytes) {\n    var decoded = { data: {} };\n    switch (fPort) {\n        case 0x01: { // HeartBeat Packet\n\n            decoded.data.state = {};\n            decoded.data.enabledAlerts = {};\n            decoded.payloadType = \"Heartbeat\";\n            decoded.payloadTypeId = bytes[0];\n            decoded.data.batteryVoltage = (bytes[1] / 100) * 2;\n            decoded.data.batteryPercentage = bytes[2];\n            decoded.data.temperature = UInt16(bytes[3] &lt;&lt; 8 | bytes[4]) / 100;\n            decoded.data.humidity = (bytes[5] &lt;&lt; 8 | bytes[6]) / 100;\n            decoded.data.lastSnr = Int8(bytes[7]);\n            decoded.data.lastRssi = Int16(bytes[8] &lt;&lt; 8 | bytes[9]);\n            decoded.data.stateAsUint8 = bytes[10];\n            decoded.data.enabledAlerts.pinLeakDetectionEnabled = ((bytes[10] &amp; 0b00000001) &gt; 0);\n            decoded.data.enabledAlerts.externalLeakDetectionEnabled = ((bytes[10] &amp; 0b00000010) &gt; 0);\n            decoded.data.enabledAlerts.tamperDetectionEnabled = ((bytes[10] &amp; 0b00000100) &gt; 0);\n            decoded.data.state.pinLeakDetected = ((bytes[10] &amp; 0b00001000) &gt; 0);\n            decoded.data.state.externalLeakDetected = ((bytes[10] &amp; 0b00010000) &gt; 0);\n            decoded.data.state.powerDetected = ((bytes[10] &amp; 0b00100000) &gt; 0);\n            decoded.data.state.jackDetected = ((bytes[10] &amp; 0b01000000) &gt; 0);\n            decoded.data.state.magnetDetected = ((bytes[10] &amp; 0b10000000) &gt; 0);\n        }\n            break;\n        case 0x02: { // Alert Packet\n\n            decoded.payloadType = \"Alert\";\n            decoded.payloadTypeId = bytes[0];\n\n            switch (bytes[0]) {\n                case 1: {\n                    decoded.data.settings = {};\n                    decoded.alertType = \"External Leak Detection (Via Headphone Jack)\";\n                    decoded.data.settings.triggerValue = UInt16(bytes[1] &lt;&lt; 8 | bytes[2]);\n                    decoded.data.currentValue = UInt16(bytes[3] &lt;&lt; 8 | bytes[4]);\n                    decoded.data.temperature = Int16(bytes[5] &lt;&lt; 8 | bytes[6]) / 100;\n                    decoded.data.humidity = UInt16(bytes[7] &lt;&lt; 8 | bytes[8]) / 100;\n                    decoded.data.settings.delayCount = bytes[9];\n                    decoded.data.currentState = bytes[10];\n                } break;\n                case 2: {\n                    decoded.data.settings = {};\n                    decoded.alertType = \"Local Leak Detection (Via Bottom Contact Pins)\";\n                    decoded.data.settings.triggerValue = UInt16(bytes[1] &lt;&lt; 8 | bytes[2]);\n                    decoded.data.currentValue = UInt16(bytes[3] &lt;&lt; 8 | bytes[4]);\n                    decoded.data.temperature = Int16(bytes[5] &lt;&lt; 8 | bytes[6]) / 100;\n                    decoded.data.humidity = UInt16(bytes[7] &lt;&lt; 8 | bytes[8]) / 100;\n                    decoded.data.settings.delayCount = bytes[9];\n                    decoded.data.currentState = bytes[10];\n                } break;\n                case 3: {\n                    decoded.alertType = \"Tamper Detection (Magnet Presence)\";\n                    decoded.data.currentValue = bytes[1];\n                } break;\n                case 4: {\n                    decoded.alertType = \"Push Button Pressed\";\n                    decoded.data.duration = UInt16(bytes[1] &lt;&lt; 8 | bytes[2]);\n                    decoded.data.turningOff = bytes[3];\n                } break;\n                case 5: {\n                    decoded.data.settings = {};\n                    decoded.alertType = \"Temperature Alert (High)\";\n                    decoded.data.temperature = Int16(bytes[1] &lt;&lt; 8 | bytes[2]) / 100;\n                    decoded.data.settings.triggerValue = Int16(bytes[3] &lt;&lt; 8 | bytes[4]) / 100;\n                    decoded.data.settings.guardbandValue = Int16(bytes[5] &lt;&lt; 8 | bytes[6]) / 100;\n                    decoded.data.humidity = UInt16(bytes[7] &lt;&lt; 8 | bytes[8]) / 100;\n                    decoded.data.settings.delayCount = bytes[9];\n                    decoded.data.currentState = bytes[10];\n                } break;\n                case 6: {\n                    decoded.data.settings = {};\n                    decoded.alertType = \"Temperature Alert (Low)\";\n                    decoded.data.temperature = Int16(bytes[1] &lt;&lt; 8 | bytes[2]) / 100;\n                    decoded.data.settings.triggerValue = Int16(bytes[3] &lt;&lt; 8 | bytes[4]) / 100;\n                    decoded.data.settings.guardbandValue = Int16(bytes[5] &lt;&lt; 8 | bytes[6]) / 100;\n                    decoded.data.humidity = UInt16(bytes[7] &lt;&lt; 8 | bytes[8]) / 100;\n                    decoded.data.settings.delayCount = bytes[9];\n                    decoded.data.currentState = bytes[10];\n                } break;\n                case 7: {\n                    decoded.data.settings = {};\n                    decoded.alertType = \"Humidity Alert (High)\";\n                    decoded.data.humidity = UInt16(bytes[1] &lt;&lt; 8 | bytes[2]) / 100;\n                    decoded.data.settings.triggerValue = Int16(bytes[3] &lt;&lt; 8 | bytes[4]) / 100;\n                    decoded.data.settings.guardbandValue = Int16(bytes[5] &lt;&lt; 8 | bytes[6]) / 100;\n                    decoded.data.temperature = Int16(bytes[7] &lt;&lt; 8 | bytes[8]) / 100;\n                    decoded.data.settings.delayCount = bytes[9];\n                    decoded.data.currentState = bytes[10];\n                } break;\n                case 8: {\n                    decoded.data.settings = {};\n                    decoded.alertType = \"Humidity Alert (Low)\";\n                    decoded.data.humidity = UInt16(bytes[1] &lt;&lt; 8 | bytes[2]) / 100;\n                    decoded.data.settings.triggerValue = Int16(bytes[3] &lt;&lt; 8 | bytes[4]) / 100;\n                    decoded.data.settings.guardbandValue = Int16(bytes[5] &lt;&lt; 8 | bytes[6]) / 100;\n                    decoded.data.temperature = Int16(bytes[7] &lt;&lt; 8 | bytes[8]) / 100;\n                    decoded.data.settings.delayCount = bytes[9];\n                    decoded.data.currentState = bytes[10];\n                } break;\n                case 9: {\n                    decoded.data.settings = {};\n                    decoded.alertType = \"Pulse Counting (Total Events)\";\n\n                    decoded.data.totalPulses = (bytes[1] &lt;&lt; 24) + (bytes[2] &lt;&lt; 16) + (bytes[3] &lt;&lt; 8) + bytes[4];\n                    decoded.data.totalEvents = UInt16(bytes[5] &lt;&lt; 8 | bytes[6]);\n                    decoded.data.settings.deviceTypeId = bytes[7];\n                    decoded.data.longEventTriggered = bytes[8];\n                    decoded.data.settings.alertInterval = UInt16(bytes[9] &lt;&lt; 8 | bytes[10]) * 100;\n\n                    switch (decoded.data.settings.deviceTypeId) {\n                        // Generic Device Type, no usage calculations\n                        case 0x00: {\n\n                        } break;\n                        // Toilet Flow Sensor\n                        case 0x01: {\n                            // F=18*Q-3 = 1077 pulses, Q(L/s) = f/1077, Q(L/min) = f*60/1077 = f/18*Q-3, Q(L/hour) = f*60*60/1077 = f*60/18*Q-3  \n                            decoded.data.totalLiters = decoded.data.totalPulses / 1077;\n                        } break;\n                    }\n\n                } break;\n                case 10: {\n                    decoded.data.settings = {};\n                    decoded.alertType = \"Pulse Counting (Long Event Alert)\";\n                    decoded.data.currentState = bytes[1];\n                    decoded.data.settings.durationTrigger = UInt16(bytes[2] &lt;&lt; 8 | bytes[3]) * 100;\n                } break;\n                case 11: {\n                    decoded.data.settings = {};\n                    decoded.alertType = \"Pulse Counting Event (Last Event Usage)\";\n                    decoded.data.totalPulses = (bytes[1] &lt;&lt; 24) + (bytes[2] &lt;&lt; 16) + (bytes[3] &lt;&lt; 8) + bytes[4];\n                    decoded.data.settings.deviceTypeId = bytes[5];\n                    decoded.data.temperature = Int16(bytes[6] &lt;&lt; 8 | bytes[7]) / 100;\n                    decoded.data.humidity = UInt16(bytes[8] &lt;&lt; 8 | bytes[9]) / 100;\n                    switch (decoded.data.settings.deviceTypeId) {\n                        // Generic Device Type, no usage calculations\n                        case 0x00:\n                        case 0x01: {\n                            decoded.data.totalLiters = decoded.data.totalPulses / 1077;\n                        } break;\n                    }\n\n                } break;\n                case 12: {\n                    decoded.alertType = \"Headphone Jack Alert\";\n                    decoded.data.currentValue = bytes[1];\n                } break;\n            }\n        } break;\n        case 0x03: { // System Packets\n\n            decoded.payloadType = \"System\";\n            decoded.payloadTypeId = bytes[0];\n            switch (bytes[0]) {\n                // \"Network Test Packet\"\n                case 0x01: {\n                    decoded.systemType = \"Network Test Packet\";\n                    decoded.data.snr = Int8(bytes[1]);\n                    decoded.data.rssi = Int16(bytes[2] &lt;&lt; 8 | bytes[3]);\n                } break;\n                // \"Joined Uplink Packet\"\n                case 0x02: {\n                    decoded.data.settings = {};\n                    decoded.data.settings.enabledAlerts = {};\n                    decoded.systemType = \"Joined Uplink Packet\";\n                    decoded.data.firmwareVersion = UInt16(bytes[1] &lt;&lt; 8 | bytes[2]);\n                    decoded.data.settings.heartbeatInterval = UInt16(bytes[3] &lt;&lt; 8 | bytes[4]);\n                    decoded.data.settings.sensorCheckInterval = UInt16(bytes[5] &lt;&lt; 8 | bytes[6]);\n                    decoded.data.settings.enabledAlerts.pinLeakDetection = ((bytes[7] &amp; 0b00000001) &gt; 0);\n                    decoded.data.settings.enabledAlerts.externalLeakDetection = ((bytes[7] &amp; 0b00000010) &gt; 0);\n                    decoded.data.settings.enabledAlerts.tamperDetection = ((bytes[7] &amp; 0b00000100) &gt; 0);\n                    decoded.data.settings.enabledAlerts.pushButton = ((bytes[7] &amp; 0b00001000) &gt; 0);\n                    decoded.data.settings.enabledAlerts.temperatureHigh = ((bytes[7] &amp; 0b00010000) &gt; 0);\n                    decoded.data.settings.enabledAlerts.temperatureLow = ((bytes[7] &amp; 0b00100000) &gt; 0);\n                    decoded.data.settings.enabledAlerts.humidityHigh = ((bytes[7] &amp; 0b01000000) &gt; 0);\n                    decoded.data.settings.enabledAlerts.humidityLow = ((bytes[7] &amp; 0b10000000) &gt; 0);\n                    decoded.data.settings.enabledAlerts.pulseCountingAlert = ((bytes[8] &amp; 0b00000001) &gt; 0);\n                    decoded.data.settings.enabledAlerts.pulseCountingEventLongAlert = ((bytes[8] &amp; 0b00000010) &gt; 0);\n\n                } break;\n            }\n\n        }\n            break;\n        case 0x04: { // Parameter Values\n\n            decoded.payloadType = \"Parameter Values\";\n            decoded.payloadTypeId = bytes[0];\n\n            switch (bytes[0]) {\n                // devEui Parameter\n                case 0: {\n                    let devEuiTemp = \"\";\n                    devEuiTemp += bytes[1].toString(16).padStart(2, '0').toUpperCase();\n                    devEuiTemp += bytes[2].toString(16).padStart(2, '0').toUpperCase();\n                    devEuiTemp += bytes[3].toString(16).padStart(2, '0').toUpperCase();\n                    devEuiTemp += bytes[4].toString(16).padStart(2, '0').toUpperCase();\n                    devEuiTemp += bytes[5].toString(16).padStart(2, '0').toUpperCase();\n                    devEuiTemp += bytes[6].toString(16).padStart(2, '0').toUpperCase();\n                    devEuiTemp += bytes[7].toString(16).padStart(2, '0').toUpperCase();\n                    devEuiTemp += bytes[8].toString(16).padStart(2, '0').toUpperCase();\n\n                    decoded.parameterType = \"devEui\";\n                    decoded.data.devEui = devEuiTemp;\n                } break;\n                // appEui Parameter\n                case 1: {\n                    let appEuiTemp = \"\";\n                    appEuiTemp += bytes[1].toString(16).padStart(2, '0').toUpperCase();\n                    appEuiTemp += bytes[2].toString(16).padStart(2, '0').toUpperCase();\n                    appEuiTemp += bytes[3].toString(16).padStart(2, '0').toUpperCase();\n                    appEuiTemp += bytes[4].toString(16).padStart(2, '0').toUpperCase();\n                    appEuiTemp += bytes[5].toString(16).padStart(2, '0').toUpperCase();\n                    appEuiTemp += bytes[6].toString(16).padStart(2, '0').toUpperCase();\n                    appEuiTemp += bytes[7].toString(16).padStart(2, '0').toUpperCase();\n                    appEuiTemp += bytes[8].toString(16).padStart(2, '0').toUpperCase();\n\n                    decoded.parameterType = \"appEui\";\n                    decoded.data.appEui = appEuiTemp;\n                } break;\n                // appKey Parameter\n                case 2: {\n                    decoded.parameterType = \"appKey\";   // This is not enabled for security reasons\n                } break;\n                // Retry Parameter\n                case 3: {\n                    decoded.parameterType = \"retry\";\n                    decoded.data.retry = bytes[1];\n                } break;\n                // Confirm Mode Parameter\n                case 4: {\n                    decoded.parameterType = \"Confirm Mode\";\n                    decoded.data.confirmMode = bytes[1];\n                } break;\n                // Join Mode Parameter\n                case 5: {\n                    decoded.parameterType = \"Join Mode\";\n                    decoded.data.joinMode = bytes[1];\n                } break;\n                // ADR Parameter\n                case 6: {\n                    decoded.parameterType = \"ADR\";\n                    decoded.data.adr = bytes[1];\n                } break;\n                // Device Class Parameter\n                case 7: {\n                    decoded.parameterType = \"Device Class\";\n                    decoded.data.deviceClass = bytes[1];\n                } break;\n                // Duty Cycle Parameter\n                case 8: {\n                    decoded.parameterType = \"Duty Cycle\";\n                    decoded.data.dutyCycle = bytes[1];\n                } break;\n                // Datarate Parameter\n                case 9: {\n                    decoded.parameterType = \"Datarate\";\n                    decoded.data.datarate = bytes[1];\n                } break;\n                // Join Delay RX1 Parameter\n                case 10: {\n                    decoded.parameterType = \"Join Delay RX1\";\n                    decoded.data.joinDelayRx1 = UInt16(bytes[1] &lt;&lt; 8 | bytes[2]);\n                } break;\n                // Join Delay RX2 Parameter\n                case 11: {\n                    decoded.parameterType = \"Join Delay RX2\";\n                    decoded.data.joinDelayRx2 = UInt16(bytes[1] &lt;&lt; 8 | bytes[2]);\n                } break;\n                // Public Network Mode Parameter\n                case 12: {\n                    decoded.parameterType = \"Public Network Mode\";\n                    decoded.publicNetworkMode = bytes[1];\n                } break;\n                // RX1 Delay Parameter\n                case 13: {\n                    decoded.parameterType = \"RX1 Delay\";\n                    decoded.data.rx1Delay = UInt16(bytes[1] &lt;&lt; 8 | bytes[2]);\n                } break;\n                // RX2 Delay Parameter\n                case 14: {\n                    decoded.parameterType = \"RX2 Delay\";\n                    decoded.data.rx2Delay = UInt16(bytes[1] &lt;&lt; 8 | bytes[2]);\n                } break;\n                // RX2 Datarate Parameter\n                case 15: {\n                    decoded.parameterType = \"RX2 Datarate\";\n                    decoded.data.rx2Datarate = bytes[1];\n                } break;\n                // TX Power Parameter\n                case 16: {\n                    decoded.parameterType = \"TX Power\";\n                    decoded.data.txPower = bytes[1];\n                } break;\n                // Region Parameter\n                case 17: {\n                    decoded.parameterType = \"Region\";\n                    decoded.data.region = bytes[1];\n                } break;\n                // Channel Mask Parameter\n                case 18: {\n                    let channelMaskTemp = \"\";\n                    channelMaskTemp += bytes[1].toString(16).padStart(2, '0').toUpperCase();\n                    channelMaskTemp += bytes[2].toString(16).padStart(2, '0').toUpperCase();\n\n                    decoded.parameterType = \"Channel Mask\";\n                    decoded.data.channelMask = channelMaskTemp;\n                } break;\n                // Network Mode Parameter\n                case 19: {\n                    decoded.parameterType = \"Network Mode\";\n                    decoded.data.networkMode = bytes[1];\n                } break;\n                // Mode Parameter\n                case 20: {\n                    decoded.parameterType = \"Mode\";\n                    decoded.data.mode = bytes[1];\n                } break;\n                // Heartbeat Interval Parameter\n                case 21: {\n                    decoded.parameterType = \"Heartbeat Interval\";\n                    decoded.data.heartbeatInterval = UInt16(bytes[1] &lt;&lt; 8 | bytes[2]);\n                } break;\n                // Join Group Parameter\n                case 22: {\n                    decoded.parameterType = \"Join Group\";\n                    decoded.data.delayBetweenIterations = UInt16(bytes[1] &lt;&lt; 8 | bytes[2]);\n                    decoded.data.delayBetweenSequence = UInt16(bytes[3] &lt;&lt; 8 | bytes[4]);\n                    decoded.data.failCountToTriggerLongDelay = bytes[5];\n                    decoded.data.longDelayBetweenSequence = UInt16(bytes[6] &lt;&lt; 8 | bytes[7]);\n\n\n                } break;\n                // Network Test Group Parameter\n                case 23: {\n                    decoded.parameterType = \"Network Test Group\";\n                    decoded.data.interval = UInt16(bytes[1] &lt;&lt; 8 | bytes[2]);\n                    decoded.data.adr = bytes[3];\n                    decoded.data.datarate = bytes[4];\n                    decoded.data.txPower = bytes[5];\n                } break;\n                // Battery Group Parameter\n                case 24: {\n                    decoded.parameterType = \"Battery Group\";\n                    decoded.data.batteryMin = (bytes[1] * 2) / 100;\n                    decoded.data.batteryMax = (bytes[2] * 2) / 100;\n                    decoded.data.batteryType = bytes[3];\n                } break;\n                // No ACK Recovery Group Parameter\n                case 25: {\n                    decoded.parameterType = \"No ACK Recovery Group\";\n                    decoded.data.noAckRecoveryMode = bytes[1];\n                    decoded.data.adrDisabled = bytes[2];\n                    decoded.data.delay = UInt16(bytes[3] &lt;&lt; 8 | bytes[4]);\n                    decoded.data.retryCount = bytes[5];\n                    decoded.data.Retrydelay = UInt16(bytes[6] &lt;&lt; 8 | bytes[7]);\n                } break;\n                // Heartbeat Group Parameter\n                case 26: {\n                    decoded.parameterType = \"Heartbeat Group\";\n                    decoded.data.heartbeatId = bytes[1];\n                    decoded.data.ack = bytes[2];\n                    decoded.data.ackRetryCount = bytes[3];\n                } break;\n                // External Leak ACK Parameter\n                case 27: {\n                    decoded.parameterType = \"External Leak ACK\";\n                    decoded.data.ack = bytes[1];\n                    decoded.data.ackRetryCount = bytes[2];\n                } break;\n                // Pin Leak ACK Parameter\n                case 28: {\n                    decoded.parameterType = \"Pin Leak ACK\";\n                    decoded.data.ack = bytes[1];\n                    decoded.data.ackRetryCount = bytes[2];\n                } break;\n                // Tamper Detection ACK Parameter\n                case 29: {\n                    decoded.parameterType = \"Tamper Detection ACK\";\n                    decoded.data.ack = bytes[1];\n                    decoded.data.ackRetryCount = bytes[2];\n                } break;\n                // Button Press ACK Parameter\n                case 30: {\n                    decoded.parameterType = \"Button Press ACK\";\n                    decoded.data.ack = bytes[1];\n                    decoded.data.ackRetryCount = bytes[2];\n                } break;\n                // Temperature High ACK Parameter\n                case 31: {\n                    decoded.parameterType = \"Temperature High ACK\";\n                    decoded.data.ack = bytes[1];\n                    decoded.data.ackRetryCount = bytes[2];\n                } break;\n                // Temperature Low ACK Parameter\n                case 32: {\n                    decoded.parameterType = \"Temperature Low ACK\";\n                    decoded.data.ack = bytes[1];\n                    decoded.data.ackRetryCount = bytes[2];\n                } break;\n                // Humidity High ACK Parameter\n                case 33: {\n                    decoded.parameterType = \"Humidity High ACK\";\n                    decoded.data.ack = bytes[1];\n                    decoded.data.ackRetryCount = bytes[2];\n                } break;\n                // Humidity Low ACK Parameter\n                case 34: {\n                    decoded.parameterType = \"Humidity Low ACK\";\n                    decoded.data.ack = bytes[1];\n                    decoded.data.ackRetryCount = bytes[2];\n                } break;\n                // Pulse Count ACK Parameter\n                case 35: {\n                    decoded.parameterType = \"Pulse Count ACK\";\n                    decoded.data.ack = bytes[1];\n                    decoded.data.ackRetryCount = bytes[2];\n                } break;\n                // Pulse Count Long Event ACK Parameter\n                case 36: {\n                    decoded.parameterType = \"Pulse Count Long Event ACK\";\n                    decoded.data.ack = bytes[1];\n                    decoded.data.ackRetryCount = bytes[2];\n                } break;\n                // Parameter Uplink ACK Parameter\n                case 37: {\n                    decoded.parameterType = \"Parameter Uplink ACK\";\n                    decoded.data.ack = bytes[1];\n                    decoded.data.ackRetryCount = bytes[2];\n                } break;\n                // Pin Leak Detection Parameter\n                case 38: {\n                    decoded.parameterType = \"Pin Leak Detection\";\n                    decoded.data.enabled = bytes[1];\n                    decoded.data.triggerValue = UInt16(bytes[2] &lt;&lt; 8 | bytes[3]);\n                    decoded.data.triggerDelay = bytes[4];\n                } break;\n                // Pin Leak Detection Buzzer Parameter\n                case 39: {\n                    decoded.parameterType = \"Pin Leak Detection Buzzer\";\n                    decoded.data.enabled = bytes[1];\n                    decoded.data.silenceEnabled = bytes[2];\n                    decoded.data.silenceCounter = UInt16(bytes[3] &lt;&lt; 8 | bytes[4]);\n                    decoded.data.beepCount = bytes[5];\n                    decoded.data.beepDuration = UInt16(bytes[6] &lt;&lt; 8 | bytes[7]);\n\n                } break;\n                // Pin Leak Detection All Parameter\n                case 40: {\n                    decoded.parameterType = \"Pin Leak Detection All\";\n                    decoded.data.pinLeakDetectionEnabled = ((bytes[1] &amp; 0b00000001) &gt; 0);\n                    decoded.data.buzzerEnabled = ((bytes[1] &amp; 0b00000010) &gt; 0);\n                    decoded.data.silenceEnabled = ((bytes[1] &amp; 0b00000100) &gt; 0);\n                    decoded.data.triggerValue = UInt16(bytes[2] &lt;&lt; 8 | bytes[3]);\n                    decoded.data.triggerDelay = bytes[4];\n                    decoded.data.silenceCounter = UInt16(bytes[5] &lt;&lt; 8 | bytes[6]);\n                    decoded.data.beepCount = bytes[7];\n                    decoded.data.beepDuration = UInt16(bytes[8] &lt;&lt; 8 | bytes[9]);\n\n                } break;\n                // External Leak Detection Parameter\n                case 41: {\n                    decoded.parameterType = \"External Leak Detection\";\n                    decoded.data.enabled = bytes[1];\n                    decoded.data.triggerValue = UInt16(bytes[2] &lt;&lt; 8 | bytes[3]);\n                    decoded.data.triggerDelay = bytes[4];\n                } break;\n                // External Leak Detection Buzzer Parameter\n                case 42: {\n                    decoded.parameterType = \"External Leak Detection Buzzer\";\n                    decoded.data.enabled = bytes[1];\n                    decoded.data.silenceEnabled = bytes[2];\n                    decoded.data.silenceCounter = UInt16(bytes[3] &lt;&lt; 8 | bytes[4]);\n                    decoded.data.beepCount = bytes[5];\n                    decoded.data.beepDuration = UInt16(bytes[6] &lt;&lt; 8 | bytes[7]);\n                } break;\n                // External Leak Detection All Parameter\n                case 43: {\n                    decoded.parameterType = \"External Leak Detection All\";\n                    decoded.data.pinLeakDetectionEnabled = ((bytes[1] &amp; 0b00000001) &gt; 0);\n                    decoded.data.buzzerEnabled = ((bytes[1] &amp; 0b00000010) &gt; 0);\n                    decoded.data.silenceEnabled = ((bytes[1] &amp; 0b00000100) &gt; 0);\n                    decoded.data.triggerValue = UInt16(bytes[2] &lt;&lt; 8 | bytes[3]);\n                    decoded.data.triggerDelay = bytes[4];\n                    decoded.data.silenceCounter = UInt16(bytes[5] &lt;&lt; 8 | bytes[6]);\n                    decoded.data.beepCount = bytes[7];\n                    decoded.data.beepDuration = UInt16(bytes[8] &lt;&lt; 8 | bytes[9]);\n                } break;\n                // Tamper Detection Parameter\n                case 44: {\n                    decoded.parameterType = \"Tamper Detection\";\n                    decoded.data.enabled = bytes[1];\n                } break;\n                // Tamper Detection Buzzer Parameter\n                case 45: {\n                    decoded.parameterType = \"Tamper Detection Buzzer\";\n                    decoded.data.enabled = bytes[1];\n                    decoded.data.silenceEnabled = bytes[2];\n                    decoded.data.silenceCounter = UInt16(bytes[3] &lt;&lt; 8 | bytes[4]);\n                    decoded.data.beepCount = bytes[5];\n                    decoded.data.beepDuration = UInt16(bytes[6] &lt;&lt; 8 | bytes[7]);\n                } break;\n                // Tamper Detection All Parameter\n                case 46: {\n                    decoded.parameterType = \"Tamper Detection All\";\n                    decoded.data.enabled = bytes[1];\n                    decoded.data.buzzerEnabled = bytes[2];\n                    decoded.data.silenceEnabled = bytes[3];\n                    decoded.data.silenceCounter = UInt16(bytes[4] &lt;&lt; 8 | bytes[5]);\n                    decoded.data.beepCount = bytes[6];\n                    decoded.data.beepDuration = UInt16(bytes[7] &lt;&lt; 8 | bytes[8]);\n                } break;\n                // Button Pressed Parameter\n                case 47: {\n                    decoded.parameterType = \"Button Pressed\";\n                    decoded.data.enabled = bytes[1];\n                } break;\n                // Temperature High Parameter\n                case 48: {\n                    decoded.parameterType = \"Temperature High\";\n                    decoded.data.enabled = bytes[1];\n                    decoded.data.triggerValue = (Int16(bytes[2] &lt;&lt; 8 | bytes[3])) / 100;\n                    decoded.data.guardbandValue = (Int16(bytes[4] &lt;&lt; 8 | bytes[5])) / 100;\n                    decoded.data.delayCount = bytes[6];\n                } break;\n                // Temperature High Buzzer Parameter\n                case 49: {\n                    decoded.parameterType = \"Temperature High Buzzer\";\n                    decoded.data.enabled = bytes[1];\n                    decoded.data.silenceEnabled = bytes[2];\n                    decoded.data.silenceCounter = UInt16(bytes[3] &lt;&lt; 8 | bytes[4]);\n                    decoded.data.beepCount = bytes[5];\n                    decoded.data.beepDuration = UInt16(bytes[6] &lt;&lt; 8 | bytes[7]);\n                } break;\n                // Temperature High All Parameter\n                case 50: {\n                    decoded.parameterType = \"Temperature High All\";\n                    decoded.data.enabled = ((bytes[1] &amp; 0b00000001) &gt; 0);\n                    decoded.data.buzzerEnabled = ((bytes[1] &amp; 0b00000010) &gt; 0);\n                    decoded.data.silenceEnabled = ((bytes[1] &amp; 0b00000100) &gt; 0);\n                    decoded.data.triggerValue = (Int16(bytes[2] &lt;&lt; 8 | bytes[3])) / 100;\n                    decoded.data.guardbandValue = (Int16(bytes[4] &lt;&lt; 8 | bytes[5])) / 100;\n                    decoded.data.delayCount = bytes[6];\n                    decoded.data.silenceCounter = bytes[7];\n                    decoded.data.beepCount = bytes[8];\n                    decoded.data.beepDuration = UInt16(bytes[9] &lt;&lt; 8 | bytes[10]);\n\n                } break;\n                // Temperature Low Parameter\n                case 51: {\n                    decoded.parameterType = \"Temperature Low\";\n                    decoded.data.enabled = bytes[1];\n                    decoded.data.triggerValue = (Int16(bytes[2] &lt;&lt; 8 | bytes[3])) / 100;\n                    decoded.data.guardbandValue = (Int16(bytes[4] &lt;&lt; 8 | bytes[5])) / 100;\n                    decoded.data.delayCount = bytes[6];\n                } break;\n                // Temperature Low Buzzer Parameter\n                case 52: {\n                    decoded.parameterType = \"Temperature Low Buzzer\";\n                    decoded.data.enabled = bytes[1];\n                    decoded.data.silenceEnabled = bytes[2];\n                    decoded.data.silenceCounter = UInt16(bytes[3] &lt;&lt; 8 | bytes[4]);\n                    decoded.data.beepCount = bytes[5];\n                    decoded.data.beepDuration = UInt16(bytes[6] &lt;&lt; 8 | bytes[7]);\n                } break;\n                // Temperature Low All Parameter\n                case 53: {\n                    decoded.parameterType = \"Temperature Low All\";\n                    decoded.data.enabled = ((bytes[1] &amp; 0b00000001) &gt; 0);\n                    decoded.data.buzzerEnabled = ((bytes[1] &amp; 0b00000010) &gt; 0);\n                    decoded.data.silenceEnabled = ((bytes[1] &amp; 0b00000100) &gt; 0);\n                    decoded.data.triggerValue = (Int16(bytes[2] &lt;&lt; 8 | bytes[3])) / 100;\n                    decoded.data.guardbandValue = (Int16(bytes[4] &lt;&lt; 8 | bytes[5])) / 100;\n                    decoded.data.delayCount = bytes[6];\n                    decoded.data.silenceCounter = bytes[7];\n                    decoded.data.beepCount = bytes[8];\n                    decoded.data.beepDuration = UInt16(bytes[9] &lt;&lt; 8 | bytes[10]);\n                } break;\n                // Humidity High Parameter\n                case 54: {\n                    decoded.parameterType = \"Humidity High\";\n                    decoded.data.enabled = bytes[1];\n                    decoded.data.triggerValue = (Int16(bytes[2] &lt;&lt; 8 | bytes[3])) / 100;\n                    decoded.data.guardbandValue = (Int16(bytes[4] &lt;&lt; 8 | bytes[5])) / 100;\n                    decoded.data.delayCount = bytes[6];\n                } break;\n                // Humidity High Buzzer Parameter\n                case 55: {\n                    decoded.parameterType = \"Humidity High Buzzer\";\n                    decoded.data.enabled = bytes[1];\n                    decoded.data.silenceEnabled = bytes[2];\n                    decoded.data.silenceCounter = UInt16(bytes[3] &lt;&lt; 8 | bytes[4]);\n                    decoded.data.beepCount = bytes[5];\n                    decoded.data.beepDuration = UInt16(bytes[6] &lt;&lt; 8 | bytes[7]);\n                } break;\n                // Humidity High All Parameter\n                case 56: {\n                    decoded.parameterType = \"Humidity High All\";\n                    decoded.data.enabled = ((bytes[1] &amp; 0b00000001) &gt; 0);\n                    decoded.data.buzzerEnabled = ((bytes[1] &amp; 0b00000010) &gt; 0);\n                    decoded.data.silenceEnabled = ((bytes[1] &amp; 0b00000100) &gt; 0);\n                    decoded.data.triggerValue = (Int16(bytes[2] &lt;&lt; 8 | bytes[3])) / 100;\n                    decoded.data.guardbandValue = (Int16(bytes[4] &lt;&lt; 8 | bytes[5])) / 100;\n                    decoded.data.delayCount = bytes[6];\n                    decoded.data.silenceCounter = bytes[7];\n                    decoded.data.beepCount = bytes[8];\n                    decoded.data.beepDuration = UInt16(bytes[9] &lt;&lt; 8 | bytes[10]);\n                } break;\n                // Humidity Low Parameter\n                case 57: {\n                    decoded.parameterType = \"Humidity Low\";\n                    decoded.data.enabled = bytes[1];\n                    decoded.data.triggerValue = (Int16(bytes[2] &lt;&lt; 8 | bytes[3])) / 100;\n                    decoded.data.guardbandValue = (Int16(bytes[4] &lt;&lt; 8 | bytes[5])) / 100;\n                    decoded.data.delayCount = bytes[6];\n                } break;\n                // Humidity Low Buzzer Parameter\n                case 58: {\n                    decoded.parameterType = \"Humidity Low Buzzer\";\n                    decoded.data.enabled = bytes[1];\n                    decoded.data.silenceEnabled = bytes[2];\n                    decoded.data.silenceCounter = UInt16(bytes[3] &lt;&lt; 8 | bytes[4]);\n                    decoded.data.beepCount = bytes[5];\n                    decoded.data.beepDuration = UInt16(bytes[6] &lt;&lt; 8 | bytes[7]);\n                } break;\n                // Humidity Low All Parameter\n                case 59: {\n                    decoded.parameterType = \"Humidity Low All\";\n                    decoded.data.enabled = ((bytes[1] &amp; 0b00000001) &gt; 0);\n                    decoded.data.buzzerEnabled = ((bytes[1] &amp; 0b00000010) &gt; 0);\n                    decoded.data.silenceEnabled = ((bytes[1] &amp; 0b00000100) &gt; 0);\n                    decoded.data.triggerValue = (Int16(bytes[2] &lt;&lt; 8 | bytes[3])) / 100;\n                    decoded.data.guardbandValue = (Int16(bytes[4] &lt;&lt; 8 | bytes[5])) / 100;\n                    decoded.data.delayCount = bytes[6];\n                    decoded.data.silenceCounter = bytes[7];\n                    decoded.data.beepCount = bytes[8];\n                    decoded.data.beepDuration = UInt16(bytes[9] &lt;&lt; 8 | bytes[10]);\n                } break;\n                // Temperature Offset Parameter\n                case 60: {\n                    decoded.parameterType = \"Temperature Offset\";\n                    decoded.data.offset = (Int16(bytes[1] &lt;&lt; 8 | bytes[2])) / 100;\n                } break;\n                // Humidity Offset Parameter\n                case 61: {\n                    decoded.parameterType = \"Humidity Offset\";\n                    decoded.data.offset = (Int16(bytes[1] &lt;&lt; 8 | bytes[2])) / 100;\n                } break;\n                // Sense Interval Parameter\n                case 62: {\n                    decoded.parameterType = \"Sense Interval\";\n                    decoded.data.interval = UInt16(bytes[1] &lt;&lt; 8 | bytes[2]);\n                } break;\n                // Pulse Counting Parameter\n                case 63: {\n                    decoded.parameterType = \"Pulse Counting\";\n                    decoded.data.enabled = bytes[1];\n                    decoded.data.deviceTypeId = bytes[2];\n                    decoded.data.reportingInterval = UInt16(bytes[3] &lt;&lt; 8 | bytes[4]);\n                    decoded.data.eventDelayValue = UInt16(bytes[5] &lt;&lt; 8 | bytes[6]);\n\n                } break;\n                // Pulse Counting Long Event Parameter\n                case 64: {\n                    decoded.parameterType = \"Pulse Counting Long Event\";\n                    decoded.data.enabled = bytes[1];\n                    decoded.data.eventLongDelayValue = UInt16(bytes[2] &lt;&lt; 8 | bytes[3]);\n                } break;\n                case 65: {\n                    decoded.parameterType = \"Jack Detected Event ACK\";\n                    decoded.data.ack = bytes[1];\n                    decoded.data.ackRetryCount = bytes[2];\n                } break;\n                case 66: {\n                    decoded.parameterType = \"Jack Detected Event\";\n                    decoded.data.enabled = bytes[1];\n                    decoded.data.delayCount = bytes[2];\n                } break;\n                case 67: {\n                    decoded.parameterType = \"Jack Detected Buzzer\";\n                    decoded.data.enabled = bytes[1];\n                    decoded.data.silenceEnabled = bytes[2];\n                    decoded.data.silenceCounter = UInt16(bytes[3] &lt;&lt; 8 | bytes[4]);\n                    decoded.data.beepCount = bytes[5];\n                    decoded.data.beepDuration = UInt16(bytes[6] &lt;&lt; 8 | bytes[7]);\n                } break;\n                case 68: {\n                    decoded.parameterType = \"Jack Detected All\";\n                    decoded.data.enabled = bytes[1];\n                    decoded.data.delayCount = bytes[2];\n                    decoded.data.buzzerEnabled = bytes[3];\n                    decoded.data.silenceEnabled = bytes[4];\n                    decoded.data.silenceCounter = UInt16(bytes[5] &lt;&lt; 8 | bytes[6]);\n                    decoded.data.beepCount = bytes[7];\n                    decoded.data.beepDuration = UInt16(bytes[8] &lt;&lt; 8 | bytes[9]);\n                } break;\n                case 69: {\n                    decoded.parameterType = \"Buzzer Disabled\";\n                    decoded.data.disabled = bytes[1];\n                } break;\n            }\n\n\n        } break;\n        default:\n            decoded.unknown = \"Unknown data format\";\n            break;\n    }\n    return decoded;\n}\n\n// For TTN\nfunction Decoder(bytes, fPort) {\n    return DoDecode(fPort, bytes);\n}\n\n// For Chirpstack\nfunction Decode(fPort, bytes, variables) {\n    return DoDecode(fPort, bytes);\n}\n\n// Chirpstack v3 to v4 compatibility wrapper\nfunction decodeUplink(input) {\n    return {\n        data: Decode(input.fPort, input.bytes, input.variables)\n    };\n}\n\nvar UInt4 = function (value) {\n    return (value &amp; 0xF);\n};\n\nvar Int4 = function (value) {\n    var ref = UInt4(value);\n    return (ref &gt; 0x7) ? ref - 0x10 : ref;\n};\n\nvar UInt8 = function (value) {\n    return (value &amp; 0xFF);\n};\n\nvar Int8 = function (value) {\n    var ref = UInt8(value);\n    return (ref &gt; 0x7F) ? ref - 0x100 : ref;\n};\n\nvar UInt16 = function (value) {\n    return (value &amp; 0xFFFF);\n};\n\nvar Int16 = function (value) {\n    var ref = UInt16(value);\n    return (ref &gt; 0x7FFF) ? ref - 0x10000 : ref;\n};\n</code></pre>"},{"location":"#_1","title":"Home","text":""},{"location":"#lambdas-for-example","title":"Lambdas for example","text":""},{"location":"#lambda-functions","title":"Lambda Functions","text":"<p>The Lambda functions are the core of the system. They handle all calculations and business logic decisions.</p>"},{"location":"#lambda-function-process_iqsl","title":"Lambda Function: <code>Process_iqsl</code>","text":""},{"location":"#purpose","title":"Purpose","text":"<p>Only for Water Leak Devices of type IQSL. Doesn't include Toilet Sensors</p>"},{"location":"#main-operations-and-algorithms","title":"Main Operations and Algorithms:","text":"<ul> <li> <p>Temperature: from Celcius to Fahrenheit</p> </li> <li> <p>Saves all connected gateways in a list and saves it in the database.</p> </li> <li> <p>Saves data in the iqwl_data table and updates the latest data in the devices_last_data table.</p> </li> </ul> <p>Note: Alerts are not sent by this Lambda. This Lambda sends data to another Lambda (SendAlertNotification) and that one will decide whether to send an alert.</p>"},{"location":"#input-source","title":"Input Source","text":"<p>Receives messages from the following SQS queue: <code>iqsl_uplink_queue</code></p>"},{"location":"#output-destinations","title":"Output Destinations","text":"<ul> <li>Sends data to Lambda: <code>SendAlertNotification</code></li> <li>Stores data in the following tables:</li> <li><code>devices_details</code></li> <li><code>iqsl_data</code></li> <li><code>devices_last_data</code></li> </ul>"},{"location":"#input-format-json","title":"Input Format (JSON)","text":"<pre><code>{\n    \"device_id\": \"123\",\n    \"application_id\": \"app1\",\n    \"dev_eui\": \"1234\",\n    \"read_time\": \"2025-07-02T19:16:38.982846975Z\",\n    \"payload_type\": \"Heartbeat\",\n    \"payload_type_id\": 1,\n    \"battery_percentage\": 38,\n    \"battery_voltage\": 3.16,\n    \"external_leak_detection_enabled\": true,\n    \"pin_leak_detection_enabled\": true,\n    \"tamper_detection_enabled\": true,\n    \"humidity\": 54.2,\n    \"last_rssi\": -42,\n    \"last_snr\": 13,\n    \"external_leak_detected\": false,\n    \"jack_detected\": false,\n    \"magnet_detected\": false,\n    \"pin_leak_detected\": false,\n    \"power_detected\": false,\n    \"state_as_uint8\": 7,\n    \"temperature\": 24.33,\n    \"frame_count\": 2677,\n    \"metadata\": [\n        {\n            \"gateway_ids\": {\n                \"gateway_id\": \"eui-58a0cbfffe8040c1\",\n                \"eui\": \"58A0CBFFFE8040C1\"\n            },\n            \"time\": \"2025-07-02T19:16:38.982846975Z\",\n            \"timestamp\": 2143403483,\n            \"rssi\": -63,\n            \"channel_rssi\": -63,\n            \"snr\": 9.25,\n            \"uplink_token\": \"CiIKIAoUZXVpLTU4YTBjYmZmZmU4MDQwYzESCFigy//+gEDBENv7hv4HGgwIl4uWwwYQyZ28jAEg+L625rA+\",\n            \"received_at\": \"2025-07-02T19:16:39.241239981Z\"\n        },\n        {\n            \"gateway_ids\": {\n                \"gateway_id\": \"iqgw-tk-20\",\n                \"eui\": \"647FDAFFFE01F36D\"\n            },\n            \"timestamp\": 1245444315,\n            \"rssi\": -78,\n            \"channel_rssi\": -78,\n            \"snr\": 9.5,\n            \"uplink_token\": \"ChgKFgoKaXFndy10ay0yMBIIZH/a//4B820Q2/Hv0QQaDAiXi5bDBhCLqciXASD4rpDSn+UU\",\n            \"received_at\": \"2025-07-02T19:16:39.125916168Z\"\n        }\n    ]\n}\n</code></pre>"},{"location":"#lambda-function-process_long_flush_iqsl","title":"Lambda Function: <code>Process_long_flush_iqsl</code>","text":""},{"location":"#purpose_1","title":"Purpose","text":"<p>Only for Toilet Sensor Devices from type IQSL filtered by the uplinks of type LONG_FLUSH (payload_type_id = 10).</p>"},{"location":"#main-operations-and-algorithms_1","title":"Main Operations and Algorithms:","text":""},{"location":"#how-does-long-flush-work","title":"How Does Long Flush Work?","text":"<p>The device only sends the uplink after 3 minutes (default) of continuous flushing. In other words, when the uplink is received, the flushing has already been occurring for 3 minutes. Because of that, the Lambda must register that the flush started 3 minutes earlier.</p>"},{"location":"#end-of-flush","title":"End of Flush","text":"<p>When a flush ends, a different type of uplink is sent: Last Event Water Usage (<code>payload_type_id = 11</code>). However, this uplink is processed by another Lambda: <code>Process_water_usage_iqsl</code>.</p>"},{"location":"#custom-long-flush-duration","title":"Custom Long Flush Duration","text":"<p>The user can request the device to register a flush only after 4 or more minutes. In this case:</p> <ol> <li>An external API (not the Lambda) stores on the device the setting that long flush should be recorded after 4+ minutes.</li> <li>The Lambda checks the device settings in the database.</li> <li>Based on the setting:</li> <li>If it's set to 3 minutes (default):      The long flush is recorded normally.</li> <li>If it's set to more than 3 minutes (late long flush): <ul> <li>The long flush is saved to the database.  </li> <li>The property <code>long_event_hide_on_dashboard</code> is set to <code>False</code>, so it won't appear on the Dashboard.  </li> <li>A schedule is created in EventBridge to trigger the long flush later via the <code>LateLongFlush</code> Lambda.</li> </ul> </li> </ol>"},{"location":"#notes","title":"Notes","text":"<ul> <li> <p>There is no information about gallons used in the flush in this uplink.   This data will arrive in a separate uplink of type Last Event Water Usage (<code>payload_type_id = 11</code>).</p> </li> <li> <p>The device is renamed with a <code>-flow</code> suffix to distinguish Toilet Sensor data from Leak Sensor data,   since IQSL includes both sensor types in the same transmitter.</p> </li> </ul>"},{"location":"#input-source_1","title":"Input Source","text":"<p>Receives messages from the following SQS queue: <code>iqsl_long_flush_uplink_queue</code></p>"},{"location":"#output-destinations_1","title":"Output Destinations","text":"<ul> <li>Sends data to Lambda: <code>SendAlertToiletNotification</code>, <code>LateLongFlush</code></li> <li>Stores data in the following tables:</li> <li><code>devices_details</code></li> <li><code>iqsl_alerts_data</code></li> <li><code>devices_last_data</code></li> </ul>"},{"location":"#input-format-json_1","title":"Input Format (JSON)","text":"<pre><code>{\n    \"device_id\": \"123\",\n    \"application_id\": \"app2\",\n    \"dev_eui\": \"1234\",\n    \"read_time\": \"2025-07-02T19:11:57.283046007Z\",\n    \"payload_type\": \"Alert\",\n    \"payload_type_id\": 10,\n    \"alert_type\": \"Pulse Counting (Long Event Alert)\",\n    \"current_status\": 1,\n    \"pulse_duration_trigger\": 180000,\n    \"frame_count\": 3642\n}\n</code></pre>"},{"location":"#lambda-function-process_water_usage_iqsl","title":"Lambda Function: <code>Process_water_usage_iqsl</code>","text":""},{"location":"#purpose_2","title":"Purpose","text":"<p>Only for Toilet Sensor Devices from type IQSL filtered by the uplinks of type WATER_USAGE (payload_type_id = 11).</p>"},{"location":"#main-operations-and-algorithms_2","title":"Main Operations and Algorithms:","text":""},{"location":"#how-does-water-usage-work","title":"How Does Water Usage Work?","text":"<p>Gallons_spent = Pulse_total_pulses * 0.264172</p> <p>Water usage can occur after a normal flush or after a Long Flush.</p> <p>If it is after a normal flush, then it simply records in the database that a flush occurred without needing to calculate when the flush started. However, there can be two types:</p> <ul> <li>Above 1 gallon: \"normal flush\"</li> <li>Equal to or less than 1 gallon: \"escape\" (value too low to be a real flush)</li> </ul> <p>If it is after a Long Flush, then:</p> <ul> <li>If the Long Flush has already been registered, then this Water Usage must be recorded at the moment the Long Flush started. The type of this flush must be \"long\".</li> <li>If the Long Flush has not yet been registered on the dashboard [see late long flush], then the Long Flush should not appear on the dashboard. Instead, it should appear as a normal flush, without the need to calculate when the flush started.</li> </ul>"},{"location":"#input-source_2","title":"Input Source","text":"<p>Receives messages from the following SQS queue: <code>iqsl_water_usage_uplink_queue</code></p>"},{"location":"#output-destinations_2","title":"Output Destinations","text":"<ul> <li>Sends data to Lambda: <code>SendAlertToiletNotification</code></li> <li>Stores data in the following tables:</li> <li><code>devices_details</code></li> <li><code>iqsl_alerts_data</code></li> <li><code>devices_last_data</code></li> </ul>"},{"location":"#input-format-json_2","title":"Input Format (JSON)","text":"<pre><code>{\n    \"device_id\": \"123\",\n    \"application_id\": \"app1\",\n    \"dev_eui\": \"1234\",\n    \"read_time\": \"2025-07-02T20:13:31.984311103Z\",\n    \"payload_type\": \"Alert\",\n    \"payload_type_id\": 11,\n    \"alert_type\": \"Pulse Counting Event (Last Event Usage)\",\n    \"humidity\": 54.33,\n    \"temperature\": 23.64,\n    \"pulse_device_type_id\": 1,\n    \"pulse_total_pulses\": 2902,\n    \"pulse_total_liters\": 2.694521819870009,\n    \"frame_count\": 24465\n}\n</code></pre>"},{"location":"#lambda-function-process_toilet_heartbeat_iqsl","title":"Lambda Function: <code>Process_toilet_heartbeat_iqsl</code>","text":""},{"location":"#purpose_3","title":"Purpose","text":"<p>Only for Toilet Sensor Devices from Type IQSL filtered by the uplinks of type HEARTBEAT (payload_type_id = 9).</p>"},{"location":"#main-operations-and-algorithms_3","title":"Main Operations and Algorithms:","text":""},{"location":"#how-does-the-heartbeat-work","title":"How Does the Heartbeat Work?","text":"<p>The heartbeat shows what has occurred since the last heartbeat:</p> <ul> <li>Number of flushes  </li> <li>Gallons spent  </li> </ul> <p>Note: If a long flush is currently happening and has not yet finished, and a heartbeat is sent, then the gallons spent during this ongoing long flush are pre-calculated.</p>"},{"location":"#input-source_3","title":"Input Source","text":"<p>Receives messages from the following SQS queue: <code>IQWLWaterLeakUplinkQueue</code></p>"},{"location":"#output-destinations_3","title":"Output Destinations","text":"<ul> <li>Sends data to Lambda: <code>iqsl_toilet_heartbeat_uplink_queue</code></li> <li>Stores data in the following tables:</li> <li><code>devices_details</code></li> <li><code>iqsl_alerts_data</code></li> <li><code>devices_last_data</code></li> </ul>"},{"location":"#input-format-json_3","title":"Input Format (JSON)","text":"<pre><code>{\n    \"device_id\": \"123\",\n    \"application_id\": \"app1\",\n    \"dev_eui\": \"1234\",\n    \"read_time\": \"2025-07-02T20:18:57.869425058Z\",\n    \"payload_type\": \"Alert\",\n    \"payload_type_id\": 9,\n    \"alert_type\": \"Pulse Counting (Total Events)\",\n    \"pulse_long_event_triggered\": 0,\n    \"pulse_alert_interval\": 500,\n    \"pulse_device_type_id\": 1,\n    \"pulse_total_events\": 11,\n    \"pulse_total_pulses\": 11,\n    \"pulse_total_liters\": 0.01021355617455896,\n    \"frame_count\": 325\n}\n</code></pre>"},{"location":"#lambda-function-process_alerts_iqsl","title":"Lambda Function: <code>Process_alerts_iqsl</code>","text":""},{"location":"#purpose_4","title":"Purpose","text":"<p>Only for Leak Sensor and Toilet Sensor Devices of type IQSL filtered by the uplinks of payload_type_id = 1,2,3,4,5,6,7,8 and 12.</p>"},{"location":"#main-operations-and-algorithms_4","title":"Main Operations and Algorithms:","text":""},{"location":"#processing-based-on-payload_type_id","title":"Processing Based on <code>payload_type_id</code>","text":"<p>Depending on the <code>payload_type_id</code>, the processing is different:</p> <ul> <li> <p>payload_type_id = 1 \u2192 Leak Detected External (LEAK SENSOR)   Saves the event and calls the Lambda SendAlertNotification to send an alert.</p> </li> <li> <p>payload_type_id = 2 \u2192 Leak Detected Local (LEAK SENSOR)   Saves the event and calls the Lambda SendAlertNotification to send an alert.</p> </li> <li> <p>payload_type_id = 3 \u2192 Tamper (LEAK SENSOR)   Saves the event. This uplink is sent when the device comes into contact with the magnet (not actual movement).</p> </li> <li> <p>payload_type_id = 4 \u2192 Button Pressed (LEAK SENSOR)   Saves the event.</p> </li> <li> <p>payload_type_id = 5 \u2192 High Temperature (LEAK SENSOR)   Saves the event and calls the Lambda SendAlertNotification to send an alert.</p> </li> <li> <p>payload_type_id = 6 \u2192 Low Temperature (LEAK SENSOR)   Saves the event and calls the Lambda SendAlertNotification to send an alert.</p> </li> <li> <p>payload_type_id = 7 \u2192 High Humidity (LEAK SENSOR)   Saves the event and calls the Lambda SendAlertNotification to send an alert.</p> </li> <li> <p>payload_type_id = 8 \u2192 Low Humidity (LEAK SENSOR)   Saves the event and calls the Lambda SendAlertNotification to send an alert.</p> </li> <li> <p>payload_type_id = 12 \u2192 Headphone Jack Alert (LEAK SENSOR)   Saves the event.</p> </li> </ul>"},{"location":"#input-source_4","title":"Input Source","text":"<p>Receives messages from the following SQS queue: <code>iqsl_alerts_uplink_queue</code></p>"},{"location":"#output-destinations_4","title":"Output Destinations","text":"<ul> <li>Sends data to Lambda: <code>SendAlertNotification</code>, <code>SendAlertToiletNotification</code></li> <li>Stores data in the following tables:</li> <li><code>devices_details</code></li> <li><code>iqsl_data</code></li> <li><code>iqsl_alerts_data</code></li> <li><code>devices_last_data</code></li> </ul>"},{"location":"#input-format-json-example-only-for-payload_type_id-2","title":"Input Format (JSON) - example only for payload_type_id = 2","text":"<pre><code>{\n    \"device_id\": \"123\",\n    \"application_id\": \"app4\",\n    \"dev_eui\": \"1234\",\n    \"read_time\": \"2025-07-02T18:46:19.129642963Z\",\n    \"payload_type\": \"Alert\",\n    \"payload_type_id\": 2,\n    \"alert_type\": \"Local Leak Detection (Via Bottom Contact Pins)\",\n    \"current_status\": 0,\n    \"current_value\": 3044,\n    \"humidity\": 49.23,\n    \"temperature\": 23.68,\n    \"delay_count\": 1,\n    \"trigger_value\": 5000,\n    \"frame_count\": 2789\n}\n</code></pre>"},{"location":"#downlinks","title":"Downlinks","text":"<p>Tip: use this site to facilitate the convert from base to hex base64-to-hex</p>"},{"location":"#working-on","title":"Working on...","text":"<p>Downlinks IQSV (Smart Valve devices) IQWM (Water meters devices)</p>"},{"location":"architecture/","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"architecture/#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live- docs server.</li> <li><code>mkdocs build</code> - Build the documreloadingentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"architecture/#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"}]}