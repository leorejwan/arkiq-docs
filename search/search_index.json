{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"arkIQ System Documentation","text":""},{"location":"#ttn-to-aws","title":"TTN to AWS","text":"<ol> <li> <p>Uplink sent from TTN to AWS</p> </li> <li> <p>AWS IoT Core receives the uplinks.    A separate IoT Core Rule is defined for each device type, extracting the necessary information from each uplink.</p> </li> <li> <p>The extracted data is sent to a dedicated queue for each device type.</p> </li> <li> <p>Each queue triggers a separate Lambda function, which processes the received data and follows a distinct path depending on the device.</p> </li> <li> <p>Alerts If necessary, alerts are sent via email and SMS.</p> </li> <li> <p>Database Storage Processed data is stored in the database.</p> </li> </ol> <p>From now on (September, 2025) the new devices should be onboarded on AWS IoT Core</p>"},{"location":"#device-types","title":"Device Types:","text":"<p>arkIQ has different types of devices</p> <p>1- IQWL: Leak Sensor 2- IQSL: Leak Sensor + Toilet Sensor 3- IQWM: Water Meter 4- IQSV: Smart Valve  </p>"},{"location":"#iqwl","title":"IQWL","text":"<p>Attributes: Water Leak Detected: boolean Tamper Detected: boolean Button Pressed: boolean Temperature (Celsius): decimal Humidity (%): decimal Battery (V): decimal  </p> <p>Payload:</p> <p>Bytes: 00 08 d2 00 3e</p> <p>Criptographic: AAjSAD4=</p> <p>Decoded:</p> <pre><code>{\n  \"battery_volt\": 2.9,\n  \"button\": 0,\n  \"humi\": 62,\n  \"tamper\": 0,\n  \"temperature\": 21,\n  \"water\": 0\n}\n</code></pre> <p>Payload Formatter (TTN):</p> <pre><code>function hex2bin(hex){\n  return (parseInt(hex, 16).toString(2)).padStart(8, '0');\n}\n\n\n//IQWL sensor\nfunction decodeUplink(input) {\n    let fPort = input.fPort;\n    let payloadlens = input.bytes.length;\n    if(fPort==126 &amp;&amp; payloadlens==5){\n        let intput_list = input.bytes;\n        let battery_int=intput_list[1];// battery calculate\n        battery_volt = (21+battery_int)/10;\n        temperature_hex= (intput_list[3].toString(16).padStart(2, '0'))+(intput_list[2].toString(16).padStart(2, '0'));  //temperature calculate\n        if((parseInt(temperature_hex, 16))&gt;1250){\n            temperature = ((parseInt(temperature_hex, 16))-65536)/10;\n        }\n        else{\n            temperature = (parseInt(temperature_hex, 16))/10;\n        }\n\n        humi =  intput_list[4]; //Humidity calculate\n        let water_hex = intput_list[0].toString(16).padStart(2, '0'); // Sensor Status calculate\n        let water_binary = hex2bin(water_hex); \n        let water_st = water_binary.substring(7, 8); \n        let button_st = water_binary.substring(6, 7); \n        let tamper_st = water_binary.substring(5, 6); \n\n        water = parseInt(water_st); // water status\n        button = parseInt(button_st); // Button pressed\n        tamper = parseInt(tamper_st); // Tamper detected\n\n        return {\n        data: {\n        battery_volt,\n        temperature,\n        humi,\n        water,\n        button,\n        tamper\n        },\n        };\n    }\n    else if (fPort==126 &amp;&amp; payloadlens==4){\n        let intput_list = input.bytes;\n        let battery_int=intput_list[1];// battery calculate\n        battery_volt = (21+battery_int)/10;\n        temperature_int= intput_list[2]; //temperature calculate\n        if(temperature_int&gt;125){\n            temperature = temperature_int-256;\n        }\n        else{\n            temperature = temperature_int;\n        }\n        humi =  intput_list[3]; //Humidity calculate\n\n\n        let water_hex = intput_list[0].toString(16).padStart(2, '0'); // Sensor Status calculate\n        let water_binary = hex2bin(water_hex); \n        let water_st = water_binary.substring(7, 8); \n        let button_st = water_binary.substring(6, 7); \n        let tamper_st = water_binary.substring(5, 6); \n\n\n        water = parseInt(water_st); // water status\n        button = parseInt(button_st); // Button pressed\n        tamper = parseInt(tamper_st); // Tamper detected\n\n\n        return {\n        data: {\n        battery_volt,\n        temperature,\n        humi,\n        water,\n        button,\n        tamper\n        },\n        };\n    }\n    //Fireware Info\n    else if (fPort==204 &amp;&amp; payloadlens==9){\n    let message = 'This is fireware info.';\n    byteArray = input.bytes;\n    let payload = byteArray.map(byte =&gt; byte.toString(16).padStart(2, '0')).join('');\n    return {\n      data: {\n              fPort,\n                message,\n                payload\n              },\n            };\n    }\n    //Configuration Info\n    else if (fPort==204 &amp;&amp; payloadlens==11){\n    let message = 'This is configuration info.';\n    byteArray = input.bytes;\n    let payload = byteArray.map(byte =&gt; byte.toString(16).padStart(2, '0')).join('');\n    return {\n      data: {\n              fPort,\n                message,\n                payload\n              },\n            };\n    }\n    else{\n            let fPort = input.fPort;\n            let payloadlength = input.bytes.length;\n            let message = 'Invalid fPort or payload length';\n            return {\n              data: {\n                fPort,\n                payloadlength,\n                message,\n              },\n            };\n    }\n}\n</code></pre>"},{"location":"#iqwl-dual-chip","title":"IQWL Dual Chip","text":"<p>Some IQWL has dual chip: 1. LoRaWAN 2. Amazon Sidewalk  </p> <p>By default, when it's turned ON, it will try to connect to LoRaWAN.  </p> <p>If after 3 attempts, it doesn't connect to LoRaWAN, it will connect to Amazon Sidewalk.  </p>"},{"location":"#what-are-the-difference-between-iqwl-chip-lorawan-and-iqwl-chip-sidewalk","title":"What are the difference between IQWL chip LoRaWAN and IQWL chip Sidewalk","text":"<ul> <li>LoRaWAN needs to be connected to a network and be cover by a LoRaWAN gateway. Sidewalk doesn't need Gateways.</li> <li>Sidewalk uses the devices from Amazon to spread the connection</li> <li>Sidewalk nowadays (year 2025) only work in United States, but soon it will be active to other countries as well (coverage.sidewalk.amazon)</li> </ul> <p>In September 2025, the Sidewalk devices are not in arkIQ cloud. It's in another cloud. The uplinks are forwarded via a Lambda that is connected to an AWS IoT Core Rule from the other AWS Account. We are working on it to bring all the Sidewalk chips to our cloud</p> <p>The Lambda that receives the messages from Amazon Sidewalk is called ReceiveUplinkBrowanSidewalkLambda. This is the payload structure of every payload:</p> <pre><code>{\n    \"MessageId\": \"48a0c3cb-7dc6-4e03-b738-9f3565808bd0\",\n    \"WirelessDeviceId\": \"cda427e6-1f7c-45bb-aeb2-7324852a191f\",\n    \"PayloadData\": \"N2UwMDBmY2YwMDQw\",\n    \"WirelessMetadata\": {\n        \"Sidewalk\": {\n            \"CmdExStatus\": \"COMMAND_EXEC_STATUS_UNSPECIFIED\",\n            \"MessageType\": \"CUSTOM_COMMAND_ID_NOTIFY\",\n            \"NackExStatus\": [],\n            \"Seq\": 20,\n            \"SidewalkId\": \"B659A2463A\",\n            \"Timestamp\": \"2025-09-22T14: 47: 18.911Z\"\n        }\n    }\n}\n</code></pre> <p>This payoload doesn't contain the DEVEUI or the Serial Number of the device. Rather, it contains the WirelessDeviceId To assign which device is related to this particular uplink, the WirelessDeviceId need to be used.  There is a table in the database that contains the serial-number WirelessDeviceId relationship: iqwl_sidewalk_deviceid_connector </p> <p>In the future, when all Amazon Sidewalk chips will be onboarded on our cloud, then we'll implement a more efficient and less manual way to assign the devices with the uplinks.</p>"},{"location":"#iqsl","title":"IQSL","text":"<p>This device is in the same time a Leak Sensor and a Transmitter:  </p> <ol> <li> <p>Leak Sensor: detects leak using its probs (Similar to IQWL devices).  </p> </li> <li> <p>Transmitter: it's possible to connect a headphone jack wth two functionalities:  </p> </li> <li> <p>Extends Leak Sensor capacity. Another device can be connected to the IQSL that detects Water Leaks. So, using the Headphone Jack, the other device will let the IQSL know that there is an external Leak. Attribute externalLeakDetectionEnabled = TRUE to extend the Leak Detection to the headphone jack. Attribute externalLeakDetected = TRUE if the extensor detects leak. </p> </li> <li> <p>Connect a Toilet Sensor. The Toilet Sensor is a device that can be connected directly on a Toilet Pipe and it will give information about flushes and water usage. It can be connected using the Headphone Jack and will send toilet information to the transmitter. attribute externalLeakDetected = FALSE to make Toilet Sensor works. </p> </li> </ol> <p>The platform need to show if the IQSL is connected to a Leak Sensor, or to a Toilet Sensor, or if there's no headphone jack connected </p> <p>1- Heartbeat Packet (fPort = 0x01) Attributes: Battery Voltage (V) batteryPercentage (%) Temperature (Celsius) Humidity (%) pinLeakDetectionEnabled: boolean (default: true) * externalLeakDetectionEnabled: boolean (TRUE to work the Leak Sensor extensor. FALSE to work the Toilet Sensor) tamperDetectionEnabled: boolean pinLeakDetected: boolean (if it's occuring a leak right now) externalLeakDetected: boolean (if Toilet Sensor connected, then always FALSE) powerDetected: boolean (No idea what is this) jackDetected: boolean (True, if connected to a Toilet Sensor) magnetDetected: boolean (Tamper detection using a magnet) Water Leak Detected: boolean Tamper Detected: boolean Button Pressed: boolean Temperature (Celsius): decimal Humidity (%): decimal </p> <p>Payload:</p> <p>Bytes: 01B06408D614720BFFB405</p> <p>Criptographic: AbBkCNYUcgv/tAU=</p> <p>Decoded:</p> <pre><code>        \"data\": {\n          \"batteryPercentage\": 100,\n          \"batteryVoltage\": 3.52,\n          \"enabledAlerts\": {\n            \"externalLeakDetectionEnabled\": false,\n            \"pinLeakDetectionEnabled\": true,\n            \"tamperDetectionEnabled\": true\n          },\n          \"humidity\": 52.34,\n          \"lastRssi\": -76,\n          \"lastSnr\": 11,\n          \"state\": {\n            \"externalLeakDetected\": false,\n            \"jackDetected\": false,\n            \"magnetDetected\": false,\n            \"pinLeakDetected\": false,\n            \"powerDetected\": false\n          },\n          \"stateAsUint8\": 5,\n          \"temperature\": 22.62\n        },\n        \"payloadType\": \"Heartbeat\",\n        \"payloadTypeId\": 1\n</code></pre> <p>2- Alert Packets (fPort = 0x02) Triggered when a specific event occurs. The first byte (bytes[0]) defines the alert type:  </p> <p>Case 1: External Leak (via headphone jack) - not applied, because the Toilet Sensor will be connected to the headphone Jack, not a Leak Sensor Extensor. Attributes: triggerValue: (No idea what is it) * currentValue: int (how moisture is it. Can define the level to consider it a leak detected) * temperature  * humidity  * delayCount (No idea what is it) * currentState: boolean* (true = leak detected. false = leak cleared) </p> <p>(IMPORTANT) Case 2: Local Leak (via bottom contact pins) Only activate if the attribute pinLeakDetectionEnabled = true Attributes: triggerValue: (No idea what is it) currentValue: int (how moisture is it. Can define the level to consider it a leak detected) temperature  humidity  delayCount (No idea what is it) currentState: boolean (true = leak detected. false = leak cleared) </p> <p>Case 3: Tamper (magnet detected) - Activate when the magnet touch the device, simulating a tamper. Only activate if the attribute tamperDetectionEnabled = true</p> <p>Case 4: Push button pressed - Activated when button is pressed</p> <p>Case 5: Temperature High. Defined by downlink th hreshold Case 6: Temperature Low. Case 7: Humidity High. Case 8: Humidity Low.   From 5 to 8: Each includes current value, trigger threshold, guardband (safety margin), delay, and state.</p> <p>(IMPORTANT) Case 9: Total Events (cumulative counter): Toilet Sensor Heartbeat Attributes: longEventTriggered: boolean (is it occuring a Long Flush right now? True = yes. False = No) alertInterval (no Idea what is it) deviceTypeId (no Idea what is it) totalEvents: int (How many flushes occured since the last heartbeat) totalLiters: decimal (How many litters were spent since the last heartbeat) -&gt; Convert to Gallons (litters ** 0.264172) totalPulses: decimal (How many pulses were spent since the last heartbeat)  </p> <p>Payload:</p> <p>Bytes: 0900001661000101000005</p> <p>Criptographic: CQAAFmEAAQEAAAU=</p> <p>Decoded:</p> <pre><code>{\n        \"alertType\": \"Pulse Counting (Total Events)\",\n        \"data\": {\n          \"longEventTriggered\": 0,\n          \"settings\": {\n            \"alertInterval\": 500,\n            \"deviceTypeId\": 1\n          },\n          \"totalEvents\": 1,\n          \"totalLiters\": 5.319405756731662,\n          \"totalPulses\": 5729\n        },\n        \"payloadType\": \"Alert\",\n        \"payloadTypeId\": 9\n      }\n</code></pre> <p>(IMPORTANT) Case 10: Long Event Alert (long-duration events): Toilet Sensor Long Event detected</p> <p>Attriubtes: currentState: boolean (True = started. False: Ended) durationTrigger: int (How many time flushing is consider a Long Flush and it will trigger this payload - in milliseconds)</p> <p>Note: this payload will only be triggered after the pulse_duration_trigger interval. So we don't know when the flush started, but we know when the flush is running for a long time. So in order to identify when the flush started, it has to subtract the pulse_duration_trigger value.</p> <p>Payload:</p>"},{"location":"#bytes","title":"Bytes:","text":""},{"location":"#criptographic","title":"Criptographic:","text":"<p>Decoded:</p> <pre><code>{\n        \"alertType\": \"Pulse Counting (Long Event Alert)\",\n        \"data\": {\n          \"currentState\": 1,\n          \"settings\": {\n            \"durationTrigger\": 180000\n          },\n        },\n        \"payloadType\": \"Alert\",\n        \"payloadTypeId\": 10\n      }\n</code></pre> <p>(IMPORTANT) Case 11: Last Event Usage (usage of the last event): Toilet Sensor water usage when a flush (normal or long) ends</p> <p>Attriubtes: totalLiters: decimal (how many litters was spent in the last flush)  -&gt; Convert to Gallons (litters x 0.264172) totalPulses: decimal (how many pulses was spent in the last flush) humidity (%) temperature (Celsius)</p> <p>Note: this payload will be triggered only after a flush (normal or long).  - If this flush was a normal flush, we don't know how much time this flush was running. However, we know by this payload when it finished. - If this flush was a long flush, we know when it started, because the Long Flush payload (type: 10) was triggered before this payload of Last Event Usage (type: 11). - One challenge is to assign the Last Event Usage payload (type: 11) with the Long Flush payload (type: 10), because the payloads will be triggered in different moments. Also, the Last Event Usage payload doesn't indicate if the last event usage was long or a normal flush. - If the last flush spent less then 1 gallon. So this is consider a Scape, not a normal flush </p> <p>Payload:</p> <p>Bytes: 0B00001CCC01088115FF</p> <p>Criptographic: CwAAHMwBCIEV/w==</p> <p>Decoded:</p> <pre><code>{\n  \"alertType\": \"Pulse Counting Event (Last Event Usage)\",\n  \"data\": {\n    \"humidity\": 56.31,\n    \"settings\": {\n      \"deviceTypeId\": 1\n    },\n    \"temperature\": 21.77,\n    \"totalLiters\": 6.84493964716806,\n    \"totalPulses\": 7372\n  },\n  \"payloadType\": \"Alert\",\n  \"payloadTypeId\": 11\n}\n</code></pre> <p>(IMPORTANT) Case 12: Jack connected / disconnected Attriubtes: jackConnected: Boolean (true: yes. false: no)</p> <p>Payload:</p>"},{"location":"#bytes_1","title":"Bytes:","text":""},{"location":"#criptographic_1","title":"Criptographic:","text":"<p>3- System Packets (fPort = 0x03) Maintenance/system packets.</p> <p>Case 0x01: Network Test Packet \u2192 reports SNR and RSSI.</p> <p>Case 0x02: Joined Uplink Packet \u2192 confirms joining the network and sends configs:</p> <p>firmwareVersion, heartbeatInterval, sensorCheckInterval.</p> <p>Which alerts are enabled (bitmasks in bytes[7] and bytes[8]).</p> <p>Used for network testing and initial configuration after join.</p> <p>4- Parameter Values (fPort = 0x04)</p> <p>Here we have many subtypes (dozens). These are configuration/parameterization packets. The first byte (bytes[0]) indicates which parameter. Examples: Identifiers * Case 0: devEui. * Case 1: appEui. * Case 2: appKey (disabled for security reasons). Network and operation configs * Case 3\u20139: retry, confirm mode, join mode, ADR, device class, duty cycle, datarate. * Case 10\u201315: RX1/RX2 delays, datarate, TX power. * Case 16\u201319: region, channel mask, network mode, mode. Operation groups * Case 21\u201326: heartbeat interval, join group, network test group, battery group, no-ack recovery, heartbeat group. Event acknowledgements * Case 27\u201337: Individual acks for external leak, pin leak, tamper, button, temp high/low, humidity high/low, pulse count, etc. Detailed sensor configs * Cases 38\u201346: Leak detection (pin/external) + buzzer + all-in-one parameters. * Cases 47\u201359: Button, high/low temperature, high/low humidity, all with buzzer/guardband/delay. * Case 60\u201361: temperature/humidity offsets. * Case 62: sensing interval. * Case 63\u201364: pulse counting configs. * Case 65\u201369: Jack detection (enabled, buzzer, ack, etc.) and global buzzer control.</p> <p>Summary of the Payload Packets:</p> <ul> <li>Heartbeat (0x01): general status (battery, SNR, sensors, flags).</li> <li>Alerts (0x02): triggered events (leak, tamper, button, temperature, humidity, pulses, jack).</li> <li>System (0x03): network/system packets (tests, join, firmware).</li> <li>Parameters (0x04): massive set of configuration parameters (network, ADR, alerts, delays, buzzer, offsets, etc.).</li> </ul>"},{"location":"#iqsl-payload-formatter-ttn","title":"IQSL Payload Formatter (TTN):","text":"<pre><code>function DoDecode(fPort, bytes) {\n    var decoded = { data: {} };\n    switch (fPort) {\n        case 0x01: { // HeartBeat Packet\n\n\n            decoded.data.state = {};\n            decoded.data.enabledAlerts = {};\n            decoded.payloadType = \"Heartbeat\";\n            decoded.payloadTypeId = bytes[0];\n            decoded.data.batteryVoltage = (bytes[1] / 100) * 2;\n            decoded.data.batteryPercentage = bytes[2];\n            decoded.data.temperature = UInt16(bytes[3] &lt;&lt; 8 | bytes[4]) / 100;\n            decoded.data.humidity = (bytes[5] &lt;&lt; 8 | bytes[6]) / 100;\n            decoded.data.lastSnr = Int8(bytes[7]);\n            decoded.data.lastRssi = Int16(bytes[8] &lt;&lt; 8 | bytes[9]);\n            decoded.data.stateAsUint8 = bytes[10];\n            decoded.data.enabledAlerts.pinLeakDetectionEnabled = ((bytes[10] &amp; 0b00000001) &gt; 0);\n            decoded.data.enabledAlerts.externalLeakDetectionEnabled = ((bytes[10] &amp; 0b00000010) &gt; 0);\n            decoded.data.enabledAlerts.tamperDetectionEnabled = ((bytes[10] &amp; 0b00000100) &gt; 0);\n            decoded.data.state.pinLeakDetected = ((bytes[10] &amp; 0b00001000) &gt; 0);\n            decoded.data.state.externalLeakDetected = ((bytes[10] &amp; 0b00010000) &gt; 0);\n            decoded.data.state.powerDetected = ((bytes[10] &amp; 0b00100000) &gt; 0);\n            decoded.data.state.jackDetected = ((bytes[10] &amp; 0b01000000) &gt; 0);\n            decoded.data.state.magnetDetected = ((bytes[10] &amp; 0b10000000) &gt; 0);\n        }\n            break;\n        case 0x02: { // Alert Packet\n\n\n            decoded.payloadType = \"Alert\";\n            decoded.payloadTypeId = bytes[0];\n\n\n            switch (bytes[0]) {\n                case 1: {\n                    decoded.data.settings = {};\n                    decoded.alertType = \"External Leak Detection (Via Headphone Jack)\";\n                    decoded.data.settings.triggerValue = UInt16(bytes[1] &lt;&lt; 8 | bytes[2]);\n                    decoded.data.currentValue = UInt16(bytes[3] &lt;&lt; 8 | bytes[4]);\n                    decoded.data.temperature = Int16(bytes[5] &lt;&lt; 8 | bytes[6]) / 100;\n                    decoded.data.humidity = UInt16(bytes[7] &lt;&lt; 8 | bytes[8]) / 100;\n                    decoded.data.settings.delayCount = bytes[9];\n                    decoded.data.currentState = bytes[10];\n                } break;\n                case 2: {\n                    decoded.data.settings = {};\n                    decoded.alertType = \"Local Leak Detection (Via Bottom Contact Pins)\";\n                    decoded.data.settings.triggerValue = UInt16(bytes[1] &lt;&lt; 8 | bytes[2]);\n                    decoded.data.currentValue = UInt16(bytes[3] &lt;&lt; 8 | bytes[4]);\n                    decoded.data.temperature = Int16(bytes[5] &lt;&lt; 8 | bytes[6]) / 100;\n                    decoded.data.humidity = UInt16(bytes[7] &lt;&lt; 8 | bytes[8]) / 100;\n                    decoded.data.settings.delayCount = bytes[9];\n                    decoded.data.currentState = bytes[10];\n                } break;\n                case 3: {\n                    decoded.alertType = \"Tamper Detection (Magnet Presence)\";\n                    decoded.data.currentValue = bytes[1];\n                } break;\n                case 4: {\n                    decoded.alertType = \"Push Button Pressed\";\n                    decoded.data.duration = UInt16(bytes[1] &lt;&lt; 8 | bytes[2]);\n                    decoded.data.turningOff = bytes[3];\n                } break;\n                case 5: {\n                    decoded.data.settings = {};\n                    decoded.alertType = \"Temperature Alert (High)\";\n                    decoded.data.temperature = Int16(bytes[1] &lt;&lt; 8 | bytes[2]) / 100;\n                    decoded.data.settings.triggerValue = Int16(bytes[3] &lt;&lt; 8 | bytes[4]) / 100;\n                    decoded.data.settings.guardbandValue = Int16(bytes[5] &lt;&lt; 8 | bytes[6]) / 100;\n                    decoded.data.humidity = UInt16(bytes[7] &lt;&lt; 8 | bytes[8]) / 100;\n                    decoded.data.settings.delayCount = bytes[9];\n                    decoded.data.currentState = bytes[10];\n                } break;\n                case 6: {\n                    decoded.data.settings = {};\n                    decoded.alertType = \"Temperature Alert (Low)\";\n                    decoded.data.temperature = Int16(bytes[1] &lt;&lt; 8 | bytes[2]) / 100;\n                    decoded.data.settings.triggerValue = Int16(bytes[3] &lt;&lt; 8 | bytes[4]) / 100;\n                    decoded.data.settings.guardbandValue = Int16(bytes[5] &lt;&lt; 8 | bytes[6]) / 100;\n                    decoded.data.humidity = UInt16(bytes[7] &lt;&lt; 8 | bytes[8]) / 100;\n                    decoded.data.settings.delayCount = bytes[9];\n                    decoded.data.currentState = bytes[10];\n                } break;\n                case 7: {\n                    decoded.data.settings = {};\n                    decoded.alertType = \"Humidity Alert (High)\";\n                    decoded.data.humidity = UInt16(bytes[1] &lt;&lt; 8 | bytes[2]) / 100;\n                    decoded.data.settings.triggerValue = Int16(bytes[3] &lt;&lt; 8 | bytes[4]) / 100;\n                    decoded.data.settings.guardbandValue = Int16(bytes[5] &lt;&lt; 8 | bytes[6]) / 100;\n                    decoded.data.temperature = Int16(bytes[7] &lt;&lt; 8 | bytes[8]) / 100;\n                    decoded.data.settings.delayCount = bytes[9];\n                    decoded.data.currentState = bytes[10];\n                } break;\n                case 8: {\n                    decoded.data.settings = {};\n                    decoded.alertType = \"Humidity Alert (Low)\";\n                    decoded.data.humidity = UInt16(bytes[1] &lt;&lt; 8 | bytes[2]) / 100;\n                    decoded.data.settings.triggerValue = Int16(bytes[3] &lt;&lt; 8 | bytes[4]) / 100;\n                    decoded.data.settings.guardbandValue = Int16(bytes[5] &lt;&lt; 8 | bytes[6]) / 100;\n                    decoded.data.temperature = Int16(bytes[7] &lt;&lt; 8 | bytes[8]) / 100;\n                    decoded.data.settings.delayCount = bytes[9];\n                    decoded.data.currentState = bytes[10];\n                } break;\n                case 9: {\n                    decoded.data.settings = {};\n                    decoded.alertType = \"Pulse Counting (Total Events)\";\n\n\n                    decoded.data.totalPulses = (bytes[1] &lt;&lt; 24) + (bytes[2] &lt;&lt; 16) + (bytes[3] &lt;&lt; 8) + bytes[4];\n                    decoded.data.totalEvents = UInt16(bytes[5] &lt;&lt; 8 | bytes[6]);\n                    decoded.data.settings.deviceTypeId = bytes[7];\n                    decoded.data.longEventTriggered = bytes[8];\n                    decoded.data.settings.alertInterval = UInt16(bytes[9] &lt;&lt; 8 | bytes[10]) * 100;\n\n\n                    switch (decoded.data.settings.deviceTypeId) {\n                        // Generic Device Type, no usage calculations\n                        case 0x00: {\n\n\n                        } break;\n                        // Toilet Flow Sensor\n                        case 0x01: {\n                            // F=18*Q-3 = 1077 pulses, Q(L/s) = f/1077, Q(L/min) = f*60/1077 = f/18*Q-3, Q(L/hour) = f*60*60/1077 = f*60/18*Q-3  \n                            decoded.data.totalLiters = decoded.data.totalPulses / 1077;\n                        } break;\n                    }\n\n\n                } break;\n                case 10: {\n                    decoded.data.settings = {};\n                    decoded.alertType = \"Pulse Counting (Long Event Alert)\";\n                    decoded.data.currentState = bytes[1];\n                    decoded.data.settings.durationTrigger = UInt16(bytes[2] &lt;&lt; 8 | bytes[3]) * 100;\n                } break;\n                case 11: {\n                    decoded.data.settings = {};\n                    decoded.alertType = \"Pulse Counting Event (Last Event Usage)\";\n                    decoded.data.totalPulses = (bytes[1] &lt;&lt; 24) + (bytes[2] &lt;&lt; 16) + (bytes[3] &lt;&lt; 8) + bytes[4];\n                    decoded.data.settings.deviceTypeId = bytes[5];\n                    decoded.data.temperature = Int16(bytes[6] &lt;&lt; 8 | bytes[7]) / 100;\n                    decoded.data.humidity = UInt16(bytes[8] &lt;&lt; 8 | bytes[9]) / 100;\n                    switch (decoded.data.settings.deviceTypeId) {\n                        // Generic Device Type, no usage calculations\n                        case 0x00:\n                        case 0x01: {\n                            decoded.data.totalLiters = decoded.data.totalPulses / 1077;\n                        } break;\n                    }\n\n\n                } break;\n                case 12: {\n                    decoded.alertType = \"Headphone Jack Alert\";\n                    decoded.data.currentValue = bytes[1];\n                } break;\n            }\n        } break;\n        case 0x03: { // System Packets\n\n\n            decoded.payloadType = \"System\";\n            decoded.payloadTypeId = bytes[0];\n            switch (bytes[0]) {\n                // \"Network Test Packet\"\n                case 0x01: {\n                    decoded.systemType = \"Network Test Packet\";\n                    decoded.data.snr = Int8(bytes[1]);\n                    decoded.data.rssi = Int16(bytes[2] &lt;&lt; 8 | bytes[3]);\n                } break;\n                // \"Joined Uplink Packet\"\n                case 0x02: {\n                    decoded.data.settings = {};\n                    decoded.data.settings.enabledAlerts = {};\n                    decoded.systemType = \"Joined Uplink Packet\";\n                    decoded.data.firmwareVersion = UInt16(bytes[1] &lt;&lt; 8 | bytes[2]);\n                    decoded.data.settings.heartbeatInterval = UInt16(bytes[3] &lt;&lt; 8 | bytes[4]);\n                    decoded.data.settings.sensorCheckInterval = UInt16(bytes[5] &lt;&lt; 8 | bytes[6]);\n                    decoded.data.settings.enabledAlerts.pinLeakDetection = ((bytes[7] &amp; 0b00000001) &gt; 0);\n                    decoded.data.settings.enabledAlerts.externalLeakDetection = ((bytes[7] &amp; 0b00000010) &gt; 0);\n                    decoded.data.settings.enabledAlerts.tamperDetection = ((bytes[7] &amp; 0b00000100) &gt; 0);\n                    decoded.data.settings.enabledAlerts.pushButton = ((bytes[7] &amp; 0b00001000) &gt; 0);\n                    decoded.data.settings.enabledAlerts.temperatureHigh = ((bytes[7] &amp; 0b00010000) &gt; 0);\n                    decoded.data.settings.enabledAlerts.temperatureLow = ((bytes[7] &amp; 0b00100000) &gt; 0);\n                    decoded.data.settings.enabledAlerts.humidityHigh = ((bytes[7] &amp; 0b01000000) &gt; 0);\n                    decoded.data.settings.enabledAlerts.humidityLow = ((bytes[7] &amp; 0b10000000) &gt; 0);\n                    decoded.data.settings.enabledAlerts.pulseCountingAlert = ((bytes[8] &amp; 0b00000001) &gt; 0);\n                    decoded.data.settings.enabledAlerts.pulseCountingEventLongAlert = ((bytes[8] &amp; 0b00000010) &gt; 0);\n\n\n                } break;\n            }\n\n\n        }\n            break;\n        case 0x04: { // Parameter Values\n\n\n            decoded.payloadType = \"Parameter Values\";\n            decoded.payloadTypeId = bytes[0];\n\n\n            switch (bytes[0]) {\n                // devEui Parameter\n                case 0: {\n                    let devEuiTemp = \"\";\n                    devEuiTemp += bytes[1].toString(16).padStart(2, '0').toUpperCase();\n                    devEuiTemp += bytes[2].toString(16).padStart(2, '0').toUpperCase();\n                    devEuiTemp += bytes[3].toString(16).padStart(2, '0').toUpperCase();\n                    devEuiTemp += bytes[4].toString(16).padStart(2, '0').toUpperCase();\n                    devEuiTemp += bytes[5].toString(16).padStart(2, '0').toUpperCase();\n                    devEuiTemp += bytes[6].toString(16).padStart(2, '0').toUpperCase();\n                    devEuiTemp += bytes[7].toString(16).padStart(2, '0').toUpperCase();\n                    devEuiTemp += bytes[8].toString(16).padStart(2, '0').toUpperCase();\n\n\n                    decoded.parameterType = \"devEui\";\n                    decoded.data.devEui = devEuiTemp;\n                } break;\n                // appEui Parameter\n                case 1: {\n                    let appEuiTemp = \"\";\n                    appEuiTemp += bytes[1].toString(16).padStart(2, '0').toUpperCase();\n                    appEuiTemp += bytes[2].toString(16).padStart(2, '0').toUpperCase();\n                    appEuiTemp += bytes[3].toString(16).padStart(2, '0').toUpperCase();\n                    appEuiTemp += bytes[4].toString(16).padStart(2, '0').toUpperCase();\n                    appEuiTemp += bytes[5].toString(16).padStart(2, '0').toUpperCase();\n                    appEuiTemp += bytes[6].toString(16).padStart(2, '0').toUpperCase();\n                    appEuiTemp += bytes[7].toString(16).padStart(2, '0').toUpperCase();\n                    appEuiTemp += bytes[8].toString(16).padStart(2, '0').toUpperCase();\n\n\n                    decoded.parameterType = \"appEui\";\n                    decoded.data.appEui = appEuiTemp;\n                } break;\n                // appKey Parameter\n                case 2: {\n                    decoded.parameterType = \"appKey\";   // This is not enabled for security reasons\n                } break;\n                // Retry Parameter\n                case 3: {\n                    decoded.parameterType = \"retry\";\n                    decoded.data.retry = bytes[1];\n                } break;\n                // Confirm Mode Parameter\n                case 4: {\n                    decoded.parameterType = \"Confirm Mode\";\n                    decoded.data.confirmMode = bytes[1];\n                } break;\n                // Join Mode Parameter\n                case 5: {\n                    decoded.parameterType = \"Join Mode\";\n                    decoded.data.joinMode = bytes[1];\n                } break;\n                // ADR Parameter\n                case 6: {\n                    decoded.parameterType = \"ADR\";\n                    decoded.data.adr = bytes[1];\n                } break;\n                // Device Class Parameter\n                case 7: {\n                    decoded.parameterType = \"Device Class\";\n                    decoded.data.deviceClass = bytes[1];\n                } break;\n                // Duty Cycle Parameter\n                case 8: {\n                    decoded.parameterType = \"Duty Cycle\";\n                    decoded.data.dutyCycle = bytes[1];\n                } break;\n                // Datarate Parameter\n                case 9: {\n                    decoded.parameterType = \"Datarate\";\n                    decoded.data.datarate = bytes[1];\n                } break;\n                // Join Delay RX1 Parameter\n                case 10: {\n                    decoded.parameterType = \"Join Delay RX1\";\n                    decoded.data.joinDelayRx1 = UInt16(bytes[1] &lt;&lt; 8 | bytes[2]);\n                } break;\n                // Join Delay RX2 Parameter\n                case 11: {\n                    decoded.parameterType = \"Join Delay RX2\";\n                    decoded.data.joinDelayRx2 = UInt16(bytes[1] &lt;&lt; 8 | bytes[2]);\n                } break;\n                // Public Network Mode Parameter\n                case 12: {\n                    decoded.parameterType = \"Public Network Mode\";\n                    decoded.publicNetworkMode = bytes[1];\n                } break;\n                // RX1 Delay Parameter\n                case 13: {\n                    decoded.parameterType = \"RX1 Delay\";\n                    decoded.data.rx1Delay = UInt16(bytes[1] &lt;&lt; 8 | bytes[2]);\n                } break;\n                // RX2 Delay Parameter\n                case 14: {\n                    decoded.parameterType = \"RX2 Delay\";\n                    decoded.data.rx2Delay = UInt16(bytes[1] &lt;&lt; 8 | bytes[2]);\n                } break;\n                // RX2 Datarate Parameter\n                case 15: {\n                    decoded.parameterType = \"RX2 Datarate\";\n                    decoded.data.rx2Datarate = bytes[1];\n                } break;\n                // TX Power Parameter\n                case 16: {\n                    decoded.parameterType = \"TX Power\";\n                    decoded.data.txPower = bytes[1];\n                } break;\n                // Region Parameter\n                case 17: {\n                    decoded.parameterType = \"Region\";\n                    decoded.data.region = bytes[1];\n                } break;\n                // Channel Mask Parameter\n                case 18: {\n                    let channelMaskTemp = \"\";\n                    channelMaskTemp += bytes[1].toString(16).padStart(2, '0').toUpperCase();\n                    channelMaskTemp += bytes[2].toString(16).padStart(2, '0').toUpperCase();\n\n\n                    decoded.parameterType = \"Channel Mask\";\n                    decoded.data.channelMask = channelMaskTemp;\n                } break;\n                // Network Mode Parameter\n                case 19: {\n                    decoded.parameterType = \"Network Mode\";\n                    decoded.data.networkMode = bytes[1];\n                } break;\n                // Mode Parameter\n                case 20: {\n                    decoded.parameterType = \"Mode\";\n                    decoded.data.mode = bytes[1];\n                } break;\n                // Heartbeat Interval Parameter\n                case 21: {\n                    decoded.parameterType = \"Heartbeat Interval\";\n                    decoded.data.heartbeatInterval = UInt16(bytes[1] &lt;&lt; 8 | bytes[2]);\n                } break;\n                // Join Group Parameter\n                case 22: {\n                    decoded.parameterType = \"Join Group\";\n                    decoded.data.delayBetweenIterations = UInt16(bytes[1] &lt;&lt; 8 | bytes[2]);\n                    decoded.data.delayBetweenSequence = UInt16(bytes[3] &lt;&lt; 8 | bytes[4]);\n                    decoded.data.failCountToTriggerLongDelay = bytes[5];\n                    decoded.data.longDelayBetweenSequence = UInt16(bytes[6] &lt;&lt; 8 | bytes[7]);\n\n\n\n                } break;\n                // Network Test Group Parameter\n                case 23: {\n                    decoded.parameterType = \"Network Test Group\";\n                    decoded.data.interval = UInt16(bytes[1] &lt;&lt; 8 | bytes[2]);\n                    decoded.data.adr = bytes[3];\n                    decoded.data.datarate = bytes[4];\n                    decoded.data.txPower = bytes[5];\n                } break;\n                // Battery Group Parameter\n                case 24: {\n                    decoded.parameterType = \"Battery Group\";\n                    decoded.data.batteryMin = (bytes[1] * 2) / 100;\n                    decoded.data.batteryMax = (bytes[2] * 2) / 100;\n                    decoded.data.batteryType = bytes[3];\n                } break;\n                // No ACK Recovery Group Parameter\n                case 25: {\n                    decoded.parameterType = \"No ACK Recovery Group\";\n                    decoded.data.noAckRecoveryMode = bytes[1];\n                    decoded.data.adrDisabled = bytes[2];\n                    decoded.data.delay = UInt16(bytes[3] &lt;&lt; 8 | bytes[4]);\n                    decoded.data.retryCount = bytes[5];\n                    decoded.data.Retrydelay = UInt16(bytes[6] &lt;&lt; 8 | bytes[7]);\n                } break;\n                // Heartbeat Group Parameter\n                case 26: {\n                    decoded.parameterType = \"Heartbeat Group\";\n                    decoded.data.heartbeatId = bytes[1];\n                    decoded.data.ack = bytes[2];\n                    decoded.data.ackRetryCount = bytes[3];\n                } break;\n                // External Leak ACK Parameter\n                case 27: {\n                    decoded.parameterType = \"External Leak ACK\";\n                    decoded.data.ack = bytes[1];\n                    decoded.data.ackRetryCount = bytes[2];\n                } break;\n                // Pin Leak ACK Parameter\n                case 28: {\n                    decoded.parameterType = \"Pin Leak ACK\";\n                    decoded.data.ack = bytes[1];\n                    decoded.data.ackRetryCount = bytes[2];\n                } break;\n                // Tamper Detection ACK Parameter\n                case 29: {\n                    decoded.parameterType = \"Tamper Detection ACK\";\n                    decoded.data.ack = bytes[1];\n                    decoded.data.ackRetryCount = bytes[2];\n                } break;\n                // Button Press ACK Parameter\n                case 30: {\n                    decoded.parameterType = \"Button Press ACK\";\n                    decoded.data.ack = bytes[1];\n                    decoded.data.ackRetryCount = bytes[2];\n                } break;\n                // Temperature High ACK Parameter\n                case 31: {\n                    decoded.parameterType = \"Temperature High ACK\";\n                    decoded.data.ack = bytes[1];\n                    decoded.data.ackRetryCount = bytes[2];\n                } break;\n                // Temperature Low ACK Parameter\n                case 32: {\n                    decoded.parameterType = \"Temperature Low ACK\";\n                    decoded.data.ack = bytes[1];\n                    decoded.data.ackRetryCount = bytes[2];\n                } break;\n                // Humidity High ACK Parameter\n                case 33: {\n                    decoded.parameterType = \"Humidity High ACK\";\n                    decoded.data.ack = bytes[1];\n                    decoded.data.ackRetryCount = bytes[2];\n                } break;\n                // Humidity Low ACK Parameter\n                case 34: {\n                    decoded.parameterType = \"Humidity Low ACK\";\n                    decoded.data.ack = bytes[1];\n                    decoded.data.ackRetryCount = bytes[2];\n                } break;\n                // Pulse Count ACK Parameter\n                case 35: {\n                    decoded.parameterType = \"Pulse Count ACK\";\n                    decoded.data.ack = bytes[1];\n                    decoded.data.ackRetryCount = bytes[2];\n                } break;\n                // Pulse Count Long Event ACK Parameter\n                case 36: {\n                    decoded.parameterType = \"Pulse Count Long Event ACK\";\n                    decoded.data.ack = bytes[1];\n                    decoded.data.ackRetryCount = bytes[2];\n                } break;\n                // Parameter Uplink ACK Parameter\n                case 37: {\n                    decoded.parameterType = \"Parameter Uplink ACK\";\n                    decoded.data.ack = bytes[1];\n                    decoded.data.ackRetryCount = bytes[2];\n                } break;\n                // Pin Leak Detection Parameter\n                case 38: {\n                    decoded.parameterType = \"Pin Leak Detection\";\n                    decoded.data.enabled = bytes[1];\n                    decoded.data.triggerValue = UInt16(bytes[2] &lt;&lt; 8 | bytes[3]);\n                    decoded.data.triggerDelay = bytes[4];\n                } break;\n                // Pin Leak Detection Buzzer Parameter\n                case 39: {\n                    decoded.parameterType = \"Pin Leak Detection Buzzer\";\n                    decoded.data.enabled = bytes[1];\n                    decoded.data.silenceEnabled = bytes[2];\n                    decoded.data.silenceCounter = UInt16(bytes[3] &lt;&lt; 8 | bytes[4]);\n                    decoded.data.beepCount = bytes[5];\n                    decoded.data.beepDuration = UInt16(bytes[6] &lt;&lt; 8 | bytes[7]);\n\n\n                } break;\n                // Pin Leak Detection All Parameter\n                case 40: {\n                    decoded.parameterType = \"Pin Leak Detection All\";\n                    decoded.data.pinLeakDetectionEnabled = ((bytes[1] &amp; 0b00000001) &gt; 0);\n                    decoded.data.buzzerEnabled = ((bytes[1] &amp; 0b00000010) &gt; 0);\n                    decoded.data.silenceEnabled = ((bytes[1] &amp; 0b00000100) &gt; 0);\n                    decoded.data.triggerValue = UInt16(bytes[2] &lt;&lt; 8 | bytes[3]);\n                    decoded.data.triggerDelay = bytes[4];\n                    decoded.data.silenceCounter = UInt16(bytes[5] &lt;&lt; 8 | bytes[6]);\n                    decoded.data.beepCount = bytes[7];\n                    decoded.data.beepDuration = UInt16(bytes[8] &lt;&lt; 8 | bytes[9]);\n\n\n                } break;\n                // External Leak Detection Parameter\n                case 41: {\n                    decoded.parameterType = \"External Leak Detection\";\n                    decoded.data.enabled = bytes[1];\n                    decoded.data.triggerValue = UInt16(bytes[2] &lt;&lt; 8 | bytes[3]);\n                    decoded.data.triggerDelay = bytes[4];\n                } break;\n                // External Leak Detection Buzzer Parameter\n                case 42: {\n                    decoded.parameterType = \"External Leak Detection Buzzer\";\n                    decoded.data.enabled = bytes[1];\n                    decoded.data.silenceEnabled = bytes[2];\n                    decoded.data.silenceCounter = UInt16(bytes[3] &lt;&lt; 8 | bytes[4]);\n                    decoded.data.beepCount = bytes[5];\n                    decoded.data.beepDuration = UInt16(bytes[6] &lt;&lt; 8 | bytes[7]);\n                } break;\n                // External Leak Detection All Parameter\n                case 43: {\n                    decoded.parameterType = \"External Leak Detection All\";\n                    decoded.data.pinLeakDetectionEnabled = ((bytes[1] &amp; 0b00000001) &gt; 0);\n                    decoded.data.buzzerEnabled = ((bytes[1] &amp; 0b00000010) &gt; 0);\n                    decoded.data.silenceEnabled = ((bytes[1] &amp; 0b00000100) &gt; 0);\n                    decoded.data.triggerValue = UInt16(bytes[2] &lt;&lt; 8 | bytes[3]);\n                    decoded.data.triggerDelay = bytes[4];\n                    decoded.data.silenceCounter = UInt16(bytes[5] &lt;&lt; 8 | bytes[6]);\n                    decoded.data.beepCount = bytes[7];\n                    decoded.data.beepDuration = UInt16(bytes[8] &lt;&lt; 8 | bytes[9]);\n                } break;\n                // Tamper Detection Parameter\n                case 44: {\n                    decoded.parameterType = \"Tamper Detection\";\n                    decoded.data.enabled = bytes[1];\n                } break;\n                // Tamper Detection Buzzer Parameter\n                case 45: {\n                    decoded.parameterType = \"Tamper Detection Buzzer\";\n                    decoded.data.enabled = bytes[1];\n                    decoded.data.silenceEnabled = bytes[2];\n                    decoded.data.silenceCounter = UInt16(bytes[3] &lt;&lt; 8 | bytes[4]);\n                    decoded.data.beepCount = bytes[5];\n                    decoded.data.beepDuration = UInt16(bytes[6] &lt;&lt; 8 | bytes[7]);\n                } break;\n                // Tamper Detection All Parameter\n                case 46: {\n                    decoded.parameterType = \"Tamper Detection All\";\n                    decoded.data.enabled = bytes[1];\n                    decoded.data.buzzerEnabled = bytes[2];\n                    decoded.data.silenceEnabled = bytes[3];\n                    decoded.data.silenceCounter = UInt16(bytes[4] &lt;&lt; 8 | bytes[5]);\n                    decoded.data.beepCount = bytes[6];\n                    decoded.data.beepDuration = UInt16(bytes[7] &lt;&lt; 8 | bytes[8]);\n                } break;\n                // Button Pressed Parameter\n                case 47: {\n                    decoded.parameterType = \"Button Pressed\";\n                    decoded.data.enabled = bytes[1];\n                } break;\n                // Temperature High Parameter\n                case 48: {\n                    decoded.parameterType = \"Temperature High\";\n                    decoded.data.enabled = bytes[1];\n                    decoded.data.triggerValue = (Int16(bytes[2] &lt;&lt; 8 | bytes[3])) / 100;\n                    decoded.data.guardbandValue = (Int16(bytes[4] &lt;&lt; 8 | bytes[5])) / 100;\n                    decoded.data.delayCount = bytes[6];\n                } break;\n                // Temperature High Buzzer Parameter\n                case 49: {\n                    decoded.parameterType = \"Temperature High Buzzer\";\n                    decoded.data.enabled = bytes[1];\n                    decoded.data.silenceEnabled = bytes[2];\n                    decoded.data.silenceCounter = UInt16(bytes[3] &lt;&lt; 8 | bytes[4]);\n                    decoded.data.beepCount = bytes[5];\n                    decoded.data.beepDuration = UInt16(bytes[6] &lt;&lt; 8 | bytes[7]);\n                } break;\n                // Temperature High All Parameter\n                case 50: {\n                    decoded.parameterType = \"Temperature High All\";\n                    decoded.data.enabled = ((bytes[1] &amp; 0b00000001) &gt; 0);\n                    decoded.data.buzzerEnabled = ((bytes[1] &amp; 0b00000010) &gt; 0);\n                    decoded.data.silenceEnabled = ((bytes[1] &amp; 0b00000100) &gt; 0);\n                    decoded.data.triggerValue = (Int16(bytes[2] &lt;&lt; 8 | bytes[3])) / 100;\n                    decoded.data.guardbandValue = (Int16(bytes[4] &lt;&lt; 8 | bytes[5])) / 100;\n                    decoded.data.delayCount = bytes[6];\n                    decoded.data.silenceCounter = bytes[7];\n                    decoded.data.beepCount = bytes[8];\n                    decoded.data.beepDuration = UInt16(bytes[9] &lt;&lt; 8 | bytes[10]);\n\n\n                } break;\n                // Temperature Low Parameter\n                case 51: {\n                    decoded.parameterType = \"Temperature Low\";\n                    decoded.data.enabled = bytes[1];\n                    decoded.data.triggerValue = (Int16(bytes[2] &lt;&lt; 8 | bytes[3])) / 100;\n                    decoded.data.guardbandValue = (Int16(bytes[4] &lt;&lt; 8 | bytes[5])) / 100;\n                    decoded.data.delayCount = bytes[6];\n                } break;\n                // Temperature Low Buzzer Parameter\n                case 52: {\n                    decoded.parameterType = \"Temperature Low Buzzer\";\n                    decoded.data.enabled = bytes[1];\n                    decoded.data.silenceEnabled = bytes[2];\n                    decoded.data.silenceCounter = UInt16(bytes[3] &lt;&lt; 8 | bytes[4]);\n                    decoded.data.beepCount = bytes[5];\n                    decoded.data.beepDuration = UInt16(bytes[6] &lt;&lt; 8 | bytes[7]);\n                } break;\n                // Temperature Low All Parameter\n                case 53: {\n                    decoded.parameterType = \"Temperature Low All\";\n                    decoded.data.enabled = ((bytes[1] &amp; 0b00000001) &gt; 0);\n                    decoded.data.buzzerEnabled = ((bytes[1] &amp; 0b00000010) &gt; 0);\n                    decoded.data.silenceEnabled = ((bytes[1] &amp; 0b00000100) &gt; 0);\n                    decoded.data.triggerValue = (Int16(bytes[2] &lt;&lt; 8 | bytes[3])) / 100;\n                    decoded.data.guardbandValue = (Int16(bytes[4] &lt;&lt; 8 | bytes[5])) / 100;\n                    decoded.data.delayCount = bytes[6];\n                    decoded.data.silenceCounter = bytes[7];\n                    decoded.data.beepCount = bytes[8];\n                    decoded.data.beepDuration = UInt16(bytes[9] &lt;&lt; 8 | bytes[10]);\n                } break;\n                // Humidity High Parameter\n                case 54: {\n                    decoded.parameterType = \"Humidity High\";\n                    decoded.data.enabled = bytes[1];\n                    decoded.data.triggerValue = (Int16(bytes[2] &lt;&lt; 8 | bytes[3])) / 100;\n                    decoded.data.guardbandValue = (Int16(bytes[4] &lt;&lt; 8 | bytes[5])) / 100;\n                    decoded.data.delayCount = bytes[6];\n                } break;\n                // Humidity High Buzzer Parameter\n                case 55: {\n                    decoded.parameterType = \"Humidity High Buzzer\";\n                    decoded.data.enabled = bytes[1];\n                    decoded.data.silenceEnabled = bytes[2];\n                    decoded.data.silenceCounter = UInt16(bytes[3] &lt;&lt; 8 | bytes[4]);\n                    decoded.data.beepCount = bytes[5];\n                    decoded.data.beepDuration = UInt16(bytes[6] &lt;&lt; 8 | bytes[7]);\n                } break;\n                // Humidity High All Parameter\n                case 56: {\n                    decoded.parameterType = \"Humidity High All\";\n                    decoded.data.enabled = ((bytes[1] &amp; 0b00000001) &gt; 0);\n                    decoded.data.buzzerEnabled = ((bytes[1] &amp; 0b00000010) &gt; 0);\n                    decoded.data.silenceEnabled = ((bytes[1] &amp; 0b00000100) &gt; 0);\n                    decoded.data.triggerValue = (Int16(bytes[2] &lt;&lt; 8 | bytes[3])) / 100;\n                    decoded.data.guardbandValue = (Int16(bytes[4] &lt;&lt; 8 | bytes[5])) / 100;\n                    decoded.data.delayCount = bytes[6];\n                    decoded.data.silenceCounter = bytes[7];\n                    decoded.data.beepCount = bytes[8];\n                    decoded.data.beepDuration = UInt16(bytes[9] &lt;&lt; 8 | bytes[10]);\n                } break;\n                // Humidity Low Parameter\n                case 57: {\n                    decoded.parameterType = \"Humidity Low\";\n                    decoded.data.enabled = bytes[1];\n                    decoded.data.triggerValue = (Int16(bytes[2] &lt;&lt; 8 | bytes[3])) / 100;\n                    decoded.data.guardbandValue = (Int16(bytes[4] &lt;&lt; 8 | bytes[5])) / 100;\n                    decoded.data.delayCount = bytes[6];\n                } break;\n                // Humidity Low Buzzer Parameter\n                case 58: {\n                    decoded.parameterType = \"Humidity Low Buzzer\";\n                    decoded.data.enabled = bytes[1];\n                    decoded.data.silenceEnabled = bytes[2];\n                    decoded.data.silenceCounter = UInt16(bytes[3] &lt;&lt; 8 | bytes[4]);\n                    decoded.data.beepCount = bytes[5];\n                    decoded.data.beepDuration = UInt16(bytes[6] &lt;&lt; 8 | bytes[7]);\n                } break;\n                // Humidity Low All Parameter\n                case 59: {\n                    decoded.parameterType = \"Humidity Low All\";\n                    decoded.data.enabled = ((bytes[1] &amp; 0b00000001) &gt; 0);\n                    decoded.data.buzzerEnabled = ((bytes[1] &amp; 0b00000010) &gt; 0);\n                    decoded.data.silenceEnabled = ((bytes[1] &amp; 0b00000100) &gt; 0);\n                    decoded.data.triggerValue = (Int16(bytes[2] &lt;&lt; 8 | bytes[3])) / 100;\n                    decoded.data.guardbandValue = (Int16(bytes[4] &lt;&lt; 8 | bytes[5])) / 100;\n                    decoded.data.delayCount = bytes[6];\n                    decoded.data.silenceCounter = bytes[7];\n                    decoded.data.beepCount = bytes[8];\n                    decoded.data.beepDuration = UInt16(bytes[9] &lt;&lt; 8 | bytes[10]);\n                } break;\n                // Temperature Offset Parameter\n                case 60: {\n                    decoded.parameterType = \"Temperature Offset\";\n                    decoded.data.offset = (Int16(bytes[1] &lt;&lt; 8 | bytes[2])) / 100;\n                } break;\n                // Humidity Offset Parameter\n                case 61: {\n                    decoded.parameterType = \"Humidity Offset\";\n                    decoded.data.offset = (Int16(bytes[1] &lt;&lt; 8 | bytes[2])) / 100;\n                } break;\n                // Sense Interval Parameter\n                case 62: {\n                    decoded.parameterType = \"Sense Interval\";\n                    decoded.data.interval = UInt16(bytes[1] &lt;&lt; 8 | bytes[2]);\n                } break;\n                // Pulse Counting Parameter\n                case 63: {\n                    decoded.parameterType = \"Pulse Counting\";\n                    decoded.data.enabled = bytes[1];\n                    decoded.data.deviceTypeId = bytes[2];\n                    decoded.data.reportingInterval = UInt16(bytes[3] &lt;&lt; 8 | bytes[4]);\n                    decoded.data.eventDelayValue = UInt16(bytes[5] &lt;&lt; 8 | bytes[6]);\n\n\n                } break;\n                // Pulse Counting Long Event Parameter\n                case 64: {\n                    decoded.parameterType = \"Pulse Counting Long Event\";\n                    decoded.data.enabled = bytes[1];\n                    decoded.data.eventLongDelayValue = UInt16(bytes[2] &lt;&lt; 8 | bytes[3]);\n                } break;\n                case 65: {\n                    decoded.parameterType = \"Jack Detected Event ACK\";\n                    decoded.data.ack = bytes[1];\n                    decoded.data.ackRetryCount = bytes[2];\n                } break;\n                case 66: {\n                    decoded.parameterType = \"Jack Detected Event\";\n                    decoded.data.enabled = bytes[1];\n                    decoded.data.delayCount = bytes[2];\n                } break;\n                case 67: {\n                    decoded.parameterType = \"Jack Detected Buzzer\";\n                    decoded.data.enabled = bytes[1];\n                    decoded.data.silenceEnabled = bytes[2];\n                    decoded.data.silenceCounter = UInt16(bytes[3] &lt;&lt; 8 | bytes[4]);\n                    decoded.data.beepCount = bytes[5];\n                    decoded.data.beepDuration = UInt16(bytes[6] &lt;&lt; 8 | bytes[7]);\n                } break;\n                case 68: {\n                    decoded.parameterType = \"Jack Detected All\";\n                    decoded.data.enabled = bytes[1];\n                    decoded.data.delayCount = bytes[2];\n                    decoded.data.buzzerEnabled = bytes[3];\n                    decoded.data.silenceEnabled = bytes[4];\n                    decoded.data.silenceCounter = UInt16(bytes[5] &lt;&lt; 8 | bytes[6]);\n                    decoded.data.beepCount = bytes[7];\n                    decoded.data.beepDuration = UInt16(bytes[8] &lt;&lt; 8 | bytes[9]);\n                } break;\n                case 69: {\n                    decoded.parameterType = \"Buzzer Disabled\";\n                    decoded.data.disabled = bytes[1];\n                } break;\n            }\n\n\n\n\n        } break;\n        default:\n            decoded.unknown = \"Unknown data format\";\n            break;\n    }\n    return decoded;\n}\n\n\n// For TTN\nfunction Decoder(bytes, fPort) {\n    return DoDecode(fPort, bytes);\n}\n\n\n// For Chirpstack\nfunction Decode(fPort, bytes, variables) {\n    return DoDecode(fPort, bytes);\n}\n\n\n// Chirpstack v3 to v4 compatibility wrapper\nfunction decodeUplink(input) {\n    return {\n        data: Decode(input.fPort, input.bytes, input.variables)\n    };\n}\n\n\nvar UInt4 = function (value) {\n    return (value &amp; 0xF);\n};\n\n\nvar Int4 = function (value) {\n    var ref = UInt4(value);\n    return (ref &gt; 0x7) ? ref - 0x10 : ref;\n};\n\n\nvar UInt8 = function (value) {\n    return (value &amp; 0xFF);\n};\n\n\nvar Int8 = function (value) {\n    var ref = UInt8(value);\n    return (ref &gt; 0x7F) ? ref - 0x100 : ref;\n};\n\n\nvar UInt16 = function (value) {\n    return (value &amp; 0xFFFF);\n};\n\n\nvar Int16 = function (value) {\n    var ref = UInt16(value);\n    return (ref &gt; 0x7FFF) ? ref - 0x10000 : ref;\n};\n</code></pre>"},{"location":"#iqsv","title":"IQSV","text":"<p>IQSV devices are installed directly in the pipe and measure the water flow, temperature, pressure and contain a valve that can open and close the flow.</p> <p>There are 2 types of IQSV</p> <ul> <li>IQSV V1 and V2 (older ones - until Sep/2025):</li> </ul> <p>Attributes: BatteryAlarm: bool BurstAlarm: bool (when pipe is damaged) CumulativeConsumption: decimal (water flow since the moment the device is turned ON) -&gt; * 264.172052 = value in gallons EEPROMERROR: bool (no idea what is it) EmptyPipeAlarm: bool (when no flow) InstantConsumption: decimal (water flow in this moment PER HOUR) -&gt; * 264.172052 = value in gallons LeakageAlarm: bool (when there is a leak in the device/pipe) LowBatteryAlarm: bool (when the battery is low) OverRangeAlarm: bool (no idea what is it) OverTemperatureAlarm: bool (temperature defined in the firmware) PreviousDayConsumption: decimal (water flow yesterday)  -&gt; * 264.172052 = value in gallons ReverseCumulativeConsumption: decimal (if there is a flow in reverse) -&gt;  * 264.172052 = value in gallons ReverseFlowAlarm: bool (when reverse flow) ValveStatus: open/close WaterPressure: decimal (in MPA) -&gt; * 145.038 to convert to PSI WaterTemperature: decimal (in Celsius) -&gt; Need to convert to \u00b0F  </p> <p>Payload:</p> <p>Bytes: FEFE68201335465201740081259090002B612461002B812155002B000000003500000000652300810248091122092520000013161F\u2026</p> <p>Criptographic: /v5oIBM1RlIBdACBJZCQACthJGEAK4EhVQArAAAAADUAAAAAZSMAgQJICREiCSUgAAATFh8=</p> <p>Decoded:</p> <pre><code>{\n    \"BatteryAlarm\": false,\n    \"BurstAlarm\": false,\n    \"CumulativeConsumption\": \"612.461\",\n    \"EEPROMERROR\": false,\n    \"EmptyPipeAlarm\": false,\n    \"InstantConsumption\": \"0.0000\",\n    \"LeakageAlarm\": false,\n    \"LowBatteryAlarm\": false,\n    \"OverRangeAlarm\": false,\n    \"OverTemperatureAlarm\": false,\n    \"PreviousDayConsumption\": \"552.181\",\n    \"ReverseCumulativeConsumption\": \"0.000\",\n    \"ReverseFlowAlarm\": false,\n    \"ValveStatus\": \"open\",\n    \"WaterPressure\": \"0.281\",\n    \"WaterTemperature\": \"23.65\"\n}\n</code></pre> <p>Payload Formatter (TTN):</p> <pre><code>function decodeUplink(input)\n{\n    var bytes = input.bytes;\n\n    var bitst1, bitst1L, bitt, bittL, Bat, Battery, Code, Len, ID, Count, Unit, decimals, raw, output, Data1, Data2, Data3, Data4, Data5, Data6, Data7, Status, Err, Concat, Concat1, Concat2, Concat3, Concat4, Concat5, Concat6;\n    var st1error5, st1error4, st1error3, st1error2, error7, error6, error5, error4, error3, error2, error1, error0;\n    var Downlink;\n    var interval, inte_unit;\n    var deff = \"null\";\n\n\n    //METER SN DECODE\n    if (bytes[0] == \"131\")\n    {\n        //control code\n        if (bytes[0] == \"131\") { Code = bytes[0].toString(16); }\n\n\n        //data length\n        if (bytes[1] == \"10\") { Len = \"Length of the Data Frame : \" + bytes[1]; }\n\n\n        //data identification for meter SN uplink\n        if (bytes[2] == \"129\" &amp; bytes[3] == \"10\") { ID = \"Read Meter Serial Number\"; }\n\n\n        //uplink data counter\n        Count = \"Uplink Data Counter : \" + bytes[4];\n\n\n        //meter SN indicator\n        Data1 = bytes[5];\n        Data2 = bytes[6];\n        Data3 = bytes[7];\n        Data4 = bytes[8];\n        Data5 = bytes[9];\n        Data6 = bytes[10];\n        Data7 = bytes[11];\n        if (Data1 &lt; 10) { Data1 = '0' + Data1.toString(16); } else { Data1 = Data1.toString(16); }\n        if (Data2 &lt; 10) { Data2 = '0' + Data2.toString(16); } else { Data2 = Data2.toString(16); }\n        if (Data3 &lt; 10) { Data3 = '0' + Data3.toString(16); } else { Data3 = Data3.toString(16); }\n        if (Data4 &lt; 10) { Data4 = '0' + Data4.toString(16); } else { Data4 = Data4.toString(16); }\n        if (Data5 &lt; 10) { Data5 = '0' + Data5.toString(16); } else { Data5 = Data5.toString(16); }\n        if (Data6 &lt; 10) { Data6 = '0' + Data6.toString(16); } else { Data6 = Data6.toString(16); }\n        if (Data7 &lt; 10) { Data7 = '0' + Data7.toString(16); } else { Data7 = Data7.toString(16); }\n        Concat1 = Data7.concat(Data6);\n        Concat2 = Data5.concat(Data4);\n        Concat3 = Data3.concat(Data2);\n        Concat4 = Concat1.concat(Concat2);\n        Concat5 = Concat3.concat(Data1);\n        Concat = Concat4.concat(Concat5);\n\n\n        return {\n        Command_Code: Code,\n                Data_Length: Len,\n                Data_Type: ID,\n                Count: Count,\n                Meter_Addr: Concat\n        };\n    }\n\n\n    //METER TOTALIZER DECODE\n    else if (bytes[0] == 0x81)\n    {\n        console.log(bytes[0])\n        //control code\n        if (bytes[0] == 0x81) { Code = bytes[0].toString(16); }\n\n\n        //data length(not include battery indicator byte)\n        if (bytes[1] == 0x0A) { Len = \"Length of the Data Frame : \" + bytes[1]; }\n\n\n        //data identification for totalizer uplink\n        if (bytes[2] == 0x144 &amp; bytes[3] == 0x31) { ID = \"Read Meter Cumulative Value\"; }\n\n\n        //uplink data counter\n        Count = \"Uplink Data Counter : \" + bytes[4];\n\n\n        //decimals\n        if (bytes[5] == 0x2B) { Unit = \"Cubic Meter\"; decimals = 1000; }\n        else if (bytes[5] == 0x2C) { Unit = \"Cubic Meter\"; decimals = 100; }\n\n\n        //totalizer\n        a = bytes[6];\n        b = bytes[7];\n        c = bytes[8];\n        d = bytes[9];\n        if (a &lt; 0x10) { a = '0' + a.toString(16); } else { a = a.toString(16); }\n        if (b &lt; 0x10) { b = '0' + b.toString(16); } else { b = b.toString(16); }\n        if (c &lt; 0x10) { c = '0' + c.toString(16); } else { c = c.toString(16); }\n        if (d &lt; 0x10) { d = '0' + d.toString(16); } else { d = d.toString(16); }\n        concat1 = d.concat(c);\n        concat2 = b.concat(a);\n        raw = concat1.concat(concat2);\n        output = raw / decimals;\n\n\n\n\n        //valve indicator\n        if (bytes[10] == 0x01) { Status = \"Valve Control : Available\"; } else { Status = \"Valve Control : Not Available\"; }\n\n\n        //error bits ST1\n        bitst1 = bytes[10];\n        bitst1 = bitst1.toString(2);\n        bitst1 = ('000000000' + bitst1).slice(-8);\n        if (bitst1[5] == \"1\") { st1error5 = \"Leakage Alert, \"; } else { st1error5 = \"\"; }\n        if (bitst1[4] == \"1\") { st1error4 = \"Burst Alert, \"; } else { st1error4 = \"\"; }\n        if (bitst1[3] == \"1\") { st1error3 = \"Tamper Alert, \"; } else { st1error3 = \"\"; }\n        if (bitst1[2] == \"1\") { st1error2 = \"Freezing Alert, \"; } else { st1error2 = \"\"; }\n        bitst1L = st1error5 + st1error4 + st1error3 + st1error2;\n        bitst1L = bitst1L.substr(0, bitst1L.length - 2);\n        if (bitst1L.length == 0) { bitst1L = \"No st1error\"; }\n        //if (bytes[11] == \"8\") { Err = \"Transducer Outlet Error\"; }\n        //if (bytes[11] == \"7\") { Err = \"Transducer Inlet Error\"; }\n        //if (bytes[11] == \"6\") { Err = \"EEPROM Error\"; }\n        //if (bytes[11] == \"5\") { Err = \"Temperature Alert\"; }\n        //if (bytes[11] == \"4\") { Err = \"Over Range/Flow Alert\"; }\n        //if (bytes[11] == \"3\") { Err = \"Reverse Flow Alert\"; }\n        //if (bytes[11] == \"2\") { Err = \"Empty Pipe Alert\"; }\n        //if (bytes[11] == \"1\") { Err = \"Battery Alert\"; }\n        //if (bytes[11] == \"0\") { Err = \"No Error\"; }\n\n\n\n\n        //error bits ST2\n        bitt = bytes[11];\n        bitt = bitt.toString(2);\n        bitt = ('000000000' + bitt).slice(-8);\n        if (bitt[7] == \"1\") { error7 = \"Battery Alert, \"; } else { error7 = \"\"; }\n        if (bitt[6] == \"1\") { error6 = \"Empty Pipe Alert, \"; } else { error6 = \"\"; }\n        if (bitt[5] == \"1\") { error5 = \"Reverse Flow Alert, \"; } else { error5 = \"\"; }\n        if (bitt[4] == \"1\") { error4 = \"Over Range/Flow Alert, \"; } else { error4 = \"\"; }\n        if (bitt[3] == \"1\") { error3 = \"Temperature Alert, \"; } else { error3 = \"\"; }\n        if (bitt[2] == \"1\") { error2 = \"EEPROM Error, \"; } else { error2 = \"\"; }\n        if (bitt[1] == \"1\") { error1 = \"Transducer Inlet Error, \"; } else { error1 = \"\"; }\n        if (bitt[0] == \"1\") { error0 = \"Transducer Outlet Error, \"; } else { error0 = \"\"; }\n        bittL = error7 + error6 + error5 + error4 + error3 + error2 + error1 + error0;\n        bittL = bittL.substr(0, bittL.length - 2);\n        if (bittL.length == 0) { bittL = \"No Error\"; }\n        //if (bytes[11] == \"8\") { Err = \"Transducer Outlet Error\"; }\n        //if (bytes[11] == \"7\") { Err = \"Transducer Inlet Error\"; }\n        //if (bytes[11] == \"6\") { Err = \"EEPROM Error\"; }\n        //if (bytes[11] == \"5\") { Err = \"Temperature Alert\"; }\n        //if (bytes[11] == \"4\") { Err = \"Over Range/Flow Alert\"; }\n        //if (bytes[11] == \"3\") { Err = \"Reverse Flow Alert\"; }\n        //if (bytes[11] == \"2\") { Err = \"Empty Pipe Alert\"; }\n        //if (bytes[11] == \"1\") { Err = \"Battery Alert\"; }\n        //if (bytes[11] == \"0\") { Err = \"No Error\"; }\n\n\n        //battery indicator\n        Bat = (bytes[12] - 1) / 253;\n        Battery = (Bat * 100).toFixed(2);\n        return {\n        Command_Code: Code,\n                Data_Length: Len,\n                Data_Type: ID,\n                Count: Count,\n                Unit: Unit,\n                Water_Flow_in_Cubic_Meter: output,\n                Valve_Status: Status,\n                Error_Status_ST2: bittL,\n                Error_Status_ST1: bitst1L,\n                Battery: Battery,\n                Raw_Data: raw\n                };\n    }\n\n\n    //SENDING INTERVAL DECODE\n    else if (bytes[0] == \"34\")\n    {\n        //control code\n        if (bytes[0] == \"34\") { Code = bytes[0].toString(16); }\n        ID = \"Modify Meter Uplink Interval\";\n\n\n\n\n        //data length(not include battery indicator byte)\n        if (bytes[1] == \"10\") { Len = \"Length of the Data Frame : \" + bytes[1]; }\n\n\n        //interval\n        a = bytes[5].toString(16);\n        b = bytes[6].toString(16);\n        concat2 = b.concat(a);\n        interval = parseInt(concat2, 16);\n        inte_unit = \"minutes\";\n\n\n        return {\n        Command_Code: Code,\n                Data_Length: Len,\n                Data_Type: ID,\n                Uplink_Interval: interval,\n                Interval_Unit: inte_unit\n                };\n    }\n\n\n    else if(bytes[0] == \"81\"){\n\n\n        if (bytes.substring(10, 12) == \"2B\") \n        { \n            Unit = \"Cubic Meter\"; \n            decimals = 1000; \n        }\n        var unit = Unit;\n\n\n        a = bytes.substring(12, 14);\n        b = bytes.substring(14, 16);\n        c = bytes.substring(16, 18);\n        d = bytes.substring(18, 20);\n\n\n        a = a.toString(10);\n        b = b.toString(10);\n        c = c.toString(10);\n        d = d.toString(10);\n\n\n        concat1 = d.concat(c);\n        concat2 = b.concat(a);\n        raw = concat1.concat(concat2);\n        var waterFlowInCubicMeter = raw / decimals;\n\n\n        console.log(bytes.substring(24, 26).toString(10))\n\n\n        Bat = (bytes.substring(24, 26).toString(10) - 1) / 253;\n        Battery = (Bat * 100).toFixed(2);\n        var battery = Battery; \n\n\n        return {\n            data: {\n                Unit: unit,\n                WaterFlowInCubicMeter: waterFlowInCubicMeter,\n                Battery: battery\n            },\n            };\n    }\n\n\n    else if(bytes[0].toString(16) == \"fe\"){\n\n        //Cumulative Consumption\n        var unitCumulativeConsuption = bytes[16];\n        var base16UCC = unitCumulativeConsuption.toString(16)\n        var doubleUCC = 0.001\n        var decimalsToFixed = 3;\n        if(base16UCC == \"2b\"){\n            doubleUCC = 0.001\n            decimalsToFixed = 3\n        }\n        else if(base16UCC == \"2c\"){\n            doubleUCC = 0.01\n            decimalsToFixed = 2\n        }\n        else if(base16UCC == \"2e\"){\n            doubleUCC = 1\n            decimalsToFixed = 0\n        }\n        else if(base16UCC == \"35\"){\n            doubleUCC = 0.0001\n            decimalsToFixed = 4\n        }\n\n\n        var cumulativeConsuption1 = bytes[20];\n        var cumulativeConsuption2 = bytes[19];\n        var cumulativeConsuption3 = bytes[18];\n        var cumulativeConsuption4 = bytes[17];\n\n\n        var base16CC1 = cumulativeConsuption1.toString(16).padStart(2, '0');\n        var base16CC2 = cumulativeConsuption2.toString(16).padStart(2, '0');\n        var base16CC3 = cumulativeConsuption3.toString(16).padStart(2, '0');\n        var base16CC4 = cumulativeConsuption4.toString(16).padStart(2, '0');\n\n\n        var base16CC = base16CC1 + base16CC2 + base16CC3 + base16CC4\n        var floatCC = parseFloat(base16CC)\n        var realCumulativeConsumption = (floatCC * doubleUCC).toFixed(decimalsToFixed)\n\n\n        //Previous day Consumption\n        var unitPreviousDayConsuption = bytes[21];\n        var base16UPDC = unitPreviousDayConsuption.toString(16)\n        var doubleUDPC = 0.001\n        if(base16UPDC == \"2b\"){\n            doubleUDPC = 0.001\n            decimalsToFixed = 3\n        }\n        else if(base16UPDC == \"2c\"){\n            doubleUDPC = 0.01\n            decimalsToFixed = 2\n        }\n        else if(base16UPDC == \"2e\"){\n            doubleUDPC = 1\n            decimalsToFixed = 0\n        }\n        else if(base16UPDC == \"35\"){\n            doubleUDPC = 0.0001\n            decimalsToFixed = 4\n        }\n\n\n\n\n        var prevDayConsuption1 = bytes[25];\n        var prevDayConsuption2 = bytes[24];\n        var prevDayConsuption3 = bytes[23];\n        var prevDayConsuption4 = bytes[22];\n\n\n        var base16PDC1 = prevDayConsuption1.toString(16).padStart(2, '0');\n        var base16PDC2 = prevDayConsuption2.toString(16).padStart(2, '0');\n        var base16PDC3 = prevDayConsuption3.toString(16).padStart(2, '0');\n        var base16PDC4 = prevDayConsuption4.toString(16).padStart(2, '0');\n\n\n        var base16PDC = base16PDC1 + base16PDC2 + base16PDC3 + base16PDC4\n        var floatPDC = parseFloat(base16PDC)\n        var realPrevDayConsumption = (floatPDC * doubleUDPC).toFixed(decimalsToFixed)\n\n\n        //Reverse Cumulative Consumption\n        var unitReverseCumulativeConsumption = bytes[26];\n        var base16URCC = unitReverseCumulativeConsumption.toString(16)\n        var doubleURCC = 0.001\n        if(base16URCC == \"2b\"){\n            doubleURCC = 0.001\n            decimalsToFixed = 3\n        }\n        else if(base16URCC == \"2c\"){\n            doubleURCC = 0.01\n            decimalsToFixed = 2\n        }\n        else if(base16URCC == \"2e\"){\n            doubleURCC = 1\n            decimalsToFixed = 0\n        }\n        else if(base16URCC == \"35\"){\n            doubleURCC = 0.0001\n            decimalsToFixed = 4\n        }\n\n\n        var reverseCumulativeConsumption1 = bytes[30];\n        var reverseCumulativeConsumption2 = bytes[29];\n        var reverseCumulativeConsumption3 = bytes[28];\n        var reverseCumulativeConsumption4 = bytes[27];\n\n\n        var base16RCC1 = reverseCumulativeConsumption1.toString(16).padStart(2, '0');\n        var base16RCC2 = reverseCumulativeConsumption2.toString(16).padStart(2, '0');\n        var base16RCC3 = reverseCumulativeConsumption3.toString(16).padStart(2, '0');\n        var base16RCC4 = reverseCumulativeConsumption4.toString(16).padStart(2, '0');\n\n\n        var base16RCC = base16RCC1 + base16RCC2 + base16RCC3 + base16RCC4\n        var floatRCC = parseFloat(base16RCC)\n        var realReverseCumulativeConsumption = (floatRCC * doubleURCC).toFixed(decimalsToFixed)\n\n\n        //Instant Consumption\n        var unitInstantConsumption = bytes[31];\n        var base16UIC = unitInstantConsumption.toString(16)\n        var doubleUIC = 0.001\n        if(base16UIC == \"2b\"){\n            doubleUIC = 0.001\n            decimalsToFixed = 3\n        }\n        else if(base16UIC == \"2c\"){\n            doubleUIC = 0.01\n            decimalsToFixed = 2\n        }\n        else if(base16UIC == \"2e\"){\n            doubleUIC = 1\n            decimalsToFixed = 0\n        }\n        else if(base16UIC == \"35\"){\n            doubleUIC = 0.0001\n            decimalsToFixed = 4\n        }\n\n\n        var instanceConsumption1 = bytes[35];\n        var instanceConsumption2 = bytes[34];\n        var instanceConsumption3 = bytes[33];\n        var instanceConsumption4 = bytes[32];\n\n\n        var base16IC1 = instanceConsumption1.toString(16).padStart(2, '0');\n        var base16IC2 = instanceConsumption2.toString(16).padStart(2, '0');\n        var base16IC3 = instanceConsumption3.toString(16).padStart(2, '0');\n        var base16IC4 = instanceConsumption4.toString(16).padStart(2, '0');\n\n\n        var base16IC = base16IC1 + base16IC2 + base16IC3 + base16IC4\n        var floatIC = parseFloat(base16IC)\n        var realInstantConsumption = (floatIC * doubleUIC).toFixed(decimalsToFixed)\n\n\n        //Water Temperature\n        var waterTemperature1 = bytes[38];\n        var waterTemperature2 = bytes[37];\n        var waterTemperature3 = bytes[36];\n\n\n        var base16WT1 = waterTemperature1.toString(16).padStart(2, '0');\n        var base16WT2 = waterTemperature2.toString(16).padStart(2, '0');\n        var base16WT3 = waterTemperature3.toString(16).padStart(2, '0');\n\n\n        var base16WT = base16WT1 + base16WT2 + base16WT3\n        var floatWT = parseFloat(base16WT)\n        var realWaterTemperature = (floatWT * 0.01).toFixed(2)\n\n\n        //Water Pressure\n        var waterPressure1 = bytes[40];\n        var waterPressure2 = bytes[39];\n\n\n        var base16WP1 = waterPressure1.toString(16).padStart(2, '0');\n        var base16WP2 = waterPressure2.toString(16).padStart(2, '0');\n\n\n        var base16WP = base16WP1 + base16WP2\n        var floatWP = parseFloat(base16WP)\n        var realWaterPressure = (floatWP * 0.001).toFixed(3)\n\n\n\n\n        var ST1 = bytes[48];\n        var ST1Binary = ST1.toString(2).padStart(8, '0');\n\n\n        valveStatusBinary = ST1Binary.substring(6)\n        var valveStatus = \"open\"\n        if(valveStatusBinary == \"00\"){\n            valveStatus = \"open\"\n        } else if(valveStatusBinary == \"01\"){\n            valveStatus = \"close\"\n        } else if(valveStatusBinary == \"11\"){\n            valveStatus = \"abnormal\"\n        }\n\n\n        var batteryAlarmBinary = ST1Binary.substring(5, 6)\n        var batteryAlarm = batteryAlarmBinary == \"0\" ? false : true\n\n\n        var ST2 = bytes[49];\n        var ST2Binary = ST2.toString(2).padStart(8, '0');\n\n\n        var lowBatteryAlarmBinary = ST2Binary.substring(7)\n        var lowBatteryAlarm = lowBatteryAlarmBinary == \"0\" ? false : true\n\n\n        var emptyPipeAlarmBinary = ST2Binary.substring(6,7)\n        var emptyPipeAlarm = emptyPipeAlarmBinary == \"0\" ? false : true\n\n\n        var reverseFlowAlarmBinary = ST2Binary.substring(5,6)\n        var reverseFlowAlarm = reverseFlowAlarmBinary == \"0\" ? false : true\n\n\n        var overRangeAlarmBinary = ST2Binary.substring(4,5)\n        var overRangeAlarm = overRangeAlarmBinary == \"0\" ? false : true\n\n\n        var overTemperatureAlarmBinary = ST2Binary.substring(3,4)\n        var overTemperatureAlarm = overTemperatureAlarmBinary == \"0\" ? false : true\n\n\n        var EEPROMErrorBinary = ST2Binary.substring(2,3)\n        var EEPROMError = EEPROMErrorBinary == \"0\" ? false : true\n\n\n        var leakageAlarmBinary = ST2Binary.substring(1,2)\n        var leakageAlarm = leakageAlarmBinary == \"0\" ? false : true\n\n\n        var burstAlarmBinary = ST2Binary.substring(0,1)\n        var burstAlarm = burstAlarmBinary == \"0\" ? false : true\n\n\n        return {\n            data: {\n                CumulativeConsumption: realCumulativeConsumption,\n                PreviousDayConsumption: realPrevDayConsumption,\n                ReverseCumulativeConsumption: realReverseCumulativeConsumption,\n                InstantConsumption: realInstantConsumption,\n                WaterTemperature: realWaterTemperature,\n                WaterPressure: realWaterPressure,\n                ValveStatus: valveStatus,\n                BatteryAlarm: batteryAlarm,\n                LowBatteryAlarm: lowBatteryAlarm,\n                EmptyPipeAlarm: emptyPipeAlarm,\n                ReverseFlowAlarm: reverseFlowAlarm,\n                OverRangeAlarm: overRangeAlarm,\n                OverTemperatureAlarm: overTemperatureAlarm,\n                EEPROMERROR: EEPROMError,\n                LeakageAlarm: leakageAlarm,\n                BurstAlarm: burstAlarm\n            },\n        };\n    }\n}\n</code></pre> <ul> <li>IQSV DC and BP (new ones - from Sep/2025):</li> </ul> <p>Attributes: BatteryAlarm: bool CumulativeConsumption: decimal (water flow since the moment the device is turned ON) -&gt; * 264.172052 = value in gallons EEPROMERROR: bool (no idea what is it)   EmptyPipeAlarm: bool (when no flow)   InstantConsumption: decimal (water flow in this moment PER HOUR) -&gt; * 264.172052 = value in gallons LeakageAlarm: bool (when there is a leak in the device/pipe) LowBatteryAlarm: bool (when the battery is low)  OverRangeAlarm: bool (no idea what is it) OverTemperatureAlarm: bool (temperature defined in the firmware) PreviousDayConsumption: decimal (water flow yesterday)  -&gt; * 264.172052 = value in gallons ReverseCumulativeConsumption: decimal (if there is a flow in reverse) -&gt;  * 264.172052 = value in gallons ReverseFlowAlarm: bool (when reverse flow) ValveStatus: open/close/ half-open (25%, 50% or 75%) WaterPressure: decimal (in MPA) -&gt; * 145.038 to convert to PSI WaterTemperature: decimal (in Celsius) -&gt; Need to convert to \u00b0F PowerSupply: Battery/External Power Supply </p> <p>Payload:</p> <p>Bytes: FEFE68100000000000000000000000002324000000000200C11615</p> <p>Criptographic: /v5oEAAAAAAAAAAAAAAAACMkAAAAAAIAwRYV</p> <p>Decoded:</p> <pre><code>{\n    \"BatteryAlarm\": false,\n    \"BurstAlarm\": false,\n    \"CumulativeConsumption\": \"612.461\",\n    \"EEPROMERROR\": false,\n    \"EmptyPipeAlarm\": false,\n    \"InstantConsumption\": \"0.0000\",\n    \"LeakageAlarm\": false,\n    \"LowBatteryAlarm\": false,\n    \"OverRangeAlarm\": false,\n    \"OverTemperatureAlarm\": false,\n    \"PreviousDayConsumption\": \"552.181\",\n    \"ReverseCumulativeConsumption\": \"0.000\",\n    \"ReverseFlowAlarm\": false,\n    \"ValveStatus\": \"open\",\n    \"WaterPressure\": \"0.281\",\n    \"WaterTemperature\": \"23.65\"\n}\n</code></pre> <p>Payload Formatter (TTN):</p> <pre><code>function decodeUplink(input) {\n  const bytes = input.bytes;\n  const toLEHex = (arr) =&gt;\n    arr.map(b =&gt; b.toString(16).padStart(2, \"0\")).reverse().join(\"\").toUpperCase();\n\n\n  const applyScale = (digitStr, scale) =&gt; {\n    const s = digitStr.replace(/[^0-9]/g, \"\");\n    let core = s.replace(/^0+/, \"\");\n    if (core.length === 0) core = \"0\";\n\n\n    if (core.length &lt;= scale) core = core.padStart(scale + 1, \"0\");\n\n\n    const p = core.length - scale;\n    const withPoint = core.slice(0, p) + \".\" + core.slice(p);\n    return withPoint.startsWith(\".\") ? \"0\" + withPoint : withPoint;\n  };\n\n\n  let off = 4;\n\n\n  const cumulativeHex = toLEHex(bytes.slice(off, off + 4)); off += 4;\n  const cumulativeStr = applyScale(cumulativeHex, 3);\n\n\n  const reverseHex = toLEHex(bytes.slice(off, off + 4)); off += 4;\n  const reverseStr = applyScale(reverseHex, 3);\n\n\n  const flowHex = toLEHex(bytes.slice(off, off + 4)); off += 4;\n  const flowStr = applyScale(flowHex, 4);\n\n\n  const tempHex = toLEHex(bytes.slice(off, off + 3)); off += 3;\n  const tempStr = applyScale(tempHex, 2);\n\n\n  const pressureHex = toLEHex(bytes.slice(off, off + 2)); off += 2;\n  const pressureStr = applyScale(pressureHex, 3);\n\n\n  const st1 = bytes[off++];\n  const valveBits = st1 &amp; 0b11;\n  const ValveStatus = (valveBits === 0b00) ? \"open\"\n                    : (valveBits === 0b01) ? \"close\"\n                    : (valveBits === 0b10) ? \"half-open\"\n                    : \"abnormal\";\n  const BatteryAlarm = (st1 &amp; 0b00000100) !== 0;\n\n\n  const st2 = bytes[off++];\n  const LowBatteryAlarm    = (st2 &amp; 0b00000001) !== 0;\n  const EmptyPipeAlarm     = (st2 &amp; 0b00000010) !== 0;\n  const ReverseFlowAlarm   = (st2 &amp; 0b00000100) !== 0;\n  const OverRangeAlarm     = (st2 &amp; 0b00001000) !== 0;\n  const OverTemperatureAlarm = (st2 &amp; 0b00010000) !== 0;\n  const EEPROMERROR        = (st2 &amp; 0b00100000) !== 0;\n  const LeakageAlarm       = (st2 &amp; 0b01000000) !== 0;\n\n\n  const powerSupplyByte = bytes[off++];\n  const PowerSupply = (powerSupplyByte === 0x00) ? \"Battery\" : \"Connected\";\n\n\n\n\n  return {\n    data: {\n      CumulativeConsumption: cumulativeStr,         \n      ReverseCumulativeConsumption: reverseStr,\n      InstantConsumption: flowStr,\n      WaterTemperature: tempStr,\n      WaterPressure: pressureStr,\n      LowBatteryAlarm,\n      EmptyPipeAlarm,\n      ReverseFlowAlarm,\n      OverRangeAlarm,\n      OverTemperatureAlarm,\n      EEPROMERROR,\n      LeakageAlarm,\n      ValveStatus,\n      BatteryAlarm,\n      PowerSupply\n    }\n  }\n}\n</code></pre>"},{"location":"#iqwm","title":"IQWM","text":"<p>IQWM devices are installed directly in the pipe and measure the water flow. It sends one uplink every 6 hours and has the history of water consumption in the last 12 hours. If one uplink failes, the consumption can be recovered in the next uplink, since the next one will be sent after 6 hours and it contains the last 12 hours of consumption history </p> <p>Attributes: batteryStatus: decimal clockDate: 09/22 (date - example: Sep 22th)   clockTime: 11:16 (time - example 11h16m)   currentReading: decimal (water flow since the moment the device is turned ON) -&gt; * 264.172052 = value in gallons   burstAlarm: bool (same as IQSV)   eepromError: bool (same as IQSV)   emptyPipeAlarm: bool (same as IQSV)   freezingAlarm: bool (when freezed)   leakageAlarm: bool (same as IQSV) lowBatteryAlarm: bool (same as IQSV) overRangeAlarm: bool  (same as IQSV) overTemperatureAlarm: bool  (same as IQSV) reverseFlowAlarm: bool  (same as IQSV) tamperAlarm: bool (when moved) log-1: decimal (* 264.172052 = consumption gallons) log-1-Time: \"23:00 00:00\" (initial and final time reading) ... log-12: decimal, log-12-Time: \"10:00 11:00\" (initial and final time reading)  </p> <p>Payload:</p> <p>Bytes: FEFEBA9003006D000F00080012000600000008001D00EF001B00040007000006092211167BFE</p> <p>Criptographic: /v66kAMAbQAPAAgAEgAGAAAACAAdAO8AGwAEAAcAAAYJIhEWe/4=</p> <p>Decoded:</p> <pre><code>{\n    \"batteryStatus\": 100,\n    \"clockDate\": \"09/22\",\n    \"clockTime\": \"11:16\",\n    \"currentReading\": 233.658,\n    \"meterStatus\": {\n      \"flags\": {\n        \"burstAlarm\": false,\n        \"eepromError\": false,\n        \"emptyPipeAlarm\": true,\n        \"freezingAlarm\": false,\n        \"leakageAlarm\": false,\n        \"lowBatteryAlarm\": false,\n        \"overRangeAlarm\": false,\n        \"overTemperatureAlarm\": false,\n        \"reserved1\": false,\n        \"reserved2\": false,\n        \"reserved3\": false,\n        \"reserved4\": false,\n        \"reserved5\": false,\n        \"reserved6\": false,\n        \"reverseFlowAlarm\": true,\n        \"tamperAlarm\": false\n      },\n      \"raw\": 1536\n    },\n    \"parameters\": [\n      {\n        \"log-1\": 0.109,\n        \"log-1-Time\": \"23:00 00:00\"\n      },\n      {\n        \"log-2\": 0.015,\n        \"log-2-Time\": \"00:00 01:00\"\n      },\n      {\n        \"log-3\": 0.008,\n        \"log-3-Time\": \"01:00 02:00\"\n      },\n      {\n        \"log-4\": 0.018,\n        \"log-4-Time\": \"02:00 03:00\"\n      },\n      {\n        \"log-5\": 0.006,\n        \"log-5-Time\": \"03:00 04:00\"\n      },\n      {\n        \"log-6\": 0,\n        \"log-6-Time\": \"04:00 05:00\"\n      },\n      {\n        \"log-7\": 0.008,\n        \"log-7-Time\": \"05:00 06:00\"\n      },\n      {\n        \"log-8\": 0.029,\n        \"log-8-Time\": \"06:00 07:00\"\n      },\n      {\n        \"log-9\": 0.239,\n        \"log-9-Time\": \"07:00 08:00\"\n      },\n      {\n        \"log-10\": 0.027,\n        \"log-10-Time\": \"08:00 09:00\"\n      },\n      {\n        \"log-11\": 0.004,\n        \"log-11-Time\": \"09:00 10:00\"\n      },\n      {\n        \"log-12\": 0.007,\n        \"log-12-Time\": \"10:00 11:00\"\n      }\n    ]\n}\n</code></pre> <p>Payload Formatter (TTN):</p> <pre><code>function decodeUplink(input) {\n  const bytes = input.bytes;\n\n\n  // Fixed sizes\n  const startBytesSize = 4; // 4 bytes\n  const logEntriesSize = 12 * 2; // 12 logs, each 2 bytes\n  const meterStatusSize = 2; // 2 bytes\n  const timestampSize = 4; // 4 bytes (clock format)\n  const batteryStatusSize = 1; // 1 byte (last byte)\n\n\n  const fixedSize = startBytesSize + logEntriesSize + meterStatusSize + timestampSize + batteryStatusSize;\n\n\n  // Validate byte array length\n  if (bytes.length &lt;= fixedSize) {\n    return { data: {}, warnings: [], errors: [\"Invalid byte array length. Expected fixed size.\"] };\n  }\n\n\n\n\n  let hexString = bytes.map((byte) =&gt; byte.toString(16).padStart(2, '0')).join('');\n  hexString = hexString.substring(4); // Remove the first 2 bytes\n\n\n  // Extract Current Reading (first 4 bytes) and convert to integer (Little Endian)\n  const currentReadingHex = hexString.substring(0, 8);\n  const currentReadingLittleEndian =\n    currentReadingHex.substring(6, 8) +\n    currentReadingHex.substring(4, 6) +\n    currentReadingHex.substring(2, 4) +\n    currentReadingHex.substring(0, 2);\n  const currentReading = (parseInt(currentReadingLittleEndian, 16) / 1000).toFixed(3);\n\n\n  // Extract 12 log entries (convert each to Little Endian signed 16-bit integer)\n  const parameters = [];\n  let index = 8; // Start after currentReading\n  for (let i = 0; i &lt; 12; i++) {\n    const paramHex = hexString.substring(index, index + 4);\n    const littleEndianHex = paramHex.substring(2, 4) + paramHex.substring(0, 2);\n    const paramInt = toSignedInt16(parseInt(littleEndianHex, 16))/1000;\n    parameters.push(paramInt);\n    index += 4;\n  }\n\n\n  // Extract Meter Status (2 bytes) and parse flags\n  const meterStatusHex = hexString.substring(index, index + 4);\n  const littleEndianMeterStatus =\n    meterStatusHex.substring(2, 4) + meterStatusHex.substring(0, 2);\n  const meterStatus = parseInt(littleEndianMeterStatus, 16);\n\n\n  const meterStatusFlags = {};\n  const firstByte = parseInt(littleEndianMeterStatus.substring(0, 2), 16);\n  meterStatusFlags.lowBatteryAlarm = Boolean(firstByte &amp; 0b00000001);\n  meterStatusFlags.emptyPipeAlarm = Boolean(firstByte &amp; 0b00000010);\n  meterStatusFlags.reverseFlowAlarm = Boolean(firstByte &amp; 0b00000100);\n  meterStatusFlags.overRangeAlarm = Boolean(firstByte &amp; 0b00001000);\n  meterStatusFlags.overTemperatureAlarm = Boolean(firstByte &amp; 0b00010000);\n  meterStatusFlags.eepromError = Boolean(firstByte &amp; 0b00100000);\n  meterStatusFlags.reserved1 = Boolean(firstByte &amp; 0b01000000);\n  meterStatusFlags.reserved2 = Boolean(firstByte &amp; 0b10000000);\n\n\n  const secondByte = parseInt(littleEndianMeterStatus.substring(2, 4), 16);\n  meterStatusFlags.leakageAlarm = Boolean(secondByte &amp; 0b00000100);\n  meterStatusFlags.burstAlarm = Boolean(secondByte &amp; 0b00001000);\n  meterStatusFlags.tamperAlarm = Boolean(secondByte &amp; 0b00010000);\n  meterStatusFlags.freezingAlarm = Boolean(secondByte &amp; 0b00100000);\n  meterStatusFlags.reserved3 = Boolean(secondByte &amp; 0b00000001);\n  meterStatusFlags.reserved4 = Boolean(secondByte &amp; 0b00000010);\n  meterStatusFlags.reserved5 = Boolean(secondByte &amp; 0b01000000);\n  meterStatusFlags.reserved6 = Boolean(secondByte &amp; 0b10000000);\n\n\n  index += 4;\n\n\n  // Extract Clock Time (4 bytes)\n  const clockHex = hexString.substring(index, index + 8);\n\n  const hours = parseInt(clockHex.substring(4, 6), 10); // First 2 hex digits represent hours\n  const minutes = parseInt(clockHex.substring(6, 8), 10); // Last 2 hex digits represent minutes\n  const clockTime = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;\n\n  const day = parseInt(clockHex.substring(0, 2), 10); // Last 2 hex digits represent minutes\n\n  const month = parseInt(clockHex.substring(2, 4), 10); // Last 2 hex digits represent minutes\n  const clockDate = `${day.toString().padStart(2, '0')}/${month.toString().padStart(2, '0')}`;\n\n\n\n  index += 8;\n\n  var hrs = hours;\n\n// Initialize the combined array\nvar combined_time_array = [];\n\n\n// Generate the past 12 entries\nfor (let i = 0; i &lt; 12; i++) {\n  // Format the current hour and minute as HH:MM\n  let currentTime = `${hrs.toString().padStart(2, '0')}:00`;\n\n\n  // Calculate the previous hour\n  let previousHrs = hrs - 1;\n  if (previousHrs &lt; 0) {\n    previousHrs = 23; // Handle rollover to the previous day\n  }\n\n\n  // Format the previous hour and minute as HH:MM\n  let previousTime = `${previousHrs.toString().padStart(2, '0')}:00`;\n\n\n  // Combine the two times and add to the array\n  combined_time_array.push(`${previousTime} ${currentTime}`);\n\n\n  // Decrement the hour\n  hrs -= 1;\n\n\n  // Handle rollover to the previous day\n  if (hrs &lt; 0) {\n    hrs = 23;\n  }\n}\n\n\n  // Extract Battery Status (1 byte, last byte of the array) and divide by 2.54\n  const batteryStatusRaw = parseInt(hexString.substring(hexString.length - 2), 16);\n  const batteryStatus = (batteryStatusRaw / 2.54).toFixed(2);\n\n\n  // Prepare the response\n  return {\n    data: {\n      currentReading: parseFloat(currentReading), // Convert back to number for output\n      parameters: parameters.map((param, i) =&gt; ({ [`log-${i + 1}`]: param , [`log-${i + 1}-Time`]: combined_time_array[11-i]})), // Signed 16-bit integers\n      meterStatus: {\n        raw: meterStatus,\n        flags: meterStatusFlags\n      },\n      clockTime, // Time as HH:MM\n      clockDate, // Month/Day \n      batteryStatus: parseFloat(batteryStatus), // Convert back to number for output\n    },\n    warnings: [],\n    errors: []\n  };\n}\n\n\n// Helper function to convert int16_t to signed number\nfunction toSignedInt16(value) {\n  value = value &amp; 0xFFFF; // Ensure 16 bits\n  if (value &amp; 0x8000) { // Check MSB for negative\n    return value - 0x10000; // Convert to signed\n  }\n  return value; // Positive values remain unchanged\n}\n</code></pre>"},{"location":"#lambdas-for-example","title":"Lambdas for example","text":""},{"location":"#lambda-functions","title":"Lambda Functions","text":"<p>The Lambda functions are the core of the system. They handle all calculations and business logic decisions.</p>"},{"location":"#lambda-function-process_iqsl","title":"Lambda Function: <code>Process_iqsl</code>","text":""},{"location":"#purpose","title":"Purpose","text":"<p>Only for Water Leak Devices of type IQSL. Doesn't include Toilet Sensors</p>"},{"location":"#main-operations-and-algorithms","title":"Main Operations and Algorithms:","text":"<ul> <li> <p>Temperature: from Celcius to Fahrenheit</p> </li> <li> <p>Saves all connected gateways in a list and saves it in the database.</p> </li> <li> <p>Saves data in the iqwl_data table and updates the latest data in the devices_last_data table.</p> </li> </ul> <p>Note: Alerts are not sent by this Lambda. This Lambda sends data to another Lambda (SendAlertNotification) and that one will decide whether to send an alert.</p>"},{"location":"#input-source","title":"Input Source","text":"<p>Receives messages from the following SQS queue: <code>iqsl_uplink_queue</code></p>"},{"location":"#output-destinations","title":"Output Destinations","text":"<ul> <li>Sends data to Lambda: <code>SendAlertNotification</code></li> <li>Stores data in the following tables:</li> <li><code>devices_details</code></li> <li><code>iqsl_data</code></li> <li><code>devices_last_data</code></li> </ul>"},{"location":"#input-format-json","title":"Input Format (JSON)","text":"<pre><code>{\n    \"device_id\": \"123\",\n    \"application_id\": \"app1\",\n    \"dev_eui\": \"1234\",\n    \"read_time\": \"2025-07-02T19:16:38.982846975Z\",\n    \"payload_type\": \"Heartbeat\",\n    \"payload_type_id\": 1,\n    \"battery_percentage\": 38,\n    \"battery_voltage\": 3.16,\n    \"external_leak_detection_enabled\": true,\n    \"pin_leak_detection_enabled\": true,\n    \"tamper_detection_enabled\": true,\n    \"humidity\": 54.2,\n    \"last_rssi\": -42,\n    \"last_snr\": 13,\n    \"external_leak_detected\": false,\n    \"jack_detected\": false,\n    \"magnet_detected\": false,\n    \"pin_leak_detected\": false,\n    \"power_detected\": false,\n    \"state_as_uint8\": 7,\n    \"temperature\": 24.33,\n    \"frame_count\": 2677,\n    \"metadata\": [\n        {\n            \"gateway_ids\": {\n                \"gateway_id\": \"eui-58a0cbfffe8040c1\",\n                \"eui\": \"58A0CBFFFE8040C1\"\n            },\n            \"time\": \"2025-07-02T19:16:38.982846975Z\",\n            \"timestamp\": 2143403483,\n            \"rssi\": -63,\n            \"channel_rssi\": -63,\n            \"snr\": 9.25,\n            \"uplink_token\": \"CiIKIAoUZXVpLTU4YTBjYmZmZmU4MDQwYzESCFigy//+gEDBENv7hv4HGgwIl4uWwwYQyZ28jAEg+L625rA+\",\n            \"received_at\": \"2025-07-02T19:16:39.241239981Z\"\n        },\n        {\n            \"gateway_ids\": {\n                \"gateway_id\": \"iqgw-tk-20\",\n                \"eui\": \"647FDAFFFE01F36D\"\n            },\n            \"timestamp\": 1245444315,\n            \"rssi\": -78,\n            \"channel_rssi\": -78,\n            \"snr\": 9.5,\n            \"uplink_token\": \"ChgKFgoKaXFndy10ay0yMBIIZH/a//4B820Q2/Hv0QQaDAiXi5bDBhCLqciXASD4rpDSn+UU\",\n            \"received_at\": \"2025-07-02T19:16:39.125916168Z\"\n        }\n    ]\n}\n</code></pre>"},{"location":"#lambda-function-process_long_flush_iqsl","title":"Lambda Function: <code>Process_long_flush_iqsl</code>","text":""},{"location":"#purpose_1","title":"Purpose","text":"<p>Only for Toilet Sensor Devices from type IQSL filtered by the uplinks of type LONG_FLUSH (payload_type_id = 10).</p>"},{"location":"#main-operations-and-algorithms_1","title":"Main Operations and Algorithms:","text":""},{"location":"#how-does-long-flush-work","title":"How Does Long Flush Work?","text":"<p>The device only sends the uplink after 3 minutes (default) of continuous flushing. In other words, when the uplink is received, the flushing has already been occurring for 3 minutes. Because of that, the Lambda must register that the flush started 3 minutes earlier.</p>"},{"location":"#end-of-flush","title":"End of Flush","text":"<p>When a flush ends, a different type of uplink is sent: Last Event Water Usage (<code>payload_type_id = 11</code>). However, this uplink is processed by another Lambda: <code>Process_water_usage_iqsl</code>.</p>"},{"location":"#custom-long-flush-duration","title":"Custom Long Flush Duration","text":"<p>The user can request the device to register a flush only after 4 or more minutes. In this case:</p> <ol> <li>An external API (not the Lambda) stores on the device the setting that long flush should be recorded after 4+ minutes.</li> <li>The Lambda checks the device settings in the database.</li> <li>Based on the setting:</li> <li>If it's set to 3 minutes (default):      The long flush is recorded normally.</li> <li>If it's set to more than 3 minutes (late long flush): <ul> <li>The long flush is saved to the database.  </li> <li>The property <code>long_event_hide_on_dashboard</code> is set to <code>False</code>, so it won't appear on the Dashboard.  </li> <li>A schedule is created in EventBridge to trigger the long flush later via the <code>LateLongFlush</code> Lambda.</li> </ul> </li> </ol>"},{"location":"#notes","title":"Notes","text":"<ul> <li> <p>There is no information about gallons used in the flush in this uplink.   This data will arrive in a separate uplink of type Last Event Water Usage (<code>payload_type_id = 11</code>).</p> </li> <li> <p>The device is renamed with a <code>-flow</code> suffix to distinguish Toilet Sensor data from Leak Sensor data,   since IQSL includes both sensor types in the same transmitter.</p> </li> </ul>"},{"location":"#input-source_1","title":"Input Source","text":"<p>Receives messages from the following SQS queue: <code>iqsl_long_flush_uplink_queue</code></p>"},{"location":"#output-destinations_1","title":"Output Destinations","text":"<ul> <li>Sends data to Lambda: <code>SendAlertToiletNotification</code>, <code>LateLongFlush</code></li> <li>Stores data in the following tables:</li> <li><code>devices_details</code></li> <li><code>iqsl_alerts_data</code></li> <li><code>devices_last_data</code></li> </ul>"},{"location":"#input-format-json_1","title":"Input Format (JSON)","text":"<pre><code>{\n    \"device_id\": \"123\",\n    \"application_id\": \"app2\",\n    \"dev_eui\": \"1234\",\n    \"read_time\": \"2025-07-02T19:11:57.283046007Z\",\n    \"payload_type\": \"Alert\",\n    \"payload_type_id\": 10,\n    \"alert_type\": \"Pulse Counting (Long Event Alert)\",\n    \"current_status\": 1,\n    \"pulse_duration_trigger\": 180000,\n    \"frame_count\": 3642\n}\n</code></pre>"},{"location":"#lambda-function-process_water_usage_iqsl","title":"Lambda Function: <code>Process_water_usage_iqsl</code>","text":""},{"location":"#purpose_2","title":"Purpose","text":"<p>Only for Toilet Sensor Devices from type IQSL filtered by the uplinks of type WATER_USAGE (payload_type_id = 11).</p>"},{"location":"#main-operations-and-algorithms_2","title":"Main Operations and Algorithms:","text":""},{"location":"#how-does-water-usage-work","title":"How Does Water Usage Work?","text":"<p>Gallons_spent = Pulse_total_pulses * 0.264172</p> <p>Water usage can occur after a normal flush or after a Long Flush.</p> <p>If it is after a normal flush, then it simply records in the database that a flush occurred without needing to calculate when the flush started. However, there can be two types:</p> <ul> <li>Above 1 gallon: \"normal flush\"</li> <li>Equal to or less than 1 gallon: \"escape\" (value too low to be a real flush)</li> </ul> <p>If it is after a Long Flush, then:</p> <ul> <li>If the Long Flush has already been registered, then this Water Usage must be recorded at the moment the Long Flush started. The type of this flush must be \"long\".</li> <li>If the Long Flush has not yet been registered on the dashboard [see late long flush], then the Long Flush should not appear on the dashboard. Instead, it should appear as a normal flush, without the need to calculate when the flush started.</li> </ul>"},{"location":"#input-source_2","title":"Input Source","text":"<p>Receives messages from the following SQS queue: <code>iqsl_water_usage_uplink_queue</code></p>"},{"location":"#output-destinations_2","title":"Output Destinations","text":"<ul> <li>Sends data to Lambda: <code>SendAlertToiletNotification</code></li> <li>Stores data in the following tables:</li> <li><code>devices_details</code></li> <li><code>iqsl_alerts_data</code></li> <li><code>devices_last_data</code></li> </ul>"},{"location":"#input-format-json_2","title":"Input Format (JSON)","text":"<pre><code>{\n    \"device_id\": \"123\",\n    \"application_id\": \"app1\",\n    \"dev_eui\": \"1234\",\n    \"read_time\": \"2025-07-02T20:13:31.984311103Z\",\n    \"payload_type\": \"Alert\",\n    \"payload_type_id\": 11,\n    \"alert_type\": \"Pulse Counting Event (Last Event Usage)\",\n    \"humidity\": 54.33,\n    \"temperature\": 23.64,\n    \"pulse_device_type_id\": 1,\n    \"pulse_total_pulses\": 2902,\n    \"pulse_total_liters\": 2.694521819870009,\n    \"frame_count\": 24465\n}\n</code></pre>"},{"location":"#lambda-function-process_toilet_heartbeat_iqsl","title":"Lambda Function: <code>Process_toilet_heartbeat_iqsl</code>","text":""},{"location":"#purpose_3","title":"Purpose","text":"<p>Only for Toilet Sensor Devices from Type IQSL filtered by the uplinks of type HEARTBEAT (payload_type_id = 9).</p>"},{"location":"#main-operations-and-algorithms_3","title":"Main Operations and Algorithms:","text":""},{"location":"#how-does-the-heartbeat-work","title":"How Does the Heartbeat Work?","text":"<p>The heartbeat shows what has occurred since the last heartbeat:</p> <ul> <li>Number of flushes  </li> <li>Gallons spent  </li> </ul> <p>Note: If a long flush is currently happening and has not yet finished, and a heartbeat is sent, then the gallons spent during this ongoing long flush are pre-calculated.</p>"},{"location":"#input-source_3","title":"Input Source","text":"<p>Receives messages from the following SQS queue: <code>IQWLWaterLeakUplinkQueue</code></p>"},{"location":"#output-destinations_3","title":"Output Destinations","text":"<ul> <li>Sends data to Lambda: <code>iqsl_toilet_heartbeat_uplink_queue</code></li> <li>Stores data in the following tables:</li> <li><code>devices_details</code></li> <li><code>iqsl_alerts_data</code></li> <li><code>devices_last_data</code></li> </ul>"},{"location":"#input-format-json_3","title":"Input Format (JSON)","text":"<pre><code>{\n    \"device_id\": \"123\",\n    \"application_id\": \"app1\",\n    \"dev_eui\": \"1234\",\n    \"read_time\": \"2025-07-02T20:18:57.869425058Z\",\n    \"payload_type\": \"Alert\",\n    \"payload_type_id\": 9,\n    \"alert_type\": \"Pulse Counting (Total Events)\",\n    \"pulse_long_event_triggered\": 0,\n    \"pulse_alert_interval\": 500,\n    \"pulse_device_type_id\": 1,\n    \"pulse_total_events\": 11,\n    \"pulse_total_pulses\": 11,\n    \"pulse_total_liters\": 0.01021355617455896,\n    \"frame_count\": 325\n}\n</code></pre>"},{"location":"#lambda-function-process_alerts_iqsl","title":"Lambda Function: <code>Process_alerts_iqsl</code>","text":""},{"location":"#purpose_4","title":"Purpose","text":"<p>Only for Leak Sensor and Toilet Sensor Devices of type IQSL filtered by the uplinks of payload_type_id = 1,2,3,4,5,6,7,8 and 12.</p>"},{"location":"#main-operations-and-algorithms_4","title":"Main Operations and Algorithms:","text":""},{"location":"#processing-based-on-payload_type_id","title":"Processing Based on <code>payload_type_id</code>","text":"<p>Depending on the <code>payload_type_id</code>, the processing is different:</p> <ul> <li> <p>payload_type_id = 1 \u2192 Leak Detected External (LEAK SENSOR)   Saves the event and calls the Lambda SendAlertNotification to send an alert.</p> </li> <li> <p>payload_type_id = 2 \u2192 Leak Detected Local (LEAK SENSOR)   Saves the event and calls the Lambda SendAlertNotification to send an alert.</p> </li> <li> <p>payload_type_id = 3 \u2192 Tamper (LEAK SENSOR)   Saves the event. This uplink is sent when the device comes into contact with the magnet (not actual movement).</p> </li> <li> <p>payload_type_id = 4 \u2192 Button Pressed (LEAK SENSOR)   Saves the event.</p> </li> <li> <p>payload_type_id = 5 \u2192 High Temperature (LEAK SENSOR)   Saves the event and calls the Lambda SendAlertNotification to send an alert.</p> </li> <li> <p>payload_type_id = 6 \u2192 Low Temperature (LEAK SENSOR)   Saves the event and calls the Lambda SendAlertNotification to send an alert.</p> </li> <li> <p>payload_type_id = 7 \u2192 High Humidity (LEAK SENSOR)   Saves the event and calls the Lambda SendAlertNotification to send an alert.</p> </li> <li> <p>payload_type_id = 8 \u2192 Low Humidity (LEAK SENSOR)   Saves the event and calls the Lambda SendAlertNotification to send an alert.</p> </li> <li> <p>payload_type_id = 12 \u2192 Headphone Jack Alert (LEAK SENSOR)   Saves the event.</p> </li> </ul>"},{"location":"#input-source_4","title":"Input Source","text":"<p>Receives messages from the following SQS queue: <code>iqsl_alerts_uplink_queue</code></p>"},{"location":"#output-destinations_4","title":"Output Destinations","text":"<ul> <li>Sends data to Lambda: <code>SendAlertNotification</code>, <code>SendAlertToiletNotification</code></li> <li>Stores data in the following tables:</li> <li><code>devices_details</code></li> <li><code>iqsl_data</code></li> <li><code>iqsl_alerts_data</code></li> <li><code>devices_last_data</code></li> </ul>"},{"location":"#input-format-json-example-only-for-payload_type_id-2","title":"Input Format (JSON) - example only for payload_type_id = 2","text":"<pre><code>{\n    \"device_id\": \"123\",\n    \"application_id\": \"app4\",\n    \"dev_eui\": \"1234\",\n    \"read_time\": \"2025-07-02T18:46:19.129642963Z\",\n    \"payload_type\": \"Alert\",\n    \"payload_type_id\": 2,\n    \"alert_type\": \"Local Leak Detection (Via Bottom Contact Pins)\",\n    \"current_status\": 0,\n    \"current_value\": 3044,\n    \"humidity\": 49.23,\n    \"temperature\": 23.68,\n    \"delay_count\": 1,\n    \"trigger_value\": 5000,\n    \"frame_count\": 2789\n}\n</code></pre>"},{"location":"#downlinks","title":"Downlinks","text":"<p>Tip: use this site to facilitate the convert from base to hex base64-to-hex</p>"},{"location":"#working-on","title":"Working on...","text":"<p>Downlinks Alerts</p>"},{"location":"architecture/","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"architecture/#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live- docs server.</li> <li><code>mkdocs build</code> - Build the documreloadingentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"architecture/#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"}]}